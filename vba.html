<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="vba.css">

    <title>24時間散歩おじさん～VBA汎用コード置き場～</title>
    <meta property="og:url" content="https://office-diet.github.io/vba.html" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="24時間散歩おじさん～VBA汎用コード置き場～" />
    <meta property="og:description" content="24時間散歩おじさん～VBA汎用コード置き場～" />
    <meta property="og:site_name" content="24時間散歩おじさん～VBA汎用コード置き場～" />
    <meta property="og:image" content="https://office-diet.github.io/vba.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@office_diet" />  
</head>
<body>
    <header>
        <div class="container">
            <a href="https://twitter.com/office_diet" target="_blank">24時間散歩おじさん VBA汎用コード置き場</a>
        </div>
    </header>
    <main>
        <div class="container">
            <div class="code-body">
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 最終行・列を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetLastRow(ByVal ws As Worksheet, ByVal strColumn As String) As Long
        
        GetLastRow = ws.Cells(ws.Rows.Count, strColumn).End(xlUp).Row
        
    End Function
    
    Function GetLastColumn(ByVal ws As Worksheet, ByVal lngRow As Long) As Long
        
        GetLastColumn = ws.Cells(lngRow, ws.Columns.Count).End(xlToLeft).Column
        
    End Function
    
    Function SearchLastRow(ByVal ws As Worksheet, aryColumns As Variant)
        Dim vntColumn As Variant
        Dim lngFindLastRow As Long
        For Each vntColumn In aryColumns
            lngFindLastRow = Max(lngFindLastRow, GetLastRow(ws, vntColumn))
        Next
        SearchLastRow = lngFindLastRow
    End Function
    
    Function SearchLastColumn(ByVal ws As Worksheet, aryRows As Variant)
        Dim vntRow As Variant
        Dim lngFindLastColumn As Long
        For Each vntRow In aryRows
            lngFindLastColumn = Max(lngFindLastColumn, GetLastRow(ws, vntRow))
        Next
        SearchLastColumn = lngFindLastColumn
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' MIN・MAX関数をラップ・機能拡張
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '「Min（エクセル関数）」
    Function Min(ParamArray aryValues() As Variant) As Variant
        Min = Application.WorksheetFunction.Min(aryValues)
    End Function
    
    '「Max（エクセル関数）」
    Function Max(ParamArray aryValues() As Variant) As Variant
        Max = Application.WorksheetFunction.Max(aryValues)
    End Function
    
    '絶対値の最小値
    Function MinAbs(ParamArray aryValues() As Variant) As Variant
        
        Dim vntValue As Variant
        Dim vntMin As Variant
        
        vntMin = aryValues(0)
        For Each vntValue In aryValues
            If Abs(vntMin) > Abs(vntValue) Then
                vntMin = vntValue
            End If
        Next
        MinAbs = vntMin
        
    End Function
    
    '絶対値の最大値
    Function MaxAbs(ParamArray aryValues() As Variant) As Variant
        
        Dim vntValue As Variant
        Dim vntMax As Variant
        
        vntMax = aryValues(0)
        For Each vntValue In aryValues
            If Abs(vntMax) < Abs(vntValue) Then
                vntMax = vntValue
            End If
        Next
        MaxAbs = vntMax
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' VLOOKUP関数をラップ・機能拡張
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '文字列・数値の不一致による検索失敗・エラーを回避
    Function VlookUp(ByVal vntKey As Variant, ByVal rngTable As Range, lngColumn As Long) As Variant
        
        Dim vntFindValue As Variant
        
        '引数そのまま検索
        On Error Resume Next
        vntFindValue = Application.WorksheetFunction.VlookUp(vntKey, rngTable, lngColumn, False)
        If Err.Number = 0 Then
            VlookUp = vntFindValue
            Exit Function
        End If
        On Error GoTo 0
        
        '引数を文字列に変換
        On Error Resume Next
        vntFindValue = Application.WorksheetFunction.VlookUp("" & vntKey, rngTable, lngColumn, False)
        If Err.Number = 0 Then
            VlookUp = vntFindValue
            Exit Function
        End If
        On Error GoTo 0
        
        '引数を数値に変換
        On Error Resume Next
        vntFindValue = Application.WorksheetFunction.VlookUp(vntKey * 1, rngTable, lngColumn, False)
        If Err.Number = 0 Then
            VlookUp = vntFindValue
            Exit Function
        End If
        On Error GoTo 0
                
        VlookUp = ""
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' MATCH関数をラップ・機能拡張（検索に活用）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '「Match（エクセル関数）」の拡張
    '※文字列・数値の不一致による検索失敗・エラーを回避
    Function Match(ByVal vntSearchKey As Variant, ByVal rngSearchRange As Range) As Long
        
        Dim lngResult As Long
        
        '引数そのまま検索
        On Error Resume Next
        lngResult = Application.WorksheetFunction.Match(vntSearchKey, rngSearchRange, False)
        If Err.Number = 0 Then
            Match = lngResult
            Exit Function
        End If
        On Error GoTo 0
        
        '引数を文字列変換して検索
        On Error Resume Next
        lngResult = Application.WorksheetFunction.Match("" & vntSearchKey, rngSearchRange, False)
        If Err.Number = 0 Then
            Match = lngResult
            Exit Function
        End If
        On Error GoTo 0
            
        '引数を数値変換して検索
        On Error Resume Next
        lngResult = Application.WorksheetFunction.Match(vntSearchKey * 1, rngSearchRange, False)
        If Err.Number = 0 Then
            Match = lngResult
            Exit Function
        End If
        On Error GoTo 0
            
        Match = 0
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 複数条件でインデックス検索
' ※検索対象は5列まで！
' ※インデックスを返却するので注意！！
' 　検索範囲によってインデックスと行・列は一致しません。
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '条件に一致する最初のインデックスを検索する
    Function FindIfs(ByVal rngSearchArea1 As Range, ByVal strSearchKey1 As String, _
                Optional ByVal rngSearchArea2 As Range = Nothing, Optional ByVal strSearchKey2 As String = "", _
                Optional ByVal rngSearchArea3 As Range = Nothing, Optional ByVal strSearchKey3 As String = "", _
                Optional ByVal rngSearchArea4 As Range = Nothing, Optional ByVal strSearchKey4 As String = "", _
                Optional ByVal rngSearchArea5 As Range = Nothing, Optional ByVal strSearchKey5 As String = "") As Variant

        '無駄な検索ループを省くためCountIfs関数で存在確認を実行する
        Dim lngFindCount As Long
        
        'キーと範囲を配列に格納
        Dim arySearchKeys As Variant
        Dim arySearchArea As Variant
        
        '引数の数に応じて必要項目を配列に格納
        On Error Resume Next
        If rngSearchArea2 Is Nothing Then
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1)
            arySearchKeys = Array(strSearchKey1)
            arySearchArea = Array(rngSearchArea1)
        ElseIf rngSearchArea3 Is Nothing Then
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1, rngSearchArea2, strSearchKey2)
            arySearchKeys = Array(strSearchKey1, strSearchKey2)
            arySearchArea = Array(rngSearchArea1, rngSearchArea2)
        ElseIf rngSearchArea4 Is Nothing Then
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1, rngSearchArea2, strSearchKey2, rngSearchArea3, strSearchKey3)
            arySearchKeys = Array(strSearchKey1, strSearchKey2, strSearchKey3)
            arySearchArea = Array(rngSearchArea1, rngSearchArea2, rngSearchArea3)
        ElseIf rngSearchArea5 Is Nothing Then
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1, rngSearchArea2, strSearchKey2, rngSearchArea3, strSearchKey3, rngSearchArea4, strSearchKey4)
            arySearchKeys = Array(strSearchKey1, strSearchKey2, strSearchKey3, strSearchKey4)
            arySearchArea = Array(rngSearchArea1, rngSearchArea2, rngSearchArea3, rngSearchArea4)
        Else
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1, rngSearchArea2, strSearchKey2, rngSearchArea3, strSearchKey3, rngSearchArea4, strSearchKey4, rngSearchArea5, strSearchKey5)
            arySearchKeys = Array(strSearchKey1, strSearchKey2, strSearchKey3, strSearchKey4, strSearchKey5)
            arySearchArea = Array(rngSearchArea1, rngSearchArea2, rngSearchArea3, rngSearchArea4, rngSearchArea5)
        End If
        
        '① Countifs関数で発見されなかったら実行を終了
        '② 対象セル範囲に矛盾があったらエラーのため実行終了
        If lngFindCount = 0 Or Err.Number <> 0 Then
            FindIfs = 0
            Exit Function
        End If
        On Error GoTo 0
        
        Dim intItemIndex As Integer
        Dim lngCellIndex As Long
        
        For lngCellIndex = 1 To rngSearchArea1.Cells.Count
            
            '全件一致確認
            Dim blnMatch As Boolean
            blnMatch = True
            
            'キーワード・範囲配列を順次走査
            For intItemIndex = LBound(arySearchKeys) To UBound(arySearchKeys)
                
                'キーワードと検索対象セルの不一致が発見されたらFalseを設定
                If Not arySearchKeys(intItemIndex) Like arySearchArea(intItemIndex).Cells(lngCellIndex).Value Then
                    blnMatch = False
                End If
            Next
            '全件一致したら発見されたインデックスを返却
            If blnMatch = True Then
                FindIfs = lngCellIndex
                Exit Function
            End If
        Next
        
        FindIfs = 0
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' テキストファイルでメッセージを表示する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub MessageByTextFile(ByVal strMessage As String, Optional ByVal strFileName As String = "MESSAGE_LOG.txt", Optional ByVal blnKillLogFile As Boolean = False)
        
        'ADODB.Stream定数
        Const adTypeBinary As Integer = 1
        Const adTypeText As Integer = 2
        Const adSaveCreateNotExist As Integer = 1
        Const adSaveCreateOverWrite As Integer = 2
        Const adWriteChar As Integer = 0
        Const adWriteLine As Integer = 1
        
        Dim strLogFilePath As String
        strLogFilePath = TextJoinAsPath(ThisWorkbook.Path, strFileName)
        
        'テキストファイルを生成
        Dim objAdoStream As Object
        Set objAdoStream = CreateObject("ADODB.Stream")
        With objAdoStream
            .Type = adTypeText
            .Charset = "UTF-8"
            .Open
            .WriteText strMessage, adWriteLine
            .SaveToFile strLogFilePath, adSaveCreateOverWrite
            .Close
            Set objAdoStream = Nothing
        End With
        
        'テキストファイルを最前面に表示
        Shell ("notepad.exe" & " " & strLogFilePath), vbNormalFocus
        
        'テキストファイルは削除？
        If blnKillLogFile = True Then
            Kill strLogFilePath
        End If
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列のバイト数を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetLenB(ByVal strText As String) As Integer
        
        GetLenB = LenB(StrConv(strText, vbFromUnicode))
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' シートを名称の部分一致で取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '定数
    Const intHeadMatch As Integer = 0
    Const intMidMatch As Integer = 1
    Const intEndMatch As Integer = 2
    
    Function SearchWorksheet(ByVal strWorksheetBaseName As String, ByVal intMatchType As Integer) As Worksheet
        
        '先頭一致・中間一致・末尾一致
        Dim strSearchKey As String
        If intMatchType = intHeadMatch Then
            strSearchKey = strWorksheetBaseName & "*"
        ElseIf intMatchType = intMidMatch Then
            strSearchKey = "*" & strWorksheetBaseName & "*"
        Else
            strSearchKey = "*" & strWorksheetBaseName
        End If
        
        '部分一致（Like）で検索
        Dim ws As Variant
        For Each ws In ThisWorkbook.Worksheets
            If ws.Name Like strSearchKey Then
                Set SearchWorksheet = ws
                Exit Function
            End If
        Next
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ランダム・無意味な文字列を生成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
        
    Const intAllChar As Integer = 0
    Const intAlphabetsOnly As Integer = 1
    Const intUpperAlphabetsOnly As Integer = 2
    Const intLowerAlphabetsOnly As Integer = 3
    Const intUpperOnly As Integer = 4
    Const intLowerOnly As Integer = 5
    Const intNumberOnly As Integer = 6
    
    Function MakeRandomString(ByVal intStringLength As Integer, Optional ByVal intType As Integer = 0) As String
        
        '元となる文字
        Const strUpperAlphabets As String = "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,U,R,T,U,V,W,X,Y,Z"
        Const strLowerAlphabets As String = "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z"
        Const strNumbers As String = "0,1,2,3,4,5,6,7,8,9"
        
        '文字を分割し格納する配列
        Dim aryCharacters As Variant
        
        '使用する文字種類の分岐
        Select Case intType
            Case intAlphabetsOnly
                aryCharacters = Split(strUpperAlphabets & "," & strLowerAlphabets, ",")
            Case intUpperAlphabetsOnly
                aryCharacters = Split(strUpperAlphabets, ",")
            Case intLowerAlphabetsOnly
                aryCharacters = Split(strLowerAlphabets, ",")
            Case intUpperOnly
                aryCharacters = Split(strUpperAlphabets & "," & strNumbers, ",")
            Case intLowerOnly
                aryCharacters = Split(strLowerAlphabets & "," & strNumbers, ",")
            Case intNumberOnly
                aryCharacters = Split(strNumbers, ",")
            Case Else
                aryCharacters = Split(strUpperAlphabets & "," & strLowerAlphabets & "," & strNumbers, ",")
        End Select
        
        Dim strResult As String
        Dim intCharacterCount As Integer
        Dim intRandomIndex As Integer
        
        '配列からランダムに文字を取得する
        For intCharacterCount = 1 To intStringLength
            Randomize
            intRandomIndex = Application.WorksheetFunction.RandBetween(LBound(aryCharacters), UBound(aryCharacters))
            strResult = strResult + aryCharacters(intRandomIndex)
        Next
        
        '生成されたランダム文字列を返却
        MakeRandomString = strResult
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 指定したセル範囲の完全一致を確認
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CompareRange(ByVal rngAnwer As Range, ByVal rngCorrect As Range) As Boolean
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '行数・列数の一致確認
        If rngAnwer.Rows.Count <> rngCorrect.Rows.Count Or rngAnwer.Columns.Count <> rngCorrect.Columns.Count Then
            CompareRange = False
            Exit Function
        End If
        
        '指定範囲内の同位置セルの一致を確認
        For lngRow = 1 To rngAnwer.Rows.Count
            For lngColumn = 1 To rngAnwer.Columns.Count
                If rngAnwer.Cells(lngRow, lngColumn).Value <> rngCorrect.Cells(lngRow, lngColumn).Value Then
                    CompareRange = False
                    Exit Function
                End If
            Next
        Next
        
        CompareRange = True
    
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Replaceのコーディングを簡略化
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ReplaceCellString(ByVal rngCell As Range, ByVal strPlaceHolder As String, ByVal strReplace As String) As Boolean
        
        rngCell.Value = Replace(rngCell.Value, strPlaceHolder, strReplace)
        
'        '置換が実行されたか否か返却
'        If InStr(rngCell.Value, strReplace) > 0 Then
'            ReplaceCellString = False
'        Else
'            ReplaceCellString = True
'        End If
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　空白なのに、謎の値が入っているセルの中身を削除
'　※空白なのにCtrl+方向キーで停止しないセル
'　※SQLや各種マクロのエラーの原因
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ClearGhostCell(wsGhostCellCheck)
        
        Dim rngCell As Range
        
        For Each rngCell In wsGhostCellCheck.UsedRange.Cells
            
            If rngCell.Value = "" Then
                rngCell.ClearContents
            End If
            
        Next
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Keyとなるコードに【数値】【文字列】が混在した場合の補助関数
' ※「数値 or 文字列判定」未実装。すべて数値に変換する前提で作成。
' ※「数値 or 文字列判定」を実装する場合には、WorksheetFunction.IsNumber関数を使用する！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*****************************************
    'セル範囲を一気に「文字列⇒数値」変換
    '*****************************************
    Function RangeTextToNumber(rng As Range)
        rng.TextToColumns FieldInfo:=Array(1, xlGeneralFormat)
    End Function
    
    '*****************************************
    'セル範囲を一気に「数値⇒文字列」変換
    '*****************************************
    Function RangeNumberToText(rng As Range)
        rng.TextToColumns FieldInfo:=Array(1, xlTextFormat)
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ユニークな文字列（Key）を収集(KeyとValueの区別も可能)
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CollectUnique(ByVal rngKeyCells As Range, Optional ByVal rngValueCells As Range) As Object
        
        '値範囲が未指定だった場合、Key範囲を値範囲とみなす
        If rngValueCells Is Nothing Then
            Set rngValueCells = rngKeyCells
        End If
        
        'Dictionaryを生成
        Dim dctUnique As Object
        Set dctUnique = CreateObject("Scripting.Dictionary")
        
        '行範囲・列範囲料対応
        Dim lngRow As Long
        Dim lngColumn As Long
        
        For lngRow = LBound(rngKeyCells.Value, 1) To UBound(rngKeyCells.Value, 1)
            For lngColumn = LBound(rngKeyCells.Value, 2) To UBound(rngKeyCells.Value, 2)
                
                '重複確認を行いながら、UniqueなKeyを収集
                If dctUnique.exists(rngKeyCells.Cells(lngRow, lngColumn).Value) = False And rngKeyCells.Cells(lngRow, lngColumn).Value <> "" Then
                    dctUnique.Add rngKeyCells.Cells(lngRow, lngColumn).Value, rngValueCells.Cells(lngRow, lngColumn).Value
                End If
            Next
        Next
        
        Set CollectUnique = dctUnique
        
    End Function                    
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 対象範囲内のユニークを数える
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CountUnique(ByVal rngCells As Range, Optional ByVal blnCountBlank As Boolean = False)
        
        'Dictionaryにユニークを収集
        Dim dctUnique As Object
        Set dctUnique = CreateObject("Scripting.Dictionary")
        
        Dim vntCell As Range
        Dim intBlankExists As Integer
        
        '対象範囲全セルを走査
        For Each vntCell In rngCells
            
            '空欄が、無い=0、存在=1
            If vntCell.Value = "" Then
                intBlankExists = 1
            Else
                
                '重複無く収集
                If dctUnique.Exists(vntCell.Value) = False Then
                    dctUnique.Add vntCell.Value, vntCell.Value
                End If
            End If
        Next
        
        '空欄を数えるか否かで数値変更
        If blnCountBlank = True Then
            CountUnique = dctUnique.Count + intBlankExists
        Else
            CountUnique = dctUnique.Count
        End If
        
    End Function     
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文章中に指定した文字列が出現する回数を数える
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CountString(ByVal strOrigin As String, ByVal strSearchKey As String) As Integer
        
        Dim strReplace As String
        
        strReplace = Replace(strOrigin, strSearchKey, "")
        CountString = (Len(strOrigin) - Len(strReplace)) / Len(strSearchKey)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列中の前後スペース・ダブルスペースを削除
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function DeleteSpace(ByVal strOrigin As String, ByVal intType As vbWideOrNarrow) As String
        
        'ツール内では一旦半角スペースを基準に処理
        Const strSingleSpace As String = " "
        Const strDoubleSpace As String = "  "
        Const strWideSpace As String = "　"
        
        Dim strResult As String
        strResult = Replace(Trim(strOrigin), "　", " ")
        If InStr(strResult, strDoubleSpace) <> 0 Then
            
            'ダブルスペースがなくなるまでループ
            Do While InStr(strResult, strDoubleSpace) <> 0
                strResult = Replace(strResult, strDoubleSpace, strSingleSpace)
            Loop
        End If
        
        If intType = vbWide Then
            strResult = Replace(strResult, strSingleSpace, strWideSpace)
        End If
        
        DeleteSpace = strResult
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 選択パターン数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

    Function CountChoicePattern(ByVal lngNumber As Long, Optional ByVal blnCountChoiceNone = False) As Long
        
        Dim intPickUpCount As Integer
        Dim lngChoicePatternTotal As Long
        
        For intPickUpCount = 1 To lngNumber
            lngChoicePatternTotal = lngChoicePatternTotal + Application.WorksheetFunction.Combin(lngNumber, intPickUpCount)
        Next
        
        If blnCountChoiceNone = True Then
            CountChoicePattern = lngChoicePatternTotal + 1
        Else
            CountChoicePattern = lngChoicePatternTotal
        End If
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 正規表現Replace関数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ReplaceRegExp(ByVal strOrigin As String, ByVal strRegExp As String, ByVal strReplace As String) As String
        
        Dim objRegExp As Object
        Set objRegExp = CreateObject("VBScript.RegExp")
        
        With objRegExp
            
            .Pattern = strRegExp
            .Global = True
            ReplaceRegExp = .Replace(strOrigin, strReplace)
            
        End With
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 正規表現にマッチした文字列を抽出
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function PickUpRegExp(ByVal strOrigin As String, ByVal strRegExp As String) As String
        
        Dim objRegExp As Object
        Set objRegExp = CreateObject("VBScript.RegExp")
        
        With objRegExp
            .Pattern = strRegExp
            .Global = False
            
            On Error Resume Next
            PickUpRegExp = .Execute(strOrigin)(0).Value
            On Error GoTo 0
            
        End With
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 正規表現にマッチするパターンが文字列の中に含まれるか？
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function IncludeRegExp(ByVal strOrigin As String, ByVal strRegExp As String) As Boolean
        
        Dim objRegExp As Object
        Set objRegExp = CreateObject("VBScript.RegExp")
        
        With objRegExp
            
            .Pattern = strRegExp
            .Global = True
            
            If .Execute(strOrigin).Count > 0 Then
                IncludeRegExp = True
            Else
                IncludeRegExp = False
            End If
        End With
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Colorプロパティの「数値」からRGB分解・計算
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetRGB(ByVal lngColor As Long) As Variant
        
        Dim intR As Integer
        Dim intG As Integer
        Dim intB As Integer
        intR = lngColor Mod 256
        intG = ((lngColor Mod 256 ^ 2) - intB) / 256
        intB = Int(lngColor / (256 ^ 2))
        
        GetRGB = Array(intR, intG, intB)
        
    End Function                    
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 年度を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetYearPeriod(ByVal dteTarget As Date) As String
        If Month(dteTarget) < 4 Then
            GetYearPeriod = Format(Year(dteTarget) - 1, "0000年度")
        Else
            GetYearPeriod = Format(Year(dteTarget), "0000年度")
        End If
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 月次で変更されるシート名を生成
' ※「年度（「P」eriod）」「年（「Y」ear）」「月（「M」onth）」
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ReplaceDateName(ByVal strOrigin As String, ByVal dteTargetMonth As Date) As String
        
        '置換に使用するPlaceHolder
        Const strStar As String = "★"
        Dim aryPlaceHolders As Variant
        aryPlaceHolders = Array("YY", "YYYY", "M", "MM", _
                                "YYM", "YYMM", "YYYYM", "YYYYMM", _
                                "YYMD", "YYMMDD", "YYYYMd", "YYYYMMDD")
        Dim strResult As String
        strResult = strOrigin
        
        '一般的な表記パターンを総当たりで置換
        Dim vntPlaceHolder As Variant
        For Each vntPlaceHolder In aryPlaceHolders
            
            'PlaceHolder大文字
            strResult = Replace(strResult, _
                                strStar & vntPlaceHolder & strStar, _
                                Format(dteTargetMonth, vntPlaceHolder))
                                
            'PlaceHolder小文字
            strResult = Replace(strResult, _
                                strStar & StrConv(vntPlaceHolder, vbLowerCase) & strStar, _
                                Format(dteTargetMonth, vntPlaceHolder))
        Next
        
        '「年度」による置換
        '※4月を境に切り替え
        Dim intPeriod As Integer
        If Month(dteTargetMonth) < 4 Then
            intPeriod = Year(dteTargetMonth) - 1
        Else
            intPeriod = Year(dteTargetMonth)
        End If
        
        'PlaceHolder,書式設定を変更
        aryPlaceHolders = Array(Array("PP", "00"), Array("PPPP", "0000"))
        For Each vntPlaceHolder In aryPlaceHolders
            
            '大文字
            strResult = Replace(strResult, _
                                strStar & vntPlaceHolder(0) & strStar, _
                                Format(intPeriod, vntPlaceHolder(1)))
            
            '小文字
            strResult = Replace(strResult, _
                                strStar & StrConv(vntPlaceHolder(0), vbLowerCase) & strStar, _
                                Format(intPeriod, vntPlaceHolder(1)))
        Next
                        
        ReplaceDateName = strResult
    End Function                        
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列をファイルパスとして結合
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function TextJoinAsPath(ParamArray aryString() As Variant) As String
        
        Dim vntString As Variant
        Dim strPath As String
        
        For Each vntString In aryString
            If strPath = "" Then
                strPath = vntString
            ElseIf Right(strPath, 1) = "\" Then
                strPath = strPath & vntString
            Else
                strPath = strPath & "\" & vntString
            End If
        Next
        
        TextJoinAsPath = strPath
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 階層をさかのぼって親フォルダを取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetParentFolderPath(Optional ByVal intBackCount = 0) As String
        
        Dim strFolderPath As String
        strFolderPath = ThisWorkbook.Path
        
        Dim intBackIndex As Integer
        
        '親階層をさかのぼる回数は「絶対値」を使用
        'さかのぼる回数が0ならば自身の保存フォルダを返却
        For intBackIndex = 1 To Abs(intBackCount)
            
            '「\」が無くなったら空文字を返却
            If InStr(strFolderPath, "\") = 0 Then
                GetParentFolderPath = ""
                Exit Function
            End If
            strFolderPath = Left(strFolderPath, InStrRev(strFolderPath, "\") - 1)
        Next
        
        GetParentFolderPath = strFolderPath
        
    End Function                            
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 入力されたフォルダパスの「存在する最深フォルダ」を特定する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function DigFolder(ByVal strFolderPath As String) As String
        
        Const strServerHead As String = "\\"
        Const strPathDelimiter As String = "\"
        Dim strPathHead As String
        Dim aryPath As Variant
        
        'サーバーパスの場合「\\fsv\fldA」
        If Left(strFolderPath, Len(strServerHead)) = strServerHead Then
            
            '\\fsv & { fldA, fldB, fldC, fldD }
            strPathHead = "\\" & Split(Right(strFolderPath, Len(strFolderPath) - Len(strServerHead)), strPathDelimiter)(0)
            aryPath = Split(Right(strFolderPath, Len(strFolderPath) - Len(strPathHead) - 1), strPathDelimiter)
        
        'ドライブの場合「c:\fldA」
       Else
            
            'c: & { fldA, fldB, fldC, fldD }
            strPathHead = Split(strFolderPath, strPathDelimiter)(0)
            aryPath = Split(Right(strFolderPath, Len(strFolderPath) - Len(strPathHead) - 1), strPathDelimiter)
        End If
        
        
        Dim vntPath As Variant
        Dim strJoinPath As String
        Dim strExistsPath As String
        
        '「\\fsv」「c:」より走査
        strExistsPath = strPathHead
        
        '「\」で分割した文字列を連結してゆく
        For Each vntPath In aryPath
            
            '存在している最短Path + 次の階層のフォルダ名で調査
            strJoinPath = strExistsPath & strPathDelimiter & vntPath
            If CreateObject("Scripting.FileSystemObject").FolderExists(strJoinPath) = True Then
                
                '調査したフォルダが存在したら「存在確認済みPathを連結」
                strExistsPath = strJoinPath
            Else
                
                '調査したフォルダが存在しなかったら前回のPathを返却
                DigFolder = strExistsPath
                Exit Function
            End If
        Next
        
        '全階層のフォルダが存在したらFullPahを返却
        DigFolder = strExistsPath
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 指定フォルダのファイル数をカウント
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CountFileInFolder(ByVal strSearchKey) As Long
        
        Dim lngCount As Long
        Dim strFindFile As String
        
        strFindFile = Dir(strSearchKey)
        
        Do While strFindFile <> ""
            lngCount = lngCount + 1
            strFindFile = Dir()
        Loop
        
        CountFileInFolder = lngCount
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' オートフィルタの解除（可変長引数）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ClearAutoFilter(ParamArray aryWorksheets() As Variant)
        
        Dim vntWorksheet As Variant
        For Each vntWorksheet In aryWorksheets
            If vntWorksheet.AutoFilterMode = True Then vntWorksheet.AutoFilterMode = False
        Next
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　OutlookMail操作
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '構造体でデータをまとめる
    Type MailSettings
        From As String
        To As String
        Cc As String
        Bcc As String
        Subject As String
        Body As String
        HtmlBody As String
        EntryId as String
    End Type
    
    '構造体でデータを受け取り、メール作成・保存を行う
    ’※送信時に使用するためにメールのIDを返却
    Sub MakeAndSaveMail(typMailSettings As MailSettings)
        
        Const olMailItem As Integer = 0
        Const olFormatHTML As Integer = 2
        
        'Outlookオブジェクト生成
        Dim objOutlook As Object
        Dim objMailItem As Object
        Set objOutlook = CreateObject("Outlook.Application")
        Set objMailItem = objOutlook.CreateItem(olMailItem)   '【定数】olMailItem = 0
        
        With typMailSettings
            
            'メール各設定
            objMailItem.To = .To
            objMailItem.Cc = .Cc
            objMailItem.Bcc = .Bcc
            objMailItem.Subject = .Subject
            
            '本文
            objMailItem.BodyFormat = olFormatHTML
            objMailItem.HtmlBody = .HtmlBody
'            objMailItem.Body = .Body
            
            '下書きを保存するアカウントを指定
            Dim objAccounts As Object
            Set objAccounts = objOutlook.Session.Accounts.Item(.From)
            Set objMailItem.SendUsingAccount = objAccounts            
            
            'メール保存
            objMailItem.Save
            
            ’メールのIDを構造体に格納して返却
            .EntryId = objMailItem.EntryId
            
        End With
        
        'オブジェクト解放
        Set objOutlook = Nothing
        Set objMailItem = Nothing
        
    End Sub
    
    '指定したアカウントの下書きフォルダの指定メールを送信
    Function SendMailByAccountAndMailId(ByVal strOutlookAccount As String, ByVal strMailId As String) As Boolean
        
        'Outlookオブジェクト生成
        Dim objOutlook As Object
        Dim objAccounts As Object
        Dim objNameSpace As Object
        Dim objItem As Object
        
        Set objOutlook = CreateObject("Outlook.Application")
        Set objAccounts = objOutlook.Session.Accounts
        
        '指定アカウント・指定メールにアクセスできなかったら終了
        On Error Resume Next
        Set objNameSpace = objAccounts(strOutlookAccount).Application.GetNamespace("MAPI")
        Set objItem = objNameSpace.GetItemFromID(strMailId)
        
        If Err.Number <> 0 Then
            SendMailByAccountAndMailId = False
            Exit Function
        End If
        
        'マクロでメール送信すると謎のエラーが発生することが多いため
        '表示してから送信することでエラーを回避
        objItem.Display
        'objItem.Send
        
        'オブジェクト解放
        Set objOutlook = Nothing
        Set objAccounts = Nothing
        Set objNameSpace = Nothing
        Set objItem = Nothing
        
        SendMailByAccountAndMailId = True
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Outlook操作各種
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'Outlook画面が開いているか？確認
    Function IsOpenOutlookWindow(ByVal blnShowMessage as String)
        
        If CreateObject("Outlook.Application").Explorers.Count > 0 then
            IsOpenOutlookWindow = True
        Else
            If blnShowMessage = True Then
                MsgBox "Outlookアプリが起動されていません。" & vbCrLf & _
                    "Outlookアプリを手動で起動・ログインしてからマクロを実行してください。" & vbCrLf & _
                    "実行を中止します。", vbExclamation
            End If
            IsOpenOutlookWindow = False
        End If
        
    End Function
    
    'Outlookの指定アカウントにログインしているか確認
    Function IsLoginOutlook(ByVal strOutlookAccount As String, ByVal blnShowMessage As Boolean) As Boolean
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        
        '指定アカウントを操作できない⇒ログインしていないと判断
        '※DisplayNameを取得する事に特別な意味はありません。
        On Error Resume Next
        Dim strDisplayName As String
        strDisplayName = objOutlookAccount(strOutlookAccount).DisplayName
        If Err.Number <> 0 Then
            IsLoginOutlook = False
            If blnShowMessage = True Then
                MsgBox "指定アカウント「" & strOutlookAccount & "」にログインしていません。" & vbCrLf & _
                        "指定アカウントにログインしてから再度実行してください。" & vbCrLf & _
                        "実行を中止します。", vbExclamation
            End If
        Else
            IsLoginOutlook = True
        End If
        On Error GoTo 0
    End Function
    
    'メインアカウントの確認
    Function GetOutlookDefaultAccount() As String
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        GetOutlookDefaultAccount = objOutlookAccount(1).DisplayName
        
    End Function
    
    '下書きフォルダの現在の保存件数
    Function CheckOutlookFolderItemsCount(ByVal strOutlookAccount As String)
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        CheckOutlookFolderItemsCount = objOutlookAccount(ByVal strOutlookAccount as String).DeliveryStore.GetDefaultFolder(16).items.Count
        
    End Function
    
    '下書きフォルダの本文のHTMLを取得
    Function GetHTML(ByVal strOutlookAccount As String)
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        GetHTML = objOutlookAccount(ByVal strOutlookAccount as String).DeliveryStore.GetDefaultFolder(16).items(1).htmlbody
        
    End Function
    
    '下書きフォルダの本文のHTMLを変更
    Function SetHtml(ByVal strOutlookAccount As String)
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Dim objMailItem As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        Set objMailItem = objOutlookAccount(byval strOutlookAccount as String).DeliveryStore.GetDefaultFolder(16).items(2)
        objMailItem.htmlbody = "<font face=""メイリオ"" style=""background-color: lightskyblue; color: white; border: 1px solid black; margin: 10px;"">楽しい</font>だろうか？"
        objMailItem.Save
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' PDF加工関数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    '************************************************
    ' PDF用パスワード設定関数
    ' ※PowerShellコマンドを生成して実行
    ' ※itextsharp.dllを使用
    '************************************************
    Function SetPasswordPDF(ByVal strInFilePath As String, ByVal strOutFilePath As String, ByVal strPassword As String, ByVal strDllPath As String) As Boolean
                        
        Dim strCommand As String
        
        strCommand = "" & _
            "$inpath = '" & strInFilePath & "';" & vbCrLf & _
            "$outpath = '" & strOutFilePath & "';" & vbCrLf & _
            "$password = '" & strPassword & "';" & vbCrLf & _
            "$dllpath = '" & strDllPath & "';" & vbCrLf & _
            "Add-Type -Path ($dllpath);" & vbCrLf & _
            "$reader = New-Object iTextSharp.text.pdf.PdfReader($inpath);" & vbCrLf & _
            "$fs = New-Object System.IO.FileStream($outpath,[System.IO.FileMode]::OpenOrCreate);" & vbCrLf & _
            "[iTextSharp.text.pdf.PdfEncryptor]::Encrypt($reader, $fs, $true, $password, $password, [iTextSharp.text.pdf.PdfWriter]::ALLOW_PRINTING);" & vbCrLf & _
            "$fs.Close();" & vbCrLf & _
            "$reader.Close();"
        
        Dim objWSH As Object
        Set objWSH = CreateObject("WScript.Shell")
        objWSH.Run "powershell -Command " & strCommand, 0, True
        
        SetPasswordPDF = CreateObject("Scripting.FileSystemObject").FileExists(strOutFilePath)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' シートやCSVファイルに対してSQLを実行するサンプル
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ※エクセル内でSQLを実行するためにはIDを文字列にする必要がありそう（？）
' ※CSVファイルを直接結合する方法は不安なので
'  「①ブック内に読み込み ⇒ ②キーを文字列に変換 ⇒ ③SQLを実行」
' 　が安全そうではある。
' ※エクセル内SQLは「文字列・数値」が混在した場合「列の型を勝手に定義して、不正なデータを消す」
' 　という仕様があるので、データが消滅していないか？の確認は必須！
' ※エクセルは「"" or Null」の判別が困難なので、下記方法で判断を行うこと！
' 　× ⇒ IsNull(カラム名)
' 　〇 ⇒ カラム名 & '' = ''
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ファイル自身の各シートに対してSQLを実行する関数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '************************************************
    ' 本エクセルブック内のシートに対してSQL実行
    '************************************************
    Function AddDataBySql(ByVal wsDataTable As Worksheet, ByVal strSql As String, Optional ByVal blnRefresh As Boolean = False, Optional ByVal blnOverWrite As Boolean)
                
        Dim adoConnection As Object
        Dim adoRecordset As Object
        Set adoConnection = AdoConnectThisBook
        Set adoRecordset = CreateObject("ADODB.Recordset")
        
        Const adOpenKeyset = 1
        Const adLockReadOnly = 1
        
        adoRecordset.Open strSql, adoConnection, adOpenKeyset, adLockReadOnly
        
        With wsDataTable
            
            '貼り付け先シート初期化？
            If blnRefresh = True Then
                .Rows.Delete
            End If
            
            Dim lngWriteRow As Long
            
            '上書きの際は2行目から転記
            If blnOverWrite = True Then
                lngWriteRow = 2
            Else
                lngWriteRow = GetLastRow(wsDataTable, "A") + 1
            End If
            
            'SQLレコードセットを貼り付け
            .Cells(lngWriteRow, 1).CopyFromRecordset adoRecordset
            
            'ヘッダは毎回再設定
            .Rows(1).Clear
            Dim intIndex As Integer
            For intIndex = 0 To adoRecordset.Fields.Count - 1
                .Cells(1, intIndex + 1).Value = adoRecordset.Fields(intIndex).Name
            Next
        End With
        
        'オブジェクト破棄
        adoRecordset.Close
        Set adoRecordset = Nothing
        adoConnection.Close
        Set adoConnection = Nothing
        
    End Function
    
    '************************************************
    ' 本エクセルブックにDB接続
    '************************************************
    Function AdoConnectThisBook() As Object
        
        Dim adoConnection As Object
        
        Set adoConnection = CreateObject("ADODB.Connection")
        adoConnection.Provider = "Microsoft.ACE.OLEDB.12.0"
        adoConnection.Properties("Extended Properties") = "Excel 12.0;HDR=YES;IMEX=1"
        adoConnection.Open ThisWorkbook.FullName
        
        Set AdoConnectThisBook = adoConnection
        
    End Function
    
    '************************************************
    ' CSVファイルが保存されているフォルダにDB接続
    '************************************************
    Function AdoConnectCsvFolder(ByVal strCsvFolder As String) As Object
        
        Dim adoConnection As Object
        
        Set adoConnection = CreateObject("ADODB.Connection")
        adoConnection.Provider = "Microsoft.ACE.OLEDB.12.0"
        adoConnection.Properties("Extended Properties") = "text;HDR=YES;FMT=Delimited"
        adoConnection.Open strCsvFolder
        
        Set AdoConnectCsvFolder = adoConnection
                
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　WebAPIを使用したスクレイピング・クローリング備忘録
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub WebApiSample()
        
        'シンプルなWebApiリクエスト
        Dim objHttpRequest As Object
        Set objHttpRequest = CreateObject("MSXML2.XMLHTTP")
        
        With objHttpRequest
            .Open "GET", "https://sample.sample.jp", False
            .Send
            
            Do While .readyState < 4
                Application.Wait Now + TimeValue("00:00:01")
                DoEvents
            Loop
            
        End With
        
        '取得したHTMLファイルを直接操作
        '※ブラウザ不要
        Dim objHtmlDoc As Object
        Set objHtmlDoc = CreateObject("htmlfile")
        objHtmlDoc.write objHttpRequest.responseText
        
        '原因不明のエラーが起こるので実行速度調整
        Application.Wait Now + TimeValue("00:00:01")
        DoEvents
        
        'HTMLから必要なデータを抽出
        If InStr(objHtmlDoc.Title, "404エラー") = 0 Then
            Debug.Print objHtmlDoc.Title
            Debug.Print objHtmlDoc.querySelector(".titleLink a").innerText
        End If
        
        '連続データ収集を実行する際は必ずメモリを開放する
        '※メモリを大量に消費します！！
        Set objHttpRequest = Nothing
        Set objHtmlDoc = Nothing
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 国土地理院API使用方法備忘録
' 住所文字列から「経度X」「緯度Y」情報を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetPointApi(ByVal strAddress As String) As Variant
            
        Dim strAddressEncode As String
       
        '住所文字列をURLエンコーディング
        strAddressEncode = Application.WorksheetFunction.EncodeURL(strAddress)
        
        Dim objHttpRequest As Object
        Set objHttpRequest = CreateObject("MSXML2.XMLHTTP")
        
        '国土地理院のAPIを使用
        With objHttpRequest
            .Open "GET", "https://msearch.gsi.go.jp/address-search/AddressSearch?q=" & strAddressEncode, False
            .Send
            
            Do While .readyState < 4
                DoEvents
            Loop
            
            'Json形式でレスポンスが返されます
            Dim objJson As Object
            Set objJson = ParseJson(.responseText)
        End With
        
        '「経度X」「緯度Y」の配列を返却
        GetPointApi = Array(objJson(1)("geometry")("coordinates")(2), objJson(1)("geometry")("coordinates")(1))
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 10進数を2進数に変換
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ChangeDecimalToBinary(ByVal lngOriginNumber As Long, Optional ByVal intBaseNumber As Integer = 2) As Long
    
        Dim strDecimal As String
        Dim lngDividedNumber As Long
        Dim lngMod As Long
        lngMod = -1
        
        lngDividedNumber = lngOriginNumber
        lngMod = 0
        
        Do While lngDividedNumber <> 0
            
            lngMod = lngDividedNumber Mod intBaseNumber
            lngDividedNumber = Int(lngDividedNumber / intBaseNumber)
            strDecimal = lngMod & strDecimal
            
        Loop
        
        ChangeDecimalToBinary = Int(strDecimal)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
' ****************************************************************
' TinySegmenter 0.1 Excel VBA Version
'  by arihagne
'
' Original JavaScript Version CopyRight Notice
'// TinySegmenter 0.1 -- Super compact Japanese tokenizer in Javascript
'// (c) 2008 Taku Kudo <taku@chasen.org>
'// TinySegmenter is freely distributable under the terms of a new BSD licence.
'// For details, see http://chasen.org/~taku/software/TinySegmenter/LICENCE.txt
' ****************************************************************

'*****************************************************************
' 下記より入手し、機能追記・不具合修正・機能解読中
' http://www16.plala.or.jp/arihagne/software/TinySegmenter.txt
'*****************************************************************

'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　Dictionary
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Private UC1__ As Object, UC2__ As Object, UC3__ As Object, UC4__ As Object, UC5__ As Object, UC6__ As Object
    Private UP1__ As Object, UP2__ As Object, UP3__ As Object
    Private UQ1__ As Object, UQ2__ As Object, UQ3__  As Object
    Private UW1__ As Object, UW2__ As Object, UW3__ As Object, UW4__ As Object, UW5__ As Object, UW6__  As Object
    
    Private BC1__ As Object, BC2__ As Object, BC3__ As Object
    Private BP1__ As Object, BP2__ As Object
    Private BQ1__ As Object, BQ2__ As Object, BQ3__ As Object, BQ4__ As Object
    Private BW1__ As Object, BW2__ As Object, BW3__ As Object
    
    Private TC1__ As Object, TC2__ As Object, TC3__ As Object, TC4__ As Object
    Private TQ1__ As Object, TQ2__ As Object, TQ3__ As Object, TQ4__ As Object
    Private TW1__ As Object, TW2__ As Object, TW3__ As Object, TW4__ As Object
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　名プロシージャ内でデータを複数回取得できるように
'　結果をクラス内広域変数に格納
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Dim aryResultWords As Variant
    Dim dctResultWords As Object
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　分かち書き機能
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*****************************************************************
    ' 分かち書き実行関数
    '*****************************************************************
    
    Function Segment(ByVal strOriginText As String, Optional ByVal arySkipCharacters As Variant = False, Optional ByVal blnSkipSingleKana As Boolean = False, _
                        Optional ByVal blnSkipAlphabet As Boolean = False, Optional ByVal blnSkipNumeric As Boolean = False) As Variant
        
        '改行文字等、無意味な文字を除外
        strOriginText = Replace(strOriginText, vbLf, "")
        strOriginText = Replace(strOriginText, vbCr, "")
        strOriginText = Replace(strOriginText, vbCrLf, "")
        strOriginText = Replace(strOriginText, vbTab, "")
        
        '「除外文字」を半角スペースに変換
        '※別の文字と連結して意味をなさないように半角スペースを挿入
        If IsArray(arySkipCharacters) Then
            Dim vntSkipWord As Variant
            For Each vntSkipWord In arySkipCharacters
                strOriginText = Replace(strOriginText, vntSkipWord, " ")
            Next
        End If
        
        '無駄を除外した結果、空文字だったら終了
        If Trim(strOriginText) = "" Then
            Segment = Array()
            Exit Function
        End If
        
        Dim lngScore As Long
        Dim strWord As String
        
        Dim p, p1, p2, p3
        Dim w1, w2, w3, w4, w5, w6
        Dim c1, c2, c3, c4, c5, c6
        
        Dim segArray()
        segArray = Array()
        Call ArrayPush(segArray, "B3")
        Call ArrayPush(segArray, "B2")
        Call ArrayPush(segArray, "B1")
        
        Dim ctypeArray()
        ctypeArray = Array()
        Call ArrayPush(ctypeArray, "O")
        Call ArrayPush(ctypeArray, "O")
        Call ArrayPush(ctypeArray, "O")
        
        '文章を「文字単位区切り」で配列に格納
        Dim aryOriginCharacter As Variant
        aryOriginCharacter = SplitByCharacter(strOriginText)
        
        Dim lngCharIndex As Long
        For lngCharIndex = LBound(aryOriginCharacter) To UBound(aryOriginCharacter)
            Call ArrayPush(segArray, aryOriginCharacter(lngCharIndex))
            Call ArrayPush(ctypeArray, ctype_(aryOriginCharacter(lngCharIndex)))
        Next lngCharIndex
            
        Call ArrayPush(segArray, "E1")
        Call ArrayPush(segArray, "E2")
        Call ArrayPush(segArray, "E3")
        
        Call ArrayPush(ctypeArray, "O")
        Call ArrayPush(ctypeArray, "O")
        Call ArrayPush(ctypeArray, "O")
        
        strWord = segArray(3)
        
        p1 = "U"
        p2 = "U"
        p3 = "U"
        
        '単語区切り配列を初期化
        aryResultWords = Array()
        Set dctResultWords = CreateObject("Scripting.Dictionary")
        
        Dim i As Long
        For i = 4 To UBound(segArray) - 3
            
            lngScore = BIAS__
            w1 = segArray(i - 3)
            w2 = segArray(i - 2)
            w3 = segArray(i - 1)
            w4 = segArray(i)
            w5 = segArray(i + 1)
            w6 = segArray(i + 2)
            c1 = ctypeArray(i - 3)
            c2 = ctypeArray(i - 2)
            c3 = ctypeArray(i - 1)
            c4 = ctypeArray(i)
            c5 = ctypeArray(i + 1)
            c6 = ctypeArray(i + 2)
            
            lngScore = lngScore + ts_(UP1__.Item(p1))
            lngScore = lngScore + ts_(UP2__.Item(p2))
            lngScore = lngScore + ts_(UP3__.Item(p3))
            lngScore = lngScore + ts_(BP1__.Item(p1 & p2))
            lngScore = lngScore + ts_(BP2__.Item(p2 & p3))
            lngScore = lngScore + ts_(UW1__.Item(w1))
            lngScore = lngScore + ts_(UW2__.Item(w2))
            lngScore = lngScore + ts_(UW3__.Item(w3))
            lngScore = lngScore + ts_(UW4__.Item(w4))
            lngScore = lngScore + ts_(UW5__.Item(w5))
            lngScore = lngScore + ts_(UW6__.Item(w6))
            lngScore = lngScore + ts_(BW1__.Item(w2 & w3))
            lngScore = lngScore + ts_(BW2__.Item(w3 & w4))
            lngScore = lngScore + ts_(BW3__.Item(w4 & w5))
            lngScore = lngScore + ts_(TW1__.Item(w1 & w2 & w3))
            lngScore = lngScore + ts_(TW2__.Item(w2 & w3 & w4))
            lngScore = lngScore + ts_(TW3__.Item(w3 & w4 & w5))
            lngScore = lngScore + ts_(TW4__.Item(w4 & w5 & w6))
            lngScore = lngScore + ts_(UC1__.Item(c1))
            lngScore = lngScore + ts_(UC2__.Item(c2))
            lngScore = lngScore + ts_(UC3__.Item(c3))
            lngScore = lngScore + ts_(UC4__.Item(c4))
            lngScore = lngScore + ts_(UC5__.Item(c5))
            lngScore = lngScore + ts_(UC6__.Item(c6))
            lngScore = lngScore + ts_(BC1__.Item(c2 & c3))
            lngScore = lngScore + ts_(BC2__.Item(c3 & c4))
            lngScore = lngScore + ts_(BC3__.Item(c4 & c5))
            lngScore = lngScore + ts_(TC1__.Item(c1 & c2 & c3))
            lngScore = lngScore + ts_(TC2__.Item(c2 & c3 & c4))
            lngScore = lngScore + ts_(TC3__.Item(c3 & c4 & c5))
            lngScore = lngScore + ts_(TC4__.Item(c4 & c5 & c6))
            'lngScore = lngScore + ts_(TC5__.Item( c4 & c5 & c6)
            lngScore = lngScore + ts_(UQ1__.Item(p1 & c1))
            lngScore = lngScore + ts_(UQ2__.Item(p2 & c2))
            lngScore = lngScore + ts_(UQ1__.Item(p3 & c3))
            lngScore = lngScore + ts_(BQ1__.Item(p2 & c2 & c3))
            lngScore = lngScore + ts_(BQ2__.Item(p2 & c3 & c4))
            lngScore = lngScore + ts_(BQ3__.Item(p3 & c2 & c3))
            lngScore = lngScore + ts_(BQ4__.Item(p3 & c3 & c4))
            lngScore = lngScore + ts_(TQ1__.Item(p2 & c1 & c2 & c3))
            lngScore = lngScore + ts_(TQ2__.Item(p2 & c2 & c3 & c4))
            lngScore = lngScore + ts_(TQ3__.Item(p3 & c1 & c2 & c3))
            lngScore = lngScore + ts_(TQ4__.Item(p3 & c2 & c3 & c4))
            
            p = "O"
            
            If lngScore > 0 Then
                
                strWord = Trim(strWord)
                
                '「かな1文字」を除外する場合
                If blnSkipSingleKana = True Then
                    If strWord Like "[あ-ん]" Then
                        strWord = ""
                    ElseIf strWord Like "[ア-ン]" Then
                        strWord = ""
                    End If
                End If
                
                '「アルファベットのみ」を除外する場合
                If blnSkipAlphabet = True Then
                    If Not strWord Like "*[!a-zA-Zａ-ｚＡ-Ｚ]*" Then
                        strWord = ""
                    End If
                End If
                
                '「数字のみ」を除外する場合
                If blnSkipNumeric = True Then
                    If Not strWord Like "*[!0-9０-９]*" Then
                        strWord = ""
                    End If
                End If
                                
                '「空文字」でなければ追加
                If strWord <> "" Then
                    
                    '新規発見単語だったら登録
                    If dctResultWords.Exists(strWord) = False Then
                        dctResultWords.Add strWord, 1
                    
                    '登録済み単語だったらカウントアップ
                    Else
                        dctResultWords(strWord) = dctResultWords(strWord) + 1
                    End If
                    
                    Call ArrayPush(aryResultWords, strWord)
                                        
                End If
                
                strWord = ""
                p = "B"
                
            End If
            
            p1 = p2
            p2 = p3
            p3 = p
            strWord = strWord & segArray(i)
            
        Next i
        
        Call ArrayPush(aryResultWords, strWord)
        
        '「単語＋単語出現数」を格納したDictionaryを返却
        Set Segment = dctResultWords
        
    End Function
    
    
    '*****************************************************************
    ' バイアス初期値の設定
    '*****************************************************************
    
    Function BIAS__() As Long
        
        BIAS__ = -332
        
    End Function
    
    
    '*****************************************************************
    ' 値が存在しない場合に「0」を返却するための安全関数？
    '*****************************************************************
    
    Private Function ts_(ByVal v As Long) As Long
        
        If IsEmpty(v) Then
            ts_ = 0
        Else
            ts_ = v
        End If
    
    End Function
    
    '*****************************************************************
    ' 文字の種類を判別
    '*****************************************************************
    
    Private Function ctype_(ByVal strWord As String) As String
        
        Dim strCharType As String
        strCharType = "O"
        
        Dim aryCharTypes As Variant
        aryCharTypes = Array( _
                        "[一二三四五六七八九十百千万億兆]:M", _
                        "[一-龠々〆ヵヶ]:H", _
                        "[ぁ-ん]:I", _
                        "[ァ-ヴーｱ-ﾝﾞｰ]:K", _
                        "[a-zA-Zａ-ｚＡ-Ｚ]:A", _
                        "[0-9０-９]:N")
        
        Dim intCharTypeIndex As Long
        For intCharTypeIndex = LBound(aryCharTypes) To UBound(aryCharTypes)
                
            If strWord Like Split(aryCharTypes(intCharTypeIndex), ":")(0) Then
                strCharType = Split(aryCharTypes(intCharTypeIndex), ":")(1)
                Exit For
            End If
        Next intCharTypeIndex
        
        ctype_ = strCharType
    
    End Function
    
    
    '*****************************************************************
    ' 配列末尾に文字列を追加
    '*****************************************************************
    
    Private Sub ArrayPush(ByRef vntArray As Variant, ByVal strWord As String)
        
        Dim lngResizeIndex As Long
        lngResizeIndex = UBound(vntArray) + 1
        ReDim Preserve vntArray(lngResizeIndex)
        vntArray(lngResizeIndex) = strWord
    
    End Sub
    
    
    '*****************************************************************
    ' 文章を「文字」単位に切り分け
    '*****************************************************************
    
    Private Function SplitByCharacter(ByVal strOriginText As String)
        
        Dim lngOriginTextLen As Long
        
        lngOriginTextLen = Len(strOriginText)
        ReDim tmpArray(lngOriginTextLen - 1)
        
        Dim lngCharacterIndex As Long
        For lngCharacterIndex = 1 To lngOriginTextLen
            tmpArray(lngCharacterIndex - 1) = Mid(strOriginText, lngCharacterIndex, 1)
        Next
        
        SplitByCharacter = tmpArray
    
    End Function
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　コンストラクタがDictionaryを初期化
'　※コードが膨大なため最下段に。本プロシージャ以下にコードはありません。
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Private Sub Class_Initialize()
        
        Set BC1__ = CreateObject("Scripting.Dictionary")
        BC1__.Add "HH", 6
        BC1__.Add "II", 2461
        BC1__.Add "KH", 406
        BC1__.Add "OH", -1378
        
        Set BC2__ = CreateObject("Scripting.Dictionary")
        BC2__.Add "AA", -3267
        BC2__.Add "AI", 2744
        BC2__.Add "AN", -878
        BC2__.Add "HH", -4070
        BC2__.Add "HM", -1711
        BC2__.Add "HN", 4012
        BC2__.Add "HO", 3761
        BC2__.Add "IA", 1327
        BC2__.Add "IH", -1184
        BC2__.Add "II", -1332
        BC2__.Add "IK", 1721
        BC2__.Add "IO", 5492
        BC2__.Add "KI", 3831
        BC2__.Add "KK", -8741
        BC2__.Add "MH", -3132
        BC2__.Add "MK", 3334
        BC2__.Add "OO", -2920
        
        Set BC3__ = CreateObject("Scripting.Dictionary")
        BC3__.Add "HH", 996
        BC3__.Add "HI", 626
        BC3__.Add "HK", -721
        BC3__.Add "HN", -1307
        BC3__.Add "HO", -836
        BC3__.Add "IH", -301
        BC3__.Add "KK", 2762
        BC3__.Add "MK", 1079
        BC3__.Add "MM", 4034
        BC3__.Add "OA", -1652
        BC3__.Add "OH", 266
        
        Set BP1__ = CreateObject("Scripting.Dictionary")
        BP1__.Add "BB", 295
        BP1__.Add "OB", 304
        BP1__.Add "OO", -125
        BP1__.Add "UB", 352
        
        Set BP2__ = CreateObject("Scripting.Dictionary")
        BP2__.Add "BO", 60
        BP2__.Add "OO", -1762
        
        Set BQ1__ = CreateObject("Scripting.Dictionary")
        BQ1__.Add "BHH", 1150
        BQ1__.Add "BHM", 1521
        BQ1__.Add "BII", -1158
        BQ1__.Add "BIM", 886
        BQ1__.Add "BMH", 1208
        BQ1__.Add "BNH", 449
        BQ1__.Add "BOH", -91
        BQ1__.Add "BOO", -2597
        BQ1__.Add "OHI", 451
        BQ1__.Add "OIH", -296
        BQ1__.Add "OKA", 1851
        BQ1__.Add "OKH", -1020
        BQ1__.Add "OKK", 904
        BQ1__.Add "OOO", 2965
        
        Set BQ2__ = CreateObject("Scripting.Dictionary")
        BQ2__.Add "BHH", 118
        BQ2__.Add "BHI", -1159
        BQ2__.Add "BHM", 466
        BQ2__.Add "BIH", -919
        BQ2__.Add "BKK", -1720
        BQ2__.Add "BKO", 864
        BQ2__.Add "OHH", -1139
        BQ2__.Add "OHM", -181
        BQ2__.Add "OIH", 153
        BQ2__.Add "UHI", -1146
        
        Set BQ3__ = CreateObject("Scripting.Dictionary")
        BQ3__.Add "BHH", -792
        BQ3__.Add "BHI", 2664
        BQ3__.Add "BII", -299
        BQ3__.Add "BKI", 419
        BQ3__.Add "BMH", 937
        BQ3__.Add "BMM", 8335
        BQ3__.Add "BNN", 998
        BQ3__.Add "BOH", 775
        BQ3__.Add "OHH", 2174
        BQ3__.Add "OHM", 439
        BQ3__.Add "OII", 280
        BQ3__.Add "OKH", 1798
        BQ3__.Add "OKI", -793
        BQ3__.Add "OKO", -2242
        BQ3__.Add "OMH", -2402
        BQ3__.Add "OOO", 11699
        
        Set BQ4__ = CreateObject("Scripting.Dictionary")
        BQ4__.Add "BHH", -3895
        BQ4__.Add "BIH", 3761
        BQ4__.Add "BII", -4654
        BQ4__.Add "BIK", 1348
        BQ4__.Add "BKK", -1806
        BQ4__.Add "BMI", -3385
        BQ4__.Add "BOO", -12396
        BQ4__.Add "OAH", 926
        BQ4__.Add "OHH", 266
        BQ4__.Add "OHK", -2036
        BQ4__.Add "ONN", -973
        
        Set BW1__ = CreateObject("Scripting.Dictionary")
        BW1__.Add ",と", 660
        BW1__.Add ",同", 727
        BW1__.Add "B1あ", 1404
        BW1__.Add "B1同", 542
        BW1__.Add "、と", 660
        BW1__.Add "、同", 727
        BW1__.Add "」と", 1682
        BW1__.Add "あっ", 1505
        BW1__.Add "いう", 1743
        BW1__.Add "いっ", -2055
        BW1__.Add "いる", 672
        BW1__.Add "うし", -4817
        BW1__.Add "うん", 665
        BW1__.Add "から", 3472
        BW1__.Add "がら", 600
        BW1__.Add "こう", -790
        BW1__.Add "こと", 2083
        BW1__.Add "こん", -1262
        BW1__.Add "さら", -4143
        BW1__.Add "さん", 4573
        BW1__.Add "した", 2641
        BW1__.Add "して", 1104
        BW1__.Add "すで", -3399
        BW1__.Add "そこ", 1977
        BW1__.Add "それ", -871
        BW1__.Add "たち", 1122
        BW1__.Add "ため", 601
        BW1__.Add "った", 3463
        BW1__.Add "つい", -802
        BW1__.Add "てい", 805
        BW1__.Add "てき", 1249
        BW1__.Add "でき", 1127
        BW1__.Add "です", 3445
        BW1__.Add "では", 844
        BW1__.Add "とい", -4915
        BW1__.Add "とみ", 1922
        BW1__.Add "どこ", 3887
        BW1__.Add "ない", 5713
        BW1__.Add "なっ", 3015
        BW1__.Add "など", 7379
        BW1__.Add "なん", -1113
        BW1__.Add "にし", 2468
        BW1__.Add "には", 1498
        BW1__.Add "にも", 1671
        BW1__.Add "に対", -912
        BW1__.Add "の一", -501
        BW1__.Add "の中", 741
        BW1__.Add "ませ", 2448
        BW1__.Add "まで", 1711
        BW1__.Add "まま", 2600
        BW1__.Add "まる", -2155
        BW1__.Add "やむ", -1947
        BW1__.Add "よっ", -2565
        BW1__.Add "れた", 2369
        BW1__.Add "れで", -913
        BW1__.Add "をし", 1860
        BW1__.Add "を見", 731
        BW1__.Add "亡く", -1886
        BW1__.Add "京都", 2558
        BW1__.Add "取り", -2784
        BW1__.Add "大き", -2604
        BW1__.Add "大阪", 1497
        BW1__.Add "平方", -2314
        BW1__.Add "引き", -1336
        BW1__.Add "日本", -195
        BW1__.Add "本当", -2423
        BW1__.Add "毎日", -2113
        BW1__.Add "目指", -724
        BW1__.Add "Ｂ１あ", 1404
        BW1__.Add "Ｂ１同", 542
        BW1__.Add "｣と", 1682
        
        Set BW2__ = CreateObject("Scripting.Dictionary")
        BW2__.Add "..", -11822
        BW2__.Add "11", -669
        BW2__.Add "――", -5730
        BW2__.Add "??", -13175
        BW2__.Add "いう", -1609
        BW2__.Add "うか", 2490
        BW2__.Add "かし", -1350
        BW2__.Add "かも", -602
        BW2__.Add "から", -7194
        BW2__.Add "かれ", 4612
        BW2__.Add "がい", 853
        BW2__.Add "がら", -3198
        BW2__.Add "きた", 1941
        BW2__.Add "くな", -1597
        BW2__.Add "こと", -8392
        BW2__.Add "この", -4193
        BW2__.Add "させ", 4533
        BW2__.Add "され", 13168
        BW2__.Add "さん", -3977
        BW2__.Add "しい", -1819
        BW2__.Add "しか", -545
        BW2__.Add "した", 5078
        BW2__.Add "して", 972
        BW2__.Add "しな", 939
        BW2__.Add "その", -3744
        BW2__.Add "たい", -1253
        BW2__.Add "たた", -662
        BW2__.Add "ただ", -3857
        BW2__.Add "たち", -786
        BW2__.Add "たと", 1224
        BW2__.Add "たは", -939
        BW2__.Add "った", 4589
        BW2__.Add "って", 1647
        BW2__.Add "っと", -2094
        BW2__.Add "てい", 6144
        BW2__.Add "てき", 3640
        BW2__.Add "てく", 2551
        BW2__.Add "ては", -3110
        BW2__.Add "ても", -3065
        BW2__.Add "でい", 2666
        BW2__.Add "でき", -1528
        BW2__.Add "でし", -3828
        BW2__.Add "です", -4761
        BW2__.Add "でも", -4203
        BW2__.Add "とい", 1890
        BW2__.Add "とこ", -1746
        BW2__.Add "とと", -2279
        BW2__.Add "との", 720
        BW2__.Add "とみ", 5168
        BW2__.Add "とも", -3941
        BW2__.Add "ない", -2488
        BW2__.Add "なが", -1313
        BW2__.Add "など", -6509
        BW2__.Add "なの", 2614
        BW2__.Add "なん", 3099
        BW2__.Add "にお", -1615
        BW2__.Add "にし", 2748
        BW2__.Add "にな", 2454
        BW2__.Add "によ", -7236
        BW2__.Add "に対", -14943
        BW2__.Add "に従", -4688
        BW2__.Add "に関", -11388
        BW2__.Add "のか", 2093
        BW2__.Add "ので", -7059
        BW2__.Add "のに", -6041
        BW2__.Add "のの", -6125
        BW2__.Add "はい", 1073
        BW2__.Add "はが", -1033
        BW2__.Add "はず", -2532
        BW2__.Add "ばれ", 1813
        BW2__.Add "まし", -1316
        BW2__.Add "まで", -6621
        BW2__.Add "まれ", 5409
        BW2__.Add "めて", -3153
        BW2__.Add "もい", 2230
        BW2__.Add "もの", -10713
        BW2__.Add "らか", -944
        BW2__.Add "らし", -1611
        BW2__.Add "らに", -1897
        BW2__.Add "りし", 651
        BW2__.Add "りま", 1620
        BW2__.Add "れた", 4270
        BW2__.Add "れて", 849
        BW2__.Add "れば", 4114
        BW2__.Add "ろう", 6067
        BW2__.Add "われ", 7901
        BW2__.Add "を通", -11877
        BW2__.Add "んだ", 728
        BW2__.Add "んな", -4115
        BW2__.Add "一人", 602
        BW2__.Add "一方", -1375
        BW2__.Add "一日", 970
        BW2__.Add "一部", -1051
        BW2__.Add "上が", -4479
        BW2__.Add "会社", -1116
        BW2__.Add "出て", 2163
        BW2__.Add "分の", -7758
        BW2__.Add "同党", 970
        BW2__.Add "同日", -913
        BW2__.Add "大阪", -2471
        BW2__.Add "委員", -1250
        BW2__.Add "少な", -1050
        BW2__.Add "年度", -8669
        BW2__.Add "年間", -1626
        BW2__.Add "府県", -2363
        BW2__.Add "手権", -1982
        BW2__.Add "新聞", -4066
        BW2__.Add "日新", -722
        BW2__.Add "日本", -7068
        BW2__.Add "日米", 3372
        BW2__.Add "曜日", -601
        BW2__.Add "朝鮮", -2355
        BW2__.Add "本人", -2697
        BW2__.Add "東京", -1543
        BW2__.Add "然と", -1384
        BW2__.Add "社会", -1276
        BW2__.Add "立て", -990
        BW2__.Add "第に", -1612
        BW2__.Add "米国", -4268
        BW2__.Add "１１", -669
        
        Set BW3__ = CreateObject("Scripting.Dictionary")
        BW3__.Add "あた", -2194
        BW3__.Add "あり", 719
        BW3__.Add "ある", 3846
        BW3__.Add "い.", -1185
        BW3__.Add "い。", -1185
        BW3__.Add "いい", 5308
        BW3__.Add "いえ", 2079
        BW3__.Add "いく", 3029
        BW3__.Add "いた", 2056
        BW3__.Add "いっ", 1883
        BW3__.Add "いる", 5600
        BW3__.Add "いわ", 1527
        BW3__.Add "うち", 1117
        BW3__.Add "うと", 4798
        BW3__.Add "えと", 1454
        BW3__.Add "か.", 2857
        BW3__.Add "か。", 2857
        BW3__.Add "かけ", -743
        BW3__.Add "かっ", -4098
        BW3__.Add "かに", -669
        BW3__.Add "から", 6520
        BW3__.Add "かり", -2670
        BW3__.Add "が,", 1816
        BW3__.Add "が、", 1816
        BW3__.Add "がき", -4855
        BW3__.Add "がけ", -1127
        BW3__.Add "がっ", -913
        BW3__.Add "がら", -4977
        BW3__.Add "がり", -2064
        BW3__.Add "きた", 1645
        BW3__.Add "けど", 1374
        BW3__.Add "こと", 7397
        BW3__.Add "この", 1542
        BW3__.Add "ころ", -2757
        BW3__.Add "さい", -714
        BW3__.Add "さを", 976
        BW3__.Add "し,", 1557
        BW3__.Add "し、", 1557
        BW3__.Add "しい", -3714
        BW3__.Add "した", 3562
        BW3__.Add "して", 1449
        BW3__.Add "しな", 2608
        BW3__.Add "しま", 1200
        BW3__.Add "す.", -1310
        BW3__.Add "す。", -1310
        BW3__.Add "する", 6521
        BW3__.Add "ず,", 3426
        BW3__.Add "ず、", 3426
        BW3__.Add "ずに", 841
        BW3__.Add "そう", 428
        BW3__.Add "た.", 8875
        BW3__.Add "た。", 8875
        BW3__.Add "たい", -594
        BW3__.Add "たの", 812
        BW3__.Add "たり", -1183
        BW3__.Add "たる", -853
        BW3__.Add "だ.", 4098
        BW3__.Add "だ。", 4098
        BW3__.Add "だっ", 1004
        BW3__.Add "った", -4748
        BW3__.Add "って", 300
        BW3__.Add "てい", 6240
        BW3__.Add "てお", 855
        BW3__.Add "ても", 302
        BW3__.Add "です", 1437
        BW3__.Add "でに", -1482
        BW3__.Add "では", 2295
        BW3__.Add "とう", -1387
        BW3__.Add "とし", 2266
        BW3__.Add "との", 541
        BW3__.Add "とも", -3543
        BW3__.Add "どう", 4664
        BW3__.Add "ない", 1796
        BW3__.Add "なく", -903
        BW3__.Add "など", 2135
        BW3__.Add "に,", -1021
        BW3__.Add "に、", -1021
        BW3__.Add "にし", 1771
        BW3__.Add "にな", 1906
        BW3__.Add "には", 2644
        BW3__.Add "の,", -724
        BW3__.Add "の、", -724
        BW3__.Add "の子", -1000
        BW3__.Add "は,", 1337
        BW3__.Add "は、", 1337
        BW3__.Add "べき", 2181
        BW3__.Add "まし", 1113
        BW3__.Add "ます", 6943
        BW3__.Add "まっ", -1549
        BW3__.Add "まで", 6154
        BW3__.Add "まれ", -793
        BW3__.Add "らし", 1479
        BW3__.Add "られ", 6820
        BW3__.Add "るる", 3818
        BW3__.Add "れ,", 854
        BW3__.Add "れ、", 854
        BW3__.Add "れた", 1850
        BW3__.Add "れて", 1375
        BW3__.Add "れば", -3246
        BW3__.Add "れる", 1091
        BW3__.Add "われ", -605
        BW3__.Add "んだ", 606
        BW3__.Add "んで", 798
        BW3__.Add "カ月", 990
        BW3__.Add "会議", 860
        BW3__.Add "入り", 1232
        BW3__.Add "大会", 2217
        BW3__.Add "始め", 1681
        BW3__.Add "市", 965
        BW3__.Add "新聞", -5055
        BW3__.Add "日,", 974
        BW3__.Add "日、", 974
        BW3__.Add "社会", 2024
        BW3__.Add "ｶ月", 990
        
        Set TC1__ = CreateObject("Scripting.Dictionary")
        TC1__.Add "AAA", 1093
        TC1__.Add "HHH", 1029
        TC1__.Add "HHM", 580
        TC1__.Add "HII", 998
        TC1__.Add "HOH", -390
        TC1__.Add "HOM", -331
        TC1__.Add "IHI", 1169
        TC1__.Add "IOH", -142
        TC1__.Add "IOI", -1015
        TC1__.Add "IOM", 467
        TC1__.Add "MMH", 187
        TC1__.Add "OOI", -1832
        
        Set TC2__ = CreateObject("Scripting.Dictionary")
        TC2__.Add "HHO", 2088
        TC2__.Add "HII", -1023
        TC2__.Add "HMM", -1154
        TC2__.Add "IHI", -1965
        TC2__.Add "KKH", 703
        TC2__.Add "OII", -2649
        
        Set TC3__ = CreateObject("Scripting.Dictionary")
        TC3__.Add "AAA", -294
        TC3__.Add "HHH", 346
        TC3__.Add "HHI", -341
        TC3__.Add "HII", -1088
        TC3__.Add "HIK", 731
        TC3__.Add "HOH", -1486
        TC3__.Add "IHH", 128
        TC3__.Add "IHI", -3041
        TC3__.Add "IHO", -1935
        TC3__.Add "IIH", -825
        TC3__.Add "IIM", -1035
        TC3__.Add "IOI", -542
        TC3__.Add "KHH", -1216
        TC3__.Add "KKA", 491
        TC3__.Add "KKH", -1217
        TC3__.Add "KOK", -1009
        TC3__.Add "MHH", -2694
        TC3__.Add "MHM", -457
        TC3__.Add "MHO", 123
        TC3__.Add "MMH", -471
        TC3__.Add "NNH", -1689
        TC3__.Add "NNO", 662
        TC3__.Add "OHO", -3393
        
        Set TC4__ = CreateObject("Scripting.Dictionary")
        TC4__.Add "HHH", -203
        TC4__.Add "HHI", 1344
        TC4__.Add "HHK", 365
        TC4__.Add "HHM", -122
        TC4__.Add "HHN", 182
        TC4__.Add "HHO", 669
        TC4__.Add "HIH", 804
        TC4__.Add "HII", 679
        TC4__.Add "HOH", 446
        TC4__.Add "IHH", 695
        TC4__.Add "IHO", -2324
        TC4__.Add "IIH", 321
        TC4__.Add "III", 1497
        TC4__.Add "IIO", 656
        TC4__.Add "IOO", 54
        TC4__.Add "KAK", 4845
        TC4__.Add "KKA", 3386
        TC4__.Add "KKK", 3065
        TC4__.Add "MHH", -405
        TC4__.Add "MHI", 201
        TC4__.Add "MMH", -241
        TC4__.Add "MMM", 661
        TC4__.Add "MOM", 841
        
        Set TQ1__ = CreateObject("Scripting.Dictionary")
        TQ1__.Add "BHHH", -227
        TQ1__.Add "BHHI", 316
        TQ1__.Add "BHIH", -132
        TQ1__.Add "BIHH", 60
        TQ1__.Add "BIII", 1595
        TQ1__.Add "BNHH", -744
        TQ1__.Add "BOHH", 225
        TQ1__.Add "BOOO", -908
        TQ1__.Add "OAKK", 482
        TQ1__.Add "OHHH", 281
        TQ1__.Add "OHIH", 249
        TQ1__.Add "OIHI", 200
        TQ1__.Add "OIIH", -68
        
        Set TQ2__ = CreateObject("Scripting.Dictionary")
        TQ2__.Add "BIHH", -1401
        TQ2__.Add "BIII", -1033
        TQ2__.Add "BKAK", -543
        TQ2__.Add "BOOO", -5591
        
        Set TQ3__ = CreateObject("Scripting.Dictionary")
        TQ3__.Add "BHHH", 478
        TQ3__.Add "BHHM", -1073
        TQ3__.Add "BHIH", 222
        TQ3__.Add "BHII", -504
        TQ3__.Add "BIIH", -116
        TQ3__.Add "BIII", -105
        TQ3__.Add "BMHI", -863
        TQ3__.Add "BMHM", -464
        TQ3__.Add "BOMH", 620
        TQ3__.Add "OHHH", 346
        TQ3__.Add "OHHI", 1729
        TQ3__.Add "OHII", 997
        TQ3__.Add "OHMH", 481
        TQ3__.Add "OIHH", 623
        TQ3__.Add "OIIH", 1344
        TQ3__.Add "OKAK", 2792
        TQ3__.Add "OKHH", 587
        TQ3__.Add "OKKA", 679
        TQ3__.Add "OOHH", 110
        TQ3__.Add "OOII", -685
        
        Set TQ4__ = CreateObject("Scripting.Dictionary")
        TQ4__.Add "BHHH", -721
        TQ4__.Add "BHHM", -3604
        TQ4__.Add "BHII", -966
        TQ4__.Add "BIIH", -607
        TQ4__.Add "BIII", -2181
        TQ4__.Add "OAAA", -2763
        TQ4__.Add "OAKK", 180
        TQ4__.Add "OHHH", -294
        TQ4__.Add "OHHI", 2446
        TQ4__.Add "OHHO", 480
        TQ4__.Add "OHIH", -1573
        TQ4__.Add "OIHH", 1935
        TQ4__.Add "OIHI", -493
        TQ4__.Add "OIIH", 626
        TQ4__.Add "OIII", -4007
        TQ4__.Add "OKAK", -8156
        
        Set TW1__ = CreateObject("Scripting.Dictionary")
        TW1__.Add "につい", -4681
        TW1__.Add "東京都", 2026
        
        Set TW2__ = CreateObject("Scripting.Dictionary")
        TW2__.Add "ある程", -2049
        TW2__.Add "いった", -1256
        TW2__.Add "ころが", -2434
        TW2__.Add "しょう", 3873
        TW2__.Add "その後", -4430
        TW2__.Add "だって", -1049
        TW2__.Add "ていた", 1833
        TW2__.Add "として", -4657
        TW2__.Add "ともに", -4517
        TW2__.Add "もので", 1882
        TW2__.Add "一気に", -792
        TW2__.Add "初めて", -1512
        TW2__.Add "同時に", -8097
        TW2__.Add "大きな", -1255
        TW2__.Add "対して", -2721
        TW2__.Add "社会党", -3216
        
        Set TW3__ = CreateObject("Scripting.Dictionary")
        TW3__.Add "いただ", -1734
        TW3__.Add "してい", 1314
        TW3__.Add "として", -4314
        TW3__.Add "につい", -5483
        TW3__.Add "にとっ", -5989
        TW3__.Add "に当た", -6247
        TW3__.Add "ので,", -727
        TW3__.Add "ので、", -727
        TW3__.Add "のもの", -600
        TW3__.Add "れから", -3752
        TW3__.Add "十二月", -2287
        
        Set TW4__ = CreateObject("Scripting.Dictionary")
        TW4__.Add "いう.", 8576
        TW4__.Add "いう。", 8576
        TW4__.Add "からな", -2348
        TW4__.Add "してい", 2958
        TW4__.Add "たが,", 1516
        TW4__.Add "たが、", 1516
        TW4__.Add "ている", 1538
        TW4__.Add "という", 1349
        TW4__.Add "ました", 5543
        TW4__.Add "ません", 1097
        TW4__.Add "ようと", -4258
        TW4__.Add "よると", 5865
        
        Set UC1__ = CreateObject("Scripting.Dictionary")
        UC1__.Add "A", 484
        UC1__.Add "K", 93
        UC1__.Add "M", 645
        UC1__.Add "O", -505
        
        Set UC2__ = CreateObject("Scripting.Dictionary")
        UC2__.Add "A", 819
        UC2__.Add "H", 1059
        UC2__.Add "I", 409
        UC2__.Add "M", 3987
        UC2__.Add "N", 5775
        UC2__.Add "O", 646
        
        Set UC3__ = CreateObject("Scripting.Dictionary")
        UC3__.Add "A", -1370
        UC3__.Add "I", 2311
        
        Set UC4__ = CreateObject("Scripting.Dictionary")
        UC4__.Add "A", -2643
        UC4__.Add "H", 1809
        UC4__.Add "I", -1032
        UC4__.Add "K", -3450
        UC4__.Add "M", 3565
        UC4__.Add "N", 3876
        UC4__.Add "O", 6646
        
        Set UC5__ = CreateObject("Scripting.Dictionary")
        UC5__.Add "H", 313
        UC5__.Add "I", -1238
        UC5__.Add "K", -799
        UC5__.Add "M", 539
        UC5__.Add "O", -831
        
        Set UC6__ = CreateObject("Scripting.Dictionary")
        UC6__.Add "H", -506
        UC6__.Add "I", -253
        UC6__.Add "K", 87
        UC6__.Add "M", 247
        UC6__.Add "O", -387
        
        Set UP1__ = CreateObject("Scripting.Dictionary")
        UP1__.Add "O", -214
        
        Set UP2__ = CreateObject("Scripting.Dictionary")
        UP2__.Add "B", 69
        UP2__.Add "O", 935
        
        Set UP3__ = CreateObject("Scripting.Dictionary")
        UP3__.Add "B", 189
        
        Set UQ1__ = CreateObject("Scripting.Dictionary")
        UQ1__.Add "BH", 21
        UQ1__.Add "BI", -12
        UQ1__.Add "BK", -99
        UQ1__.Add "BN", 142
        UQ1__.Add "BO", -56
        UQ1__.Add "OH", -95
        UQ1__.Add "OI", 477
        UQ1__.Add "OK", 410
        UQ1__.Add "OO", -2422
        
        Set UQ2__ = CreateObject("Scripting.Dictionary")
        UQ2__.Add "BH", 216
        UQ2__.Add "BI", 113
        UQ2__.Add "OK", 1759
        
        Set UQ3__ = CreateObject("Scripting.Dictionary")
        UQ3__.Add "BA", -479
        UQ3__.Add "BH", 42
        UQ3__.Add "BI", 1913
        UQ3__.Add "BK", -7198
        UQ3__.Add "BM", 3160
        UQ3__.Add "BN", 6427
        UQ3__.Add "BO", 14761
        UQ3__.Add "OI", -827
        UQ3__.Add "ON", -3212
        
        Set UW1__ = CreateObject("Scripting.Dictionary")
        UW1__.Add ",", 156
        UW1__.Add "、", 156
        UW1__.Add "「", -463
        UW1__.Add "あ", -941
        UW1__.Add "う", -127
        UW1__.Add "が", -553
        UW1__.Add "き", 121
        UW1__.Add "こ", 505
        UW1__.Add "で", -201
        UW1__.Add "と", -547
        UW1__.Add "ど", -123
        UW1__.Add "に", -789
        UW1__.Add "の", -185
        UW1__.Add "は", -847
        UW1__.Add "も", -466
        UW1__.Add "や", -470
        UW1__.Add "よ", 182
        UW1__.Add "ら", -292
        UW1__.Add "り", 208
        UW1__.Add "れ", 169
        UW1__.Add "を", -446
        UW1__.Add "ん", -137
        UW1__.Add "・", -135
        UW1__.Add "主", -402
        UW1__.Add "京", -268
        UW1__.Add "区", -912
        UW1__.Add "午", 871
        UW1__.Add "国", -460
        UW1__.Add "大", 561
        UW1__.Add "委", 729
        UW1__.Add "市", -411
        UW1__.Add "日", -141
        UW1__.Add "理", 361
        UW1__.Add "生", -408
        UW1__.Add "県", -386
        UW1__.Add "都", -718
        UW1__.Add "｢", -463
        UW1__.Add "･", -135
        
        Set UW2__ = CreateObject("Scripting.Dictionary")
        UW2__.Add ",", -829
        UW2__.Add "、", -829
        UW2__.Add "〇", 892
        UW2__.Add "「", -645
        UW2__.Add "」", 3145
        UW2__.Add "あ", -538
        UW2__.Add "い", 505
        UW2__.Add "う", 134
        UW2__.Add "お", -502
        UW2__.Add "か", 1454
        UW2__.Add "が", -856
        UW2__.Add "く", -412
        UW2__.Add "こ", 1141
        UW2__.Add "さ", 878
        UW2__.Add "ざ", 540
        UW2__.Add "し", 1529
        UW2__.Add "す", -675
        UW2__.Add "せ", 300
        UW2__.Add "そ", -1011
        UW2__.Add "た", 188
        UW2__.Add "だ", 1837
        UW2__.Add "つ", -949
        UW2__.Add "て", -291
        UW2__.Add "で", -268
        UW2__.Add "と", -981
        UW2__.Add "ど", 1273
        UW2__.Add "な", 1063
        UW2__.Add "に", -1764
        UW2__.Add "の", 130
        UW2__.Add "は", -409
        UW2__.Add "ひ", -1273
        UW2__.Add "べ", 1261
        UW2__.Add "ま", 600
        UW2__.Add "も", -1263
        UW2__.Add "や", -402
        UW2__.Add "よ", 1639
        UW2__.Add "り", -579
        UW2__.Add "る", -694
        UW2__.Add "れ", 571
        UW2__.Add "を", -2516
        UW2__.Add "ん", 2095
        UW2__.Add "ア", -587
        UW2__.Add "カ", 306
        UW2__.Add "キ", 568
        UW2__.Add "ッ", 831
        UW2__.Add "三", -758
        UW2__.Add "不", -2150
        UW2__.Add "世", -302
        UW2__.Add "中", -968
        UW2__.Add "主", -861
        UW2__.Add "事", 492
        UW2__.Add "人", -123
        UW2__.Add "会", 978
        UW2__.Add "保", 362
        UW2__.Add "入", 548
        UW2__.Add "初", -3025
        UW2__.Add "副", -1566
        UW2__.Add "北", -3414
        UW2__.Add "区", -422
        UW2__.Add "大", -1769
        UW2__.Add "天", -865
        UW2__.Add "太", -483
        UW2__.Add "子", -1519
        UW2__.Add "学", 760
        UW2__.Add "実", 1023
        UW2__.Add "小", -2009
        UW2__.Add "市", -813
        UW2__.Add "年", -1060
        UW2__.Add "強", 1067
        UW2__.Add "手", -1519
        UW2__.Add "揺", -1033
        UW2__.Add "政", 1522
        UW2__.Add "文", -1355
        UW2__.Add "新", -1682
        UW2__.Add "日", -1815
        UW2__.Add "明", -1462
        UW2__.Add "最", -630
        UW2__.Add "朝", -1843
        UW2__.Add "本", -1650
        UW2__.Add "東", -931
        UW2__.Add "果", -665
        UW2__.Add "次", -2378
        UW2__.Add "民", -180
        UW2__.Add "気", -1740
        UW2__.Add "理", 752
        UW2__.Add "発", 529
        UW2__.Add "目", -1584
        UW2__.Add "相", -242
        UW2__.Add "県", -1165
        UW2__.Add "立", -763
        UW2__.Add "第", 810
        UW2__.Add "米", 509
        UW2__.Add "自", -1353
        UW2__.Add "行", 838
        UW2__.Add "西", -744
        UW2__.Add "見", -3874
        UW2__.Add "調", 1010
        UW2__.Add "議", 1198
        UW2__.Add "込", 3041
        UW2__.Add "開", 1758
        UW2__.Add "間", -1257
        UW2__.Add "｢", -645
        UW2__.Add "｣", 3145
        UW2__.Add "ｯ", 831
        UW2__.Add "ｱ", -587
        UW2__.Add "ｶ", 306
        UW2__.Add "ｷ", 568
        
        Set UW3__ = CreateObject("Scripting.Dictionary")
        UW3__.Add ",", 4889
        UW3__.Add "1", -800
        UW3__.Add "?", -1723
        UW3__.Add "、", 4889
        UW3__.Add "々", -2311
        UW3__.Add "〇", 5827
        UW3__.Add "」", 2670
        UW3__.Add "〓", -3573
        UW3__.Add "あ", -2696
        UW3__.Add "い", 1006
        UW3__.Add "う", 2342
        UW3__.Add "え", 1983
        UW3__.Add "お", -4864
        UW3__.Add "か", -1163
        UW3__.Add "が", 3271
        UW3__.Add "く", 1004
        UW3__.Add "け", 388
        UW3__.Add "げ", 401
        UW3__.Add "こ", -3552
        UW3__.Add "ご", -3116
        UW3__.Add "さ", -1058
        UW3__.Add "し", -395
        UW3__.Add "す", 584
        UW3__.Add "せ", 3685
        UW3__.Add "そ", -5228
        UW3__.Add "た", 842
        UW3__.Add "ち", -521
        UW3__.Add "っ", -1444
        UW3__.Add "つ", -1081
        UW3__.Add "て", 6167
        UW3__.Add "で", 2318
        UW3__.Add "と", 1691
        UW3__.Add "ど", -899
        UW3__.Add "な", -2788
        UW3__.Add "に", 2745
        UW3__.Add "の", 4056
        UW3__.Add "は", 4555
        UW3__.Add "ひ", -2171
        UW3__.Add "ふ", -1798
        UW3__.Add "へ", 1199
        UW3__.Add "ほ", -5516
        UW3__.Add "ま", -4384
        UW3__.Add "み", -120
        UW3__.Add "め", 1205
        UW3__.Add "も", 2323
        UW3__.Add "や", -788
        UW3__.Add "よ", -202
        UW3__.Add "ら", 727
        UW3__.Add "り", 649
        UW3__.Add "る", 5905
        UW3__.Add "れ", 2773
        UW3__.Add "わ", -1207
        UW3__.Add "を", 6620
        UW3__.Add "ん", -518
        UW3__.Add "ア", 551
        UW3__.Add "グ", 1319
        UW3__.Add "ス", 874
        UW3__.Add "ッ", -1350
        UW3__.Add "ト", 521
        UW3__.Add "ム", 1109
        UW3__.Add "ル", 1591
        UW3__.Add "ロ", 2201
        UW3__.Add "ン", 278
        UW3__.Add "・", -3794
        UW3__.Add "一", -1619
        UW3__.Add "下", -1759
        UW3__.Add "世", -2087
        UW3__.Add "両", 3815
        UW3__.Add "中", 653
        UW3__.Add "主", -758
        UW3__.Add "予", -1193
        UW3__.Add "二", 974
        UW3__.Add "人", 2742
        UW3__.Add "今", 792
        UW3__.Add "他", 1889
        UW3__.Add "以", -1368
        UW3__.Add "低", 811
        UW3__.Add "何", 4265
        UW3__.Add "作", -361
        UW3__.Add "保", -2439
        UW3__.Add "元", 4858
        UW3__.Add "党", 3593
        UW3__.Add "全", 1574
        UW3__.Add "公", -3030
        UW3__.Add "六", 755
        UW3__.Add "共", -1880
        UW3__.Add "円", 5807
        UW3__.Add "再", 3095
        UW3__.Add "分", 457
        UW3__.Add "初", 2475
        UW3__.Add "別", 1129
        UW3__.Add "前", 2286
        UW3__.Add "副", 4437
        UW3__.Add "力", 365
        UW3__.Add "動", -949
        UW3__.Add "務", -1872
        UW3__.Add "化", 1327
        UW3__.Add "北", -1038
        UW3__.Add "区", 4646
        UW3__.Add "千", -2309
        UW3__.Add "午", -783
        UW3__.Add "協", -1006
        UW3__.Add "口", 483
        UW3__.Add "右", 1233
        UW3__.Add "各", 3588
        UW3__.Add "合", -241
        UW3__.Add "同", 3906
        UW3__.Add "和", -837
        UW3__.Add "員", 4513
        UW3__.Add "国", 642
        UW3__.Add "型", 1389
        UW3__.Add "場", 1219
        UW3__.Add "外", -241
        UW3__.Add "妻", 2016
        UW3__.Add "学", -1356
        UW3__.Add "安", -423
        UW3__.Add "実", -1008
        UW3__.Add "家", 1078
        UW3__.Add "小", -513
        UW3__.Add "少", -3102
        UW3__.Add "州", 1155
        UW3__.Add "市", 3197
        UW3__.Add "平", -1804
        UW3__.Add "年", 2416
        UW3__.Add "広", -1030
        UW3__.Add "府", 1605
        UW3__.Add "度", 1452
        UW3__.Add "建", -2352
        UW3__.Add "当", -3885
        UW3__.Add "得", 1905
        UW3__.Add "思", -1291
        UW3__.Add "性", 1822
        UW3__.Add "戸", -488
        UW3__.Add "指", -3973
        UW3__.Add "政", -2013
        UW3__.Add "教", -1479
        UW3__.Add "数", 3222
        UW3__.Add "文", -1489
        UW3__.Add "新", 1764
        UW3__.Add "日", 2099
        UW3__.Add "旧", 5792
        UW3__.Add "昨", -661
        UW3__.Add "時", -1248
        UW3__.Add "曜", -951
        UW3__.Add "最", -937
        UW3__.Add "月", 4125
        UW3__.Add "期", 360
        UW3__.Add "李", 3094
        UW3__.Add "村", 364
        UW3__.Add "東", -805
        UW3__.Add "核", 5156
        UW3__.Add "森", 2438
        UW3__.Add "業", 484
        UW3__.Add "氏", 2613
        UW3__.Add "民", -1694
        UW3__.Add "決", -1073
        UW3__.Add "法", 1868
        UW3__.Add "海", -495
        UW3__.Add "無", 979
        UW3__.Add "物", 461
        UW3__.Add "特", -3850
        UW3__.Add "生", -273
        UW3__.Add "用", 914
        UW3__.Add "町", 1215
        UW3__.Add "的", 7313
        UW3__.Add "直", -1835
        UW3__.Add "省", 792
        UW3__.Add "県", 6293
        UW3__.Add "知", -1528
        UW3__.Add "私", 4231
        UW3__.Add "税", 401
        UW3__.Add "立", -960
        UW3__.Add "第", 1201
        UW3__.Add "米", 7767
        UW3__.Add "系", 3066
        UW3__.Add "約", 3663
        UW3__.Add "級", 1384
        UW3__.Add "統", -4229
        UW3__.Add "総", 1163
        UW3__.Add "線", 1255
        UW3__.Add "者", 6457
        UW3__.Add "能", 725
        UW3__.Add "自", -2869
        UW3__.Add "英", 785
        UW3__.Add "見", 1044
        UW3__.Add "調", -562
        UW3__.Add "財", -733
        UW3__.Add "費", 1777
        UW3__.Add "車", 1835
        UW3__.Add "軍", 1375
        UW3__.Add "込", -1504
        UW3__.Add "通", -1136
        UW3__.Add "選", -681
        UW3__.Add "郎", 1026
        UW3__.Add "郡", 4404
        UW3__.Add "部", 1200
        UW3__.Add "金", 2163
        UW3__.Add "長", 421
        UW3__.Add "開", -1432
        UW3__.Add "間", 1302
        UW3__.Add "関", -1282
        UW3__.Add "雨", 2009
        UW3__.Add "電", -1045
        UW3__.Add "非", 2066
        UW3__.Add "駅", 1620
        UW3__.Add "１", -800
        UW3__.Add "｣", 2670
        UW3__.Add "･", -3794
        UW3__.Add "ｯ", -1350
        UW3__.Add "ｱ", 551
        UW3__.Add "ｸﾞ", 1319
        UW3__.Add "ｽ", 874
        UW3__.Add "ﾄ", 521
        UW3__.Add "ﾑ", 1109
        UW3__.Add "ﾙ", 1591
        UW3__.Add "ﾛ", 2201
        UW3__.Add "ﾝ", 278
        
        Set UW4__ = CreateObject("Scripting.Dictionary")
        UW4__.Add ",", 3930
        UW4__.Add ".", 3508
        UW4__.Add "―", -4841
        UW4__.Add "、", 3930
        UW4__.Add "。", 3508
        UW4__.Add "〇", 4999
        UW4__.Add "「", 1895
        UW4__.Add "」", 3798
        UW4__.Add "〓", -5156
        UW4__.Add "あ", 4752
        UW4__.Add "い", -3435
        UW4__.Add "う", -640
        UW4__.Add "え", -2514
        UW4__.Add "お", 2405
        UW4__.Add "か", 530
        UW4__.Add "が", 6006
        UW4__.Add "き", -4482
        UW4__.Add "ぎ", -3821
        UW4__.Add "く", -3788
        UW4__.Add "け", -4376
        UW4__.Add "げ", -4734
        UW4__.Add "こ", 2255
        UW4__.Add "ご", 1979
        UW4__.Add "さ", 2864
        UW4__.Add "し", -843
        UW4__.Add "じ", -2506
        UW4__.Add "す", -731
        UW4__.Add "ず", 1251
        UW4__.Add "せ", 181
        UW4__.Add "そ", 4091
        UW4__.Add "た", 5034
        UW4__.Add "だ", 5408
        UW4__.Add "ち", -3654
        UW4__.Add "っ", -5882
        UW4__.Add "つ", -1659
        UW4__.Add "て", 3994
        UW4__.Add "で", 7410
        UW4__.Add "と", 4547
        UW4__.Add "な", 5433
        UW4__.Add "に", 6499
        UW4__.Add "ぬ", 1853
        UW4__.Add "ね", 1413
        UW4__.Add "の", 7396
        UW4__.Add "は", 8578
        UW4__.Add "ば", 1940
        UW4__.Add "ひ", 4249
        UW4__.Add "び", -4134
        UW4__.Add "ふ", 1345
        UW4__.Add "へ", 6665
        UW4__.Add "べ", -744
        UW4__.Add "ほ", 1464
        UW4__.Add "ま", 1051
        UW4__.Add "み", -2082
        UW4__.Add "む", -882
        UW4__.Add "め", -5046
        UW4__.Add "も", 4169
        UW4__.Add "ゃ", -2666
        UW4__.Add "や", 2795
        UW4__.Add "ょ", -1544
        UW4__.Add "よ", 3351
        UW4__.Add "ら", -2922
        UW4__.Add "り", -9726
        UW4__.Add "る", -14896
        UW4__.Add "れ", -2613
        UW4__.Add "ろ", -4570
        UW4__.Add "わ", -1783
        UW4__.Add "を", 13150
        UW4__.Add "ん", -2352
        UW4__.Add "カ", 2145
        UW4__.Add "コ", 1789
        UW4__.Add "セ", 1287
        UW4__.Add "ッ", -724
        UW4__.Add "ト", -403
        UW4__.Add "メ", -1635
        UW4__.Add "ラ", -881
        UW4__.Add "リ", -541
        UW4__.Add "ル", -856
        UW4__.Add "ン", -3637
        UW4__.Add "・", -4371
        UW4__.Add "ー", -11870
        UW4__.Add "一", -2069
        UW4__.Add "中", 2210
        UW4__.Add "予", 782
        UW4__.Add "事", -190
        UW4__.Add "井", -1768
        UW4__.Add "人", 1036
        UW4__.Add "以", 544
        UW4__.Add "会", 950
        UW4__.Add "体", -1286
        UW4__.Add "作", 530
        UW4__.Add "側", 4292
        UW4__.Add "先", 601
        UW4__.Add "党", -2006
        UW4__.Add "共", -1212
        UW4__.Add "内", 584
        UW4__.Add "円", 788
        UW4__.Add "初", 1347
        UW4__.Add "前", 1623
        UW4__.Add "副", 3879
        UW4__.Add "力", -302
        UW4__.Add "動", -740
        UW4__.Add "務", -2715
        UW4__.Add "化", 776
        UW4__.Add "区", 4517
        UW4__.Add "協", 1013
        UW4__.Add "参", 1555
        UW4__.Add "合", -1834
        UW4__.Add "和", -681
        UW4__.Add "員", -910
        UW4__.Add "器", -851
        UW4__.Add "回", 1500
        UW4__.Add "国", -619
        UW4__.Add "園", -1200
        UW4__.Add "地", 866
        UW4__.Add "場", -1410
        UW4__.Add "塁", -2094
        UW4__.Add "士", -1413
        UW4__.Add "多", 1067
        UW4__.Add "大", 571
        UW4__.Add "子", -4802
        UW4__.Add "学", -1397
        UW4__.Add "定", -1057
        UW4__.Add "寺", -809
        UW4__.Add "小", 1910
        UW4__.Add "屋", -1328
        UW4__.Add "山", -1500
        UW4__.Add "島", -2056
        UW4__.Add "川", -2667
        UW4__.Add "市", 2771
        UW4__.Add "年", 374
        UW4__.Add "庁", -4556
        UW4__.Add "後", 456
        UW4__.Add "性", 553
        UW4__.Add "感", 916
        UW4__.Add "所", -1566
        UW4__.Add "支", 856
        UW4__.Add "改", 787
        UW4__.Add "政", 2182
        UW4__.Add "教", 704
        UW4__.Add "文", 522
        UW4__.Add "方", -856
        UW4__.Add "日", 1798
        UW4__.Add "時", 1829
        UW4__.Add "最", 845
        UW4__.Add "月", -9066
        UW4__.Add "木", -485
        UW4__.Add "来", -442
        UW4__.Add "校", -360
        UW4__.Add "業", -1043
        UW4__.Add "氏", 5388
        UW4__.Add "民", -2716
        UW4__.Add "気", -910
        UW4__.Add "沢", -939
        UW4__.Add "済", -543
        UW4__.Add "物", -735
        UW4__.Add "率", 672
        UW4__.Add "球", -1267
        UW4__.Add "生", -1286
        UW4__.Add "産", -1101
        UW4__.Add "田", -2900
        UW4__.Add "町", 1826
        UW4__.Add "的", 2586
        UW4__.Add "目", 922
        UW4__.Add "省", -3485
        UW4__.Add "県", 2997
        UW4__.Add "空", -867
        UW4__.Add "立", -2112
        UW4__.Add "第", 788
        UW4__.Add "米", 2937
        UW4__.Add "系", 786
        UW4__.Add "約", 2171
        UW4__.Add "経", 1146
        UW4__.Add "統", -1169
        UW4__.Add "総", 940
        UW4__.Add "線", -994
        UW4__.Add "署", 749
        UW4__.Add "者", 2145
        UW4__.Add "能", -730
        UW4__.Add "般", -852
        UW4__.Add "行", -792
        UW4__.Add "規", 792
        UW4__.Add "警", -1184
        UW4__.Add "議", -244
        UW4__.Add "谷", -1000
        UW4__.Add "賞", 730
        UW4__.Add "車", -1481
        UW4__.Add "軍", 1158
        UW4__.Add "輪", -1433
        UW4__.Add "込", -3370
        UW4__.Add "近", 929
        UW4__.Add "道", -1291
        UW4__.Add "選", 2596
        UW4__.Add "郎", -4866
        UW4__.Add "都", 1192
        UW4__.Add "野", -1100
        UW4__.Add "銀", -2213
        UW4__.Add "長", 357
        UW4__.Add "間", -2344
        UW4__.Add "院", -2297
        UW4__.Add "際", -2604
        UW4__.Add "電", -878
        UW4__.Add "領", -1659
        UW4__.Add "題", -792
        UW4__.Add "館", -1984
        UW4__.Add "首", 1749
        UW4__.Add "高", 2120
        UW4__.Add "｢", 1895
        UW4__.Add "｣", 3798
        UW4__.Add "･", -4371
        UW4__.Add "ｯ", -724
        UW4__.Add "ｰ", -11870
        UW4__.Add "ｶ", 2145
        UW4__.Add "ｺ", 1789
        UW4__.Add "ｾ", 1287
        UW4__.Add "ﾄ", -403
        UW4__.Add "ﾒ", -1635
        UW4__.Add "ﾗ", -881
        UW4__.Add "ﾘ", -541
        UW4__.Add "ﾙ", -856
        UW4__.Add "ﾝ", -3637
        
        Set UW5__ = CreateObject("Scripting.Dictionary")
        UW5__.Add ",", 465
        UW5__.Add ".", -299
        UW5__.Add "1", -514
        UW5__.Add "E2", -32768
        UW5__.Add "]", -2762
        UW5__.Add "、", 465
        UW5__.Add "。", -299
        UW5__.Add "「", 363
        UW5__.Add "あ", 1655
        UW5__.Add "い", 331
        UW5__.Add "う", -503
        UW5__.Add "え", 1199
        UW5__.Add "お", 527
        UW5__.Add "か", 647
        UW5__.Add "が", -421
        UW5__.Add "き", 1624
        UW5__.Add "ぎ", 1971
        UW5__.Add "く", 312
        UW5__.Add "げ", -983
        UW5__.Add "さ", -1537
        UW5__.Add "し", -1371
        UW5__.Add "す", -852
        UW5__.Add "だ", -1186
        UW5__.Add "ち", 1093
        UW5__.Add "っ", 52
        UW5__.Add "つ", 921
        UW5__.Add "て", -18
        UW5__.Add "で", -850
        UW5__.Add "と", -127
        UW5__.Add "ど", 1682
        UW5__.Add "な", -787
        UW5__.Add "に", -1224
        UW5__.Add "の", -635
        UW5__.Add "は", -578
        UW5__.Add "べ", 1001
        UW5__.Add "み", 502
        UW5__.Add "め", 865
        UW5__.Add "ゃ", 3350
        UW5__.Add "ょ", 854
        UW5__.Add "り", -208
        UW5__.Add "る", 429
        UW5__.Add "れ", 504
        UW5__.Add "わ", 419
        UW5__.Add "を", -1264
        UW5__.Add "ん", 327
        UW5__.Add "イ", 241
        UW5__.Add "ル", 451
        UW5__.Add "ン", -343
        UW5__.Add "中", -871
        UW5__.Add "京", 722
        UW5__.Add "会", -1153
        UW5__.Add "党", -654
        UW5__.Add "務", 3519
        UW5__.Add "区", -901
        UW5__.Add "告", 848
        UW5__.Add "員", 2104
        UW5__.Add "大", -1296
        UW5__.Add "学", -548
        UW5__.Add "定", 1785
        UW5__.Add "嵐", -1304
        UW5__.Add "市", -2991
        UW5__.Add "席", 921
        UW5__.Add "年", 1763
        UW5__.Add "思", 872
        UW5__.Add "所", -814
        UW5__.Add "挙", 1618
        UW5__.Add "新", -1682
        UW5__.Add "日", 218
        UW5__.Add "月", -4353
        UW5__.Add "査", 932
        UW5__.Add "格", 1356
        UW5__.Add "機", -1508
        UW5__.Add "氏", -1347
        UW5__.Add "田", 240
        UW5__.Add "町", -3912
        UW5__.Add "的", -3149
        UW5__.Add "相", 1319
        UW5__.Add "省", -1052
        UW5__.Add "県", -4003
        UW5__.Add "研", -997
        UW5__.Add "社", -278
        UW5__.Add "空", -813
        UW5__.Add "統", 1955
        UW5__.Add "者", -2233
        UW5__.Add "表", 663
        UW5__.Add "語", -1073
        UW5__.Add "議", 1219
        UW5__.Add "選", -1018
        UW5__.Add "郎", -368
        UW5__.Add "長", 786
        UW5__.Add "間", 1191
        UW5__.Add "題", 2368
        UW5__.Add "館", -689
        UW5__.Add "１", -514
        UW5__.Add "Ｅ２", -32768
        UW5__.Add "｢", 363
        UW5__.Add "ｲ", 241
        UW5__.Add "ﾙ", 451
        UW5__.Add "ﾝ", -343
        
        Set UW6__ = CreateObject("Scripting.Dictionary")
        UW6__.Add ",", 227
        UW6__.Add ".", 808
        UW6__.Add "1", -270
        UW6__.Add "E1", 306
        UW6__.Add "、", 227
        UW6__.Add "。", 808
        UW6__.Add "あ", -307
        UW6__.Add "う", 189
        UW6__.Add "か", 241
        UW6__.Add "が", -73
        UW6__.Add "く", -121
        UW6__.Add "こ", -200
        UW6__.Add "じ", 1782
        UW6__.Add "す", 383
        UW6__.Add "た", -428
        UW6__.Add "っ", 573
        UW6__.Add "て", -1014
        UW6__.Add "で", 101
        UW6__.Add "と", -105
        UW6__.Add "な", -253
        UW6__.Add "に", -149
        UW6__.Add "の", -417
        UW6__.Add "は", -236
        UW6__.Add "も", -206
        UW6__.Add "り", 187
        UW6__.Add "る", -135
        UW6__.Add "を", 195
        UW6__.Add "ル", -673
        UW6__.Add "ン", -496
        UW6__.Add "一", -277
        UW6__.Add "中", 201
        UW6__.Add "件", -800
        UW6__.Add "会", 624
        UW6__.Add "前", 302
        UW6__.Add "区", 1792
        UW6__.Add "員", -1212
        UW6__.Add "委", 798
        UW6__.Add "学", -960
        UW6__.Add "市", 887
        UW6__.Add "広", -695
        UW6__.Add "後", 535
        UW6__.Add "業", -697
        UW6__.Add "相", 753
        UW6__.Add "社", -507
        UW6__.Add "福", 974
        UW6__.Add "空", -822
        UW6__.Add "者", 1811
        UW6__.Add "連", 463
        UW6__.Add "郎", 1082
        UW6__.Add "１", -270
        UW6__.Add "Ｅ１", 306
        UW6__.Add "ﾙ", -673
        UW6__.Add "ﾝ", -496
    
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列をベクトル化してあいまい検索（未完成）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '******************************************************
    ' あいまい検索使用方法のサンプル
    '******************************************************
    Sub FuzzySearchSample()
        
        Dim wsStaffMst As Worksheet
        Set wsStaffMst = ThisWorkbook.Worksheets("社員名簿")
        
        Dim lngLastRow As Long
        Dim vntReturn As Variant
        
        '検索対象となる表（重複の無いセル範囲）から
        '文字列をベクトル変換するためのDictionaryを生成
        With wsStaffMst
            lngLastRow = .Cells(.Rows.Count, "A").End(xlUp).Row
            vntReturn = MakeWordVecDict(.Range(.Cells(2, "B"), .Cells(lngLastRow, "B")))
        End With
        
        Dim dctStaffName As Object  '検索対象となる「文字列&ベクトル」
        Dim dctWordToVec As Object  '文字をベクトルに変換するための読替表
        Dim dctVecToWord As Object  'ベクトルを文字に変換するための読替表
        
        '配列で返却されるため用途に応じて切り分ける
        Set dctStaffName = vntReturn(0)
        Set dctWordToVec = vntReturn(1)
        Set dctVecToWord = vntReturn(2)
        
        'あいまい検索でArray("検索結果文字列", index)が返却される
        MsgBox FuzzySearch("山田 花子（旧姓：佐藤）", dctStaffName, dctWordToVec)(0)
        
    End Sub
    
    
    '******************************************************
    ' セル範囲から文字列を収集しベクトルを生成し
    ' 下記3個のDictionaryを返却
    '******************************************************
    '　■dctWords
    '　　「文字列」「ベクトル」ペアのDictionary
    '　　{"文章" : (1, 1, 0), "文学": (1, 0, 1)}
    '******************************************************
    '　■dctWordToVec
    '　　「文字」「インデックス」ペアのDictionary
    '　　{"文" : 0, "章": 1, "学" : 2}
    '******************************************************
    '　■dctVecToWord
    '　　「インデックス」「文字」ペアのDictionary
    '　　{0 : "文", 1 : "章", 2 : "学"}
    '******************************************************
    '　文章ベクトルのイメージ
    '　--------------------------
    '　　　｜あ｜い｜う｜え｜お｜
    '　--------------------------
    '　あい｜１｜１｜０｜０｜０｜
    '　あお｜１｜０｜０｜０｜１｜
    '　うい｜０｜１｜１｜０｜０｜
    '　--------------------------
    '******************************************************
    Function MakeWordVecDict(ByVal rngWords As Range) As Variant
            
        Dim rngCell As Range
        Dim dctWords As Object
        Set dctWords = CreateObject("Scripting.Dictionary")
        
        
        '*************************************
        ' セル範囲のユニークな文字列を収集
        '*************************************
        For Each rngCell In rngWords
            If dctWords.Exists(rngCell.Value) = False Then
                '「無変換」「全角変換」で格納
                dctWords.Add rngCell.Value, Replace(StrConv(rngCell.Value, vbWide), "　", "")
            End If
        Next
        
        'Dictionaryを準備
        Dim dctWordToVec As Object
        Dim dctVecToWord As Object
        Set dctWordToVec = CreateObject("Scripting.Dictionary")
        Set dctVecToWord = CreateObject("Scripting.Dictionary")
        
        Dim lngIndex As Long
        Dim lngChar As Long
        Dim strWords As String
        Dim strChar As String
        
        
        '*************************************
        ' 全ての文字にインデックス番号を付与
        '*************************************
        For lngIndex = 0 To dctWords.Count - 1
            
            '全角変換した文字列をもとにベクトル作成
            strWords = dctWords(dctWords.Keys()(lngIndex))
            
            For lngChar = 1 To Len(strWords)
                
                '一文字ずつ取り出す
                strChar = Mid(strWords, lngChar, 1)
                
                'Dictionaryに未格納の文字だったら・・・
                If dctWordToVec.Exists(strChar) = False Then
                    
                    '「文字：インデックス」
                    dctWordToVec.Add strChar, dctWordToVec.Count
                    
                    '「インデックス：文字」
                    dctVecToWord.Add dctVecToWord.Count, strChar
                    
                End If
            Next
        Next
        
        
        '*************************************
        ' 文字列をベクトル化
        '*************************************
        For lngIndex = 0 To dctWords.Count - 1
            
            '※必ず全角変換後文字列を使用する
            strWords = dctWords(dctWords.Keys()(lngIndex))
            
            '「存在する文字数の長さ」の配列になる
            ReDim aryTmp(dctWordToVec.Count - 1) As Variant
            
            '配列をいったん0で初期化
            For lngChar = 0 To UBound(aryTmp)
                aryTmp(lngChar) = 0
            Next
            
            '文字列を一文字ずつ処理
            For lngChar = 1 To Len(strWords)
                
                '対象の一文字
                strChar = Mid(strWords, lngChar, 1)
                
                '「文字；インデックス」変換
                If dctWordToVec.Exists(strChar) Then
                    
                    '配列内の「インデックス位置」に1を設定
                    '※複数同一文字があっても1
                    aryTmp(dctWordToVec(strChar)) = 1
                End If
            Next
            
            '「文字列：ベクトル」Dictionaryに格納
            dctWords(dctWords.Keys()(lngIndex)) = aryTmp
        Next
        
        '3個のDictionaryを返却
        MakeWordVecDict = Array(dctWords, dctWordToVec, dctVecToWord)
        
    End Function
    
    '******************************************************
    ' 文字の一致数・不一致数から「似ている」文字列を検索する
    ' 下記2つのDictionaryが必要
    '******************************************************
    '　■dctWords
    '　　「文字列」「ベクトル」ペアのDictionary
    '　　{"文章" : (1, 1, 0), "文学": (1, 0, 1)}
    '******************************************************
    '　■dctWordToVec
    '　　「文字」「インデックス」ペアのDictionary
    '　　{"文" : 0, "章": 1, "学" : 2}
    '******************************************************
    Function FuzzySearch(ByVal strKeyword As String, ByVal dctWords As Object, ByVal dctWordToVec As Object) As Variant
                
        '検索キーワード用ベクトル
        ReDim aryKeywordVec(dctWordToVec.Count - 1) As Variant
        
        Dim strKeywordWide As String
        Dim lngChar As Long
        Dim strChar As String
        
        '検索キーワードは必ず全角変換
        strKeywordWide = Replace(StrConv(strKeyword, vbWide), "　", "")
        
        '検索キーワード用ベクトルを0で初期化
        For lngChar = 0 To UBound(aryKeywordVec)
            aryKeywordVec(lngChar) = aryKeywordVec(lngChar) + 0
        Next
        
        '検索キーワードをベクトル変換
        '※この際作成済みDictionaryに存在しない文字は無視されます
        '　道の文字に対する対応は検討の余地あり
        For lngChar = 1 To Len(strKeywordWide)
            strChar = Mid(strKeywordWide, lngChar, 1)
            
            '検索キーワード内の文字が既知の文字だったら・・・
            If dctWordToVec.Exists(strChar) Then
                
                'ベクトルの対象インデクス位置をカウントアップ
                '複数同一文字があったらカウントアップ
                aryKeywordVec(dctWordToVec(strChar)) = aryKeywordVec(dctWordToVec(strChar)) + 1
            End If
        Next
            
        Dim lngIndex As Long
        Dim dblDistance As Double
        Dim dblDistanceTmp As Double
        Dim intDiff As Integer
        Dim intSame As Integer
        
        Dim strResultWord As String
        Dim lngResultIndex As Long
        
        '********************************
        ' 「一致」「不一致」計算の定数
        '********************************
        Const dblDiffPenalty As Double = 2  '完全不一致のペナルティ（乗数）
        Const dblSameReward As Double = 0.5 '部分完全一致の報酬（倍）
    
        
        For lngIndex = 0 To dctWords.Count - 1
            
            '偏差の2乗の総和で「不一致」を測定
            intDiff = Application.WorksheetFunction.SumXMY2(aryKeywordVec, dctWords(dctWords.Keys()(lngIndex)))
            
            '一致数をカウント
            intSame = Application.WorksheetFunction.SumProduct(aryKeywordVec, dctWords(dctWords.Keys()(lngIndex)))
            
            '一致数・不一致数から距離を計算する
            '※下記計算のパラメータは検討の余地あり
            If intSame = 0 Then
            
                '完全不一致はペナルティ2乗
                dblDistanceTmp = intDiff ^ dblDiffPenalty
                
            ElseIf InStr(StrConv(dctWords.Keys()(lngIndex), vbWide), strKeywordWide) > 0 Then
                
                '部分完全一致は不一致半分
                dblDistanceTmp = intDiff * dblSameReward / (intSame * 2) ^ 2
            
            Else
                
                '個別文字一致
                dblDistanceTmp = intDiff / (intSame * 2) ^ 2
            
            End If
            
            '最小距離の文字列とインデックスを格納
            If dblDistance = 0 Or dblDistance > dblDistanceTmp Then
                dblDistance = dblDistanceTmp
                strResultWord = dctWords.Keys()(lngIndex)
                lngResultIndex = lngIndex
            End If
        Next
        
        '最小距離の文字列とDictionary内の位置を返却
        FuzzySearch = Array(strResultWord, lngResultIndex)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　数列を生成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function MakePermutation(ByVal intNumberCount As Integer, ByVal intPickupCount As Integer, Optional ByVal aryReplaceNumbers As Variant) As Variant
        
        Dim lngPatternCount As Long
        Dim intCountDown As Integer
        
        lngPatternCount = 1
        For intCountDown = intNumberCount To (intNumberCount - intPickupCount + 1) Step -1
            lngPatternCount = lngPatternCount * intCountDown
        Next
        
        Dim aryNumbers() As Integer
        ReDim aryNumbers(1 To lngPatternCount, 1 To intPickupCount)
        Dim intIndex As Integer
        
        For intIndex = 1 To intPickupCount
            aryNumbers(1, intIndex) = intIndex
        Next
        
        Dim intTargetNumberLow As Integer
        Dim intTargetNumberHigh As Integer
        Dim lngCompleteRowsCount As Long
        Dim lngNowMakigRow As Long
        
        Dim lngRow As Long
        Dim lngColumn As Long
        Dim blnChanged As Boolean
        
        lngCompleteRowsCount = 1
        lngNowMakigRow = 1
        
        For intTargetNumberLow = intNumberCount - 1 To 1 Step -1
            For intTargetNumberHigh = intTargetNumberLow + 1 To intNumberCount
                For lngRow = 1 To lngCompleteRowsCount
                    lngNowMakigRow = lngNowMakigRow + 1
                    blnChanged = False
                    
                    For lngColumn = 1 To intPickupCount
                        
                        If aryNumbers(lngRow, lngColumn) = intTargetNumberLow Then
                            aryNumbers(lngNowMakigRow, lngColumn) = intTargetNumberHigh
                            blnChanged = True
                        ElseIf aryNumbers(lngRow, lngColumn) = intTargetNumberHigh Then
                            aryNumbers(lngNowMakigRow, lngColumn) = intTargetNumberLow
                            blnChanged = True
                        Else
                            aryNumbers(lngNowMakigRow, lngColumn) = aryNumbers(lngRow, lngColumn)
                        End If
                                        
                    Next
                    
                    If blnChanged = False Then
                        lngNowMakigRow = lngNowMakigRow - 1
                    End If
                Next
            Next
            lngCompleteRowsCount = lngNowMakigRow
        Next
        
        If IsMissing(aryReplaceNumbers) = False Then
            Dim dctChangeNumbers As Object
            Set dctChangeNumbers = CreateObject("Scripting.Dictionary")
            
            lngRow = 1
            For intIndex = LBound(aryReplaceNumbers) To UBound(aryReplaceNumbers)
                dctChangeNumbers.Add lngRow, aryReplaceNumbers(intIndex)
                lngRow = lngRow + 1
            Next
            
            For lngRow = LBound(aryNumbers, 1) To UBound(aryNumbers, 1)
                For lngColumn = LBound(aryNumbers, 2) To UBound(aryNumbers, 2)
                    aryNumbers(lngRow, lngColumn) = dctChangeNumbers(aryNumbers(lngRow, lngColumn))
                Next
            Next
        End If
        
        MakePermutation = aryNumbers
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 「共分散行列（セル範囲）」から主成分分析用の固有ベクトル・固有値を算出
'
' 元データから共分散行列の計算⇒固有ベクトル算出⇒主成分出力と
' 一気通貫のほうが良いかなぁ・・・
'
' ※1データでしかテストしていません
' ※固有ベクトル2つしか返却しません
' ※「EXCELマーケティングリサーチ&データ分析」を参考に作成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'セルから受け取る配列を使用するため配列の最小インデックスは「1」
    Const intStartIndex As Integer = 1
    
    'ワークシート関数を想定して「セル範囲」を受け取る
    Function GetEigenVectors(ByVal rngVectorOrigin As Range) As Variant
        
        'セル範囲で受けとった引数を「値」にして配列に格納
        Dim aryVectorOld As Variant
        Dim aryVectorNew As Variant
        aryVectorOld = rngVectorOrigin.Value
        
        '引数から配列サイズを特定
        Dim intInputRowSize As Integer
        Dim intInputColumnSize As Integer
        intInputRowSize = UBound(aryVectorOld, 1)
        intInputColumnSize = UBound(aryVectorOld, 2)
        
        '関数の出力は+2行
        '⇒「固有ベクトル : 空欄 : 固有値」
        Dim intOutputRowSize As Integer
        Dim intOutputColumnSize As Integer
        intOutputRowSize = intInputRowSize + 2
        intOutputColumnSize = 2
        
        '2つ固有ベクトルを返却するための配列
        Dim aryResultVectors As Variant
        ReDim aryResultVectors(intStartIndex To intOutputRowSize, intStartIndex To intOutputColumnSize)
        
        '2つの固有ベクトルを返却
        Dim intLoopCount As Integer
        For intLoopCount = intStartIndex To intOutputColumnSize
            
            Dim vntResults As Variant
            Dim aryVectorPrincipal As Variant
            Dim dblEigenValue As Double
            
            '「固有ベクトル ＋ 固有値」を同時に受け取ってから分割
            vntResults = CalcEigenVectors(aryVectorOld)
            aryVectorPrincipal = vntResults(0)
            dblEigenValue = vntResults(1)
            
            '確定した「固有ベクトル ＋ 固有値」を返却用配列に格納
            Dim intRowIndex As Integer
            For intRowIndex = intStartIndex To intInputRowSize
                aryResultVectors(intRowIndex, intLoopCount) = aryVectorPrincipal(intRowIndex, 1)
            Next
            
            '返却用配列に「固有値」を追加
            '※「固有ベクトル : 空欄 : 固有値」
            aryResultVectors(intOutputRowSize, intLoopCount) = dblEigenValue
            
            '固有値・固有ベクトルが2つ求まれば終了
            If intLoopCount = intOutputColumnSize Then
                Exit For
            End If
                        
            '固有ベクトル * t固有ベクトル
            aryVectorNew = Application.WorksheetFunction.MMult(aryVectorPrincipal, Application.WorksheetFunction.Transpose(aryVectorPrincipal))
            
            '確定した固有ベクトルを使用して「元となる配列」を調整
            Dim intColumnIndex As Integer
            For intColumnIndex = LBound(aryVectorNew, 2) To UBound(aryVectorNew, 2)
                For intRowIndex = LBound(aryVectorNew, 1) To UBound(aryVectorNew, 1)
                    
                    '元の配列 - 固有ベクトル * t固有ベクトル * 固有値
                    aryVectorNew(intRowIndex, intColumnIndex) = aryVectorOld(intRowIndex, intColumnIndex) - (dblEigenValue * aryVectorNew(intRowIndex, intColumnIndex))
                Next
            Next
            
            '値を調整した配列から再度固有ベクトル・固有値を取得
            aryVectorOld = aryVectorNew
        Next
        
        GetEigenVectors = aryResultVectors
        
    End Function
    
    '*****************************************
    '固有ベクトル・固有値を求める単純機能
    '*****************************************
    
    Private Function CalcEigenVectors(ByVal aryVectorOrigin As Variant) As Variant
        
        '引数から配列サイズを特定
        Dim intInputRowSize As Integer
        Dim intInputColumnSize As Integer
        intInputRowSize = UBound(aryVectorOrigin, 1)
        intInputColumnSize = UBound(aryVectorOrigin, 2)
        
        
        '固有ベクトルを求めるための初期値
        Dim aryVectorOne() As Variant
        Dim aryLambda() As Variant
        ReDim aryVectorOne(intStartIndex To intInputRowSize, intStartIndex To intStartIndex)
        ReDim aryLambda(intStartIndex To intInputRowSize, intStartIndex To intStartIndex)
        
        Dim intRowIndex As Integer
        For intRowIndex = intStartIndex To intInputRowSize
            aryVectorOne(intRowIndex, 1) = 1
        Next
                
        Dim aryVectorNew As Variant
        Dim aryVectorOld As Variant
        aryVectorOld = aryVectorOne
        
        Do While True
            
            '固有値計算の反復回数カウント
            '※誤差が指定値以下にならなかったら「回数」管理で終了
            Dim intLoopCount As Integer
            intLoopCount = intLoopCount + 1
            
            '「元となるベクトル」「現在の固有ベクトル候補」から新たなベクトルを計算
            aryVectorNew = Application.WorksheetFunction.MMult(aryVectorOrigin, aryVectorOld)
            
            '新旧「固有ベクトル候補」から「λ」を計算
            For intRowIndex = LBound(aryVectorOrigin, 1) To UBound(aryVectorOrigin, 1)
                aryLambda(intRowIndex, 1) = aryVectorNew(intRowIndex, 1) / aryVectorOld(intRowIndex, 1)
            Next
            
            '全ての「λ」の誤差を計算
            '※極小小数の誤差を無視するためRound使用
            Dim dblDiffrence As Double
            dblDiffrence = 0
            For intRowIndex = LBound(aryVectorOrigin, 1) To UBound(aryVectorOrigin, 1) - 1
                dblDiffrence = dblDiffrence + Abs(Round(aryLambda(intRowIndex, 1), 10) - Round(aryLambda(intRowIndex + 1, 1), 10))
            Next
            
            '「λ」の誤差がない or 指定回数を超えたら 計算終了
            If dblDiffrence = 0 Then
                Exit Do
            ElseIf intLoopCount = 100 Then
                Exit Do
            End If
            
            '更新されたベクトルを「現在の固有ベクトル候補」にして再度計算
            aryVectorOld = aryVectorNew
            
        Loop
        
        '固有値
        Dim dblEigenValue As Double
        dblEigenValue = aryLambda(1, 1)
        
        '「固有ベクトル候補」の2乗和
        '※固有ベクトル調整用の数値
        Dim dblSumSquareRoot As Double
        dblSumSquareRoot = Sqr(Application.WorksheetFunction.SumSq(aryVectorNew))
        
        '固有ベクトルを調整
        For intRowIndex = LBound(aryVectorOrigin, 1) To UBound(aryVectorOrigin, 1)
            aryVectorNew(intRowIndex, 1) = aryVectorNew(intRowIndex, 1) / dblSumSquareRoot
        Next
        
        '「固有ベクトル」「固有値」を返却
        CalcEigenVectors = Array(aryVectorNew, dblEigenValue)
        
    End Function    
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　クラスタリング（K-Means）練習備忘録
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '汎用性はないので要改造！
    Sub Clustering()
        
        Dim aryVectors As Variant
        Dim aryBeforeClustering As Variant
        Dim aryNewClustering As Variant
        Dim aryDistances As Variant
        Dim aryClusterCenterPoints As Variant
        
        aryVectors = Range("B20:C119").Value
        aryBeforeClustering = Range("D20:D119").Value
        aryNewClustering = Range("D20:D119").Value
        aryDistances = Range("E20:H119").Value
        aryClusterCenterPoints = Range("D9:E12").Value
        
        Dim lngRow As Long
        Dim intClusterIndex As Integer
                
        'ラベルをランダムに振り分ける
        For lngRow = LBound(aryBeforeClustering) To UBound(aryBeforeClustering)
            Randomize
            aryBeforeClustering(lngRow, 1) = Application.WorksheetFunction.RandBetween(1, 4)
        Next
                        
        Dim dblDistanceMin As Double
        Dim intChangeCount As Integer
        Dim intMemberCount(1 To 4) As Integer
        Dim intLoopCount As Integer
                
        Do While True
            
            For lngRow = LBound(aryVectors, 1) To UBound(aryVectors, 1)
                dblDistanceMin = Abs(aryVectors(lngRow, 1)) + Abs(aryVectors(lngRow, 2))
                For intClusterIndex = 1 To 4
                    aryDistances(lngRow, intClusterIndex) = GetDistance( _
                                                        Array(aryVectors(lngRow, 1), aryVectors(lngRow, 2)), _
                                                        Array(aryClusterCenterPoints(intClusterIndex, 1), aryClusterCenterPoints(intClusterIndex, 2)))
                    
                    If dblDistanceMin > aryDistances(lngRow, intClusterIndex) Then
                        dblDistanceMin = aryDistances(lngRow, intClusterIndex)
                        aryNewClustering(lngRow, 1) = intClusterIndex
                    End If
                    
                Next
            Next
            
            For intClusterIndex = LBound(aryClusterCenterPoints, 1) To UBound(aryClusterCenterPoints, 1)
                aryClusterCenterPoints(intClusterIndex, 1) = 0
                aryClusterCenterPoints(intClusterIndex, 2) = 0
                intMemberCount(intClusterIndex) = 1
            Next
            
            For lngRow = LBound(aryVectors, 1) To UBound(aryVectors, 1)
                intClusterIndex = aryNewClustering(lngRow, 1)
                aryClusterCenterPoints(intClusterIndex, 1) = aryClusterCenterPoints(intClusterIndex, 1) + aryVectors(lngRow, 1)
                aryClusterCenterPoints(intClusterIndex, 2) = aryClusterCenterPoints(intClusterIndex, 2) + aryVectors(lngRow, 2)
                intMemberCount(intClusterIndex) = intMemberCount(intClusterIndex) + 1
            Next
            
            For intClusterIndex = LBound(aryClusterCenterPoints, 1) To UBound(aryClusterCenterPoints, 1)
                On Error Resume Next
                aryClusterCenterPoints(intClusterIndex, 1) = aryClusterCenterPoints(intClusterIndex, 1) / intMemberCount(intClusterIndex)
                aryClusterCenterPoints(intClusterIndex, 2) = aryClusterCenterPoints(intClusterIndex, 2) / intMemberCount(intClusterIndex)
                On Error GoTo 0
            Next
            
            For lngRow = LBound(aryVectors, 1) To UBound(aryVectors, 1)
                If aryBeforeClustering(lngRow, 1) <> aryNewClustering(lngRow, 1) Then
                    intChangeCount = intChangeCount + 1
                    aryBeforeClustering(lngRow, 1) = aryNewClustering(lngRow, 1)
                End If
            Next
            
            intLoopCount = intLoopCount + 1
            
            If intLoopCount = 1000 Or intChangeCount = 0 Then
                Debug.Print intLoopCount, intChangeCount
                Exit Do
            End If
            
            intChangeCount = 0
        Loop
        
        Range("D20:D119").Value = aryNewClustering
        Range("E20:H119").Value = aryDistances
        Range("D9:E12").Value = aryClusterCenterPoints
        
        MsgBox "FINISHED!"
        
    End Sub
    
    
    'ユークリッド距離
    Function GetDistance(ByVal aryData As Variant, ByVal aryCluster As Variant) As Double
        
        Dim dblAnswer As Double
        Dim intIndex As Integer
        
        dblAnswer = 0
        
        For intIndex = LBound(aryData) To UBound(aryData)
            
            dblAnswer = dblAnswer + (aryData(intIndex) - aryCluster(intIndex)) ^ 2
            
        Next
        
        GetDistance = Sqr(dblAnswer)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　マクロ高速化クラス（画面描画・再計算・警告表示停止・復旧）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*************************************************
    ' インスタンス作成時点で画面処理等を停止する
    '*************************************************
    Private Sub Class_Initialize()
        
        With Application
            .ScreenUpdating = False
            .Calculation = xlManual
            .DisplayAlerts = False
            .EnableEvents = True
        End With
        
    End Sub
    
    '*************************************************
    ' インスタンスが破棄されたら自動でデフォルトに復旧
    '*************************************************
    Private Sub Class_Terminate()
        
        With Application
            .ScreenUpdating = True
            .Calculation = xlAutomatic
            .DisplayAlerts = True
            .EnableEvents = True
            .StatusBar = False
        End With
    
    End Sub
    
    '*************************************************
    ' 設定を個別に指定できる
    '*************************************************
    Sub Setting(Optional ByVal intUpdating As Integer = False, Optional ByVal intCalc As Integer = xlManual, _
            Optional ByVal intAlert As Integer = False, Optional ByVal intEvent As Integer = True)
        
        Application.ScreenUpdating = intUpdating
        Application.Calculation = intCalc
        Application.DisplayAlerts = intAlert
        Application.EnableEvents = intEvent
        
    End Sub
    
    '*************************************************
    ' ステータスバーへの進捗・メッセージ表示
    '*************************************************
    Sub StatusBar(Optional ByVal strStatusBar As String = "False")
        
        If strStatusBar <> "False" Then
            Application.StatusBar = strStatusBar
        Else
            Application.StatusBar = False
        End If
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' 標準Module
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
' 
' NeuralNetworkクラス使用例（多値分類未対応）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'Dataシートイメージ
    'ID |  x1  |  x2  | tflag | pred |
    ' 1 |  0.1 |  0.5 |   1   |  0.6 |
    ' 2 |  0.9 |  0.3 |   0   |  0.3 |
    
    Sub NeuralNetworkTest()
        
        '実行時間計測
        Dim dteStart As Date
        dteStart = Now
        
        'NueralNetworkクラス
        Dim clsNN As ClassNeuralNetwork
        Set clsNN = New ClassNeuralNetwork
        
        'NueralNetwork設計
        '入力   　：x1 x2（2値の縦ベクトル）
        '出力   　：1 　 （2種類分類）
        'Layer数　：4層　（出力層含む）
        'Units  　：層のユニット数（最終層は出力数に依存）
        '学習率 　：
        Call clsNN.Init(2, 1, 4, 10, 0.001)
        
        'NueralNetworkに渡すx（縦ベクトル）
        Dim x(1 To 2, 1 To 1) As Double
        
        '教師データの成否
        Dim intTeacher As Integer
        
        Dim wsData as Worksheet
        set wsData = Thisworkbook.Worksheets("data")
        Dim intLoopCount As Integer
        Dim lngRow As Long
        
        
        '********************************************
        ' 学習ループ
        '********************************************
        For intLoopCount = 1 To 10  'エポック回数
            For lngRow = 2 To 101   '教師データ数
                
                'x1, x2 を縦ベクトル格納（Transeposeでも良いかも？）
                x(1, 1) = wsData.Cells(lngRow, "B").Value
                x(2, 1) = wsData.Cells(lngRow, "C").Value
                
                '成否（教師データ）
                '※多値分類未対応
                intTeacher = wsData.Cells(lngRow, "D").Value
                
                '学習
                Call clsNN.Train(x, intTeacher)
            Next
        Next
        
        '********************************************
        ' 予測
        '********************************************
        For lngRow = 2 To 201
            
            'x1, x2 を縦ベクトル格納（Transeposeでも良いかも？）
            x(1, 1) = wsData.Cells(lngRow, "B").Value
            x(2, 1) = wsData.Cells(lngRow, "C").Value
            
            '予測
            wsData.Cells(lngRow, "E").Value = clsNN.Predict(x)
        Next
        
        MsgBox "実行時間：" & Format(Now - dteStart, "hh:mm:ss")
        
    End Sub
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassNeuralNetwork（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
    
Option Explicit
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'クラス内ので管理するLayerの設定等
    Dim intInputCount As Integer
    Dim intOutputCount As Integer
    Dim intLayerCount As Integer
    Dim intUnitCount As Integer
    Dim dblLR As Double
    
    'クラス内でLayer・学習・予測を管理する
    Dim aryNetworks() As Variant
    Dim intT As Integer
    Dim dblE As Double
    Dim dblZ() As Double
    Dim dblZ_B() As Double
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラスの初期設定・Layerの管理を代行
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Sub Init(ByVal intInput As Integer, ByVal intOutput As Integer, ByVal intLayer As Integer, ByVal intUnits As Integer, ByVal dblLearningRate As Double)
        
        
        ReDim dblZ(1 To intOutput, 1 To 1) As Double
        ReDim dblZ_B(1 To intOutput, 1 To 1) As Double
        
        intInputCount = intInput
        intOutputCount = intOutput
        intLayerCount = intLayer
        intUnitCount = intUnits
        dblLR = dblLearningRate
        
        ReDim aryNetworks(1 To intLayerCount)
        
        Dim intLayerIndex As Integer
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            
            Set aryNetworks(intLayerIndex) = New ClassLayer
            
            If intLayerIndex = LBound(aryNetworks) Then
                Call aryNetworks(intLayerIndex).Init(intInputCount, intUnitCount, "ReLU", dblLearningRate, intLayerIndex)
            ElseIf intLayerIndex <> UBound(aryNetworks) Then
                Call aryNetworks(intLayerIndex).Init(intUnitCount, intUnitCount, "ReLU", dblLearningRate, intLayerIndex)
            Else
                Call aryNetworks(intLayerIndex).Init(intUnitCount, intOutputCount, "Sigmoid", dblLearningRate, intLayerIndex)
            End If
            
        Next
        
    End Sub
    
    '********************************************
    ' 「wx+b=y」の計算を実行
    '********************************************
    
    Public Sub Train(ByVal vntX As Variant, ByVal intTeach As Integer)
        
        Dim intLayerIndex As Integer
        Dim vntZ As Variant
        
        intT = intTeach
        vntZ = vntX
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            Call aryNetworks(intLayerIndex).Foward(vntZ, vntZ)
        Next
        
        dblZ(1, 1) = vntZ(1, 1)
        
        If dblZ(1, 1) <> 0 And dblZ(1, 1) <> 1 Then
            
            Call CrossEntropyLoss
            Call CrossEntropyLossBack
            
            Dim vntZ_B As Variant
            vntZ_B = dblZ_B
            
            For intLayerIndex = UBound(aryNetworks) To LBound(aryNetworks) Step -1
                Call aryNetworks(intLayerIndex).Backward(vntZ_B, vntZ_B)
            Next
        Else
            Debug.Print "error"
        End If
        
    End Sub
    
    
    Private Sub CrossEntropyLoss()
        If intT = 1 Then
            dblE = (-intT) * Log(dblZ(1, 1))
        Else
            dblE = -(1 - intT) * Log(1 - dblZ(1, 1))
        End If
    End Sub
    
    Private Sub CrossEntropyLossBack()
        On Error Resume Next
        dblZ_B(1, 1) = (-intT / dblZ(1, 1)) + ((1 - intT) / (1 - dblZ(1, 1)))
        If Err.Number <> 0 Then
            dblZ_B(1, 1) = 0
        End If
        On Error GoTo 0
    End Sub
    
    Public Function Predict(ByVal vntX As Variant) As Double
        
        Dim intLayerIndex As Integer
        Dim vntZ As Variant
        
        vntZ = vntX
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            Call aryNetworks(intLayerIndex).Foward(vntZ, vntZ)
        Next
        
        Predict = vntZ(1, 1)
        
    End Function
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassLayer（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
    
Option Explicit
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'Layer設計のプロパティ
    '内部で保持する配列のサイズなどをダイナミックに作成
    Dim intXRowsCount As Integer
    Dim intXColumnsCount As Integer
    Dim intWRowsCount As Integer
    Dim intWColumnsCount As Integer
    
    'アクティベート関数の選択
    Dim blnReLU As Boolean
    Dim blnSigmoid As Boolean
    
    '学習・予想の計算時に使用するパラメータ
    Dim dblX() As Double
    Dim dblW() As Double
    Dim dblB() As Double
    Dim dblY() As Double
    Dim dblZ() As Double
    
    '誤差逆伝播計算に使用
    '計算完了後「_Bなし」の変数を更新する
    '※逆伝播は値の保存必要ないかも？
    Dim dblX_B() As Double
    Dim dblW_B() As Double
    Dim dblB_B() As Double
    Dim dblY_B() As Double
    Dim dblZ_B() As Double
    
    '学習率を保持
    Dim dblLR As Double
    
    'パラメータを出力できるようにするなど、
    '拡張性のためLayerに名前を保持する
    Dim strLayerName As String
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Layerの初期設定
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Sub Init(ByVal intInput As Integer, ByVal intOutput As Integer, ByVal strActivateFucntion As String, ByVal dblLearningRate As Double, ByVal intLayerNumber As Integer)
        
        '入力データの体裁
        intXRowsCount = intInput
        intXColumnsCount = 1
        
        'Wパラメータの体裁
        intWRowsCount = intOutput
        intWColumnsCount = intInput
        
        'アクティベート関数の選択
        If strActivateFucntion = "ReLU" Then
            blnReLU = True
        ElseIf strActivateFucntion = "Sigmoid" Then
            blnSigmoid = True
        End If
        
        '学習率の保持
        dblLR = dblLearningRate
        
        strLayerName = "Layer" & intLayerNumber
        
        '入出力の体裁によって、配列のサイズを決定
        ReDim dblX(1 To intXRowsCount, 1 To intXColumnsCount) As Double
        ReDim dblW(1 To intWRowsCount, 1 To intWColumnsCount) As Double
        ReDim dblB(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblY(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblZ(1 To intWRowsCount, 1 To 1) As Double
        
        '誤差逆伝播計算用配列は「_Bなし」と同じサイズ
        ReDim dblX_B(1 To intXRowsCount, 1 To intXColumnsCount) As Double
        ReDim dblW_B(1 To intWRowsCount, 1 To intWColumnsCount) As Double
        ReDim dblB_B(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblY_B(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblZ_B(1 To intWRowsCount, 1 To 1) As Double
        
        Dim lngRow As Long
        Dim lngColum As Long
        
        'Wをランダム（正規分布）な数値で埋める
        For lngRow = LBound(dblW, 1) To UBound(dblW, 1)
            For lngColum = LBound(dblW, 2) To UBound(dblW, 2)
                Randomize
                dblW(lngRow, lngColum) = Application.WorksheetFunction.Norm_Inv(Rnd(), 0, 1)
            Next
        Next
        
        'Bをランダム（正規分布）な数値で埋める
        For lngRow = LBound(dblB, 1) To UBound(dblB, 1)
            For lngColum = LBound(dblB, 2) To UBound(dblB, 2)
                Randomize
                dblB(lngRow, lngColum) = Application.WorksheetFunction.Norm_Inv(Rnd(), 0, 1)
            Next
        Next
        
    End Sub
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 学習の前進計算 ＆ 予測時に使用する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Foward(ByVal vntX As Variant, ByRef vntZ As Variant) As Double()
        Call CopyArray(vntX, dblX)
        Call CalcWXB
        Call ActivateFunction
        Call CopyArray(dblZ, vntZ)
        Foward = dblZ
    End Function
    
    '********************************************
    ' 「wx+b=y」の計算を実行
    '********************************************
    Private Sub CalcWXB()
        
        Dim vntWX As Variant
        vntWX = Application.WorksheetFunction.MMult(dblW, dblX)
        
        Dim lngRow As Long
        For lngRow = 1 To UBound(vntWX, 1)
            On Error Resume Next
            dblY(lngRow, 1) = vntWX(lngRow, 1) + dblB(lngRow, 1)
            If Err.Number <> 0 Then
                dblY(lngRow, 1) = vntWX(lngRow) + dblB(lngRow, 1)
            End If
            On Error GoTo 0
        Next
                
    End Sub
    
    '********************************************
    ' 「activate(y)=z」の計算を実行
    '********************************************
    Private Sub ActivateFunction()
        
        Dim lngRow As Long
        
        'ReLU関数によるActivate
        If blnReLU = True Then
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = Application.WorksheetFunction.Max(0, dblY(lngRow, 1))
            Next
        
        'Sigmoid関数によるActivate
        ElseIf blnSigmoid = True Then
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = 1 / (1 + Exp(-dblY(lngRow, 1)))
            Next
        End If
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 誤差逆伝播計算によるパラーメータの更新
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Backward(ByVal vntZ As Variant, ByRef vntX As Variant) As Double()
        Call CopyArray(vntZ, dblZ_B)
        Call ActivateFunctionBack
        Call CalcWXB_XBack
        Call CalcWXB_WBack
        Call CalcWXB_BBack
        Call CopyArray(dblX_B, vntX)
        Call UpdateParams
        Backward = dblX_B
    End Function
    
    '********************************************
    ' 「activate(y)」の微分計算を実行
    '********************************************
    Sub ActivateFunctionBack()
        
        Dim lngRow As Long
        
        'ReLU関数の逆伝播
        If blnReLU = True Then
            For lngRow = 1 To UBound(dblY, 1)
                If dblY(lngRow, 1) >= 0 Then
                    dblY_B(lngRow, 1) = dblZ_B(lngRow, 1)
                Else
                    dblY_B(lngRow, 1) = 0
                End If
            Next
        
        'Sigmoid関数の逆伝播
        ElseIf blnSigmoid = True Then
            For lngRow = 1 To UBound(dblY_B, 1)
                dblY_B(lngRow, 1) = dblZ_B(lngRow, 1) * (dblZ(lngRow, 1) * (1 - dblZ(lngRow, 1)))
            Next
        End If
    End Sub
    
    '********************************************
    ' 「wx+b⇒xの微分⇒w」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_XBack()
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '「w ＆ 逆伝播の積和（加算の反復）」を計算するため一度過去データを消去
        For lngRow = LBound(dblX_B, 1) To UBound(dblX_B, 1)
            dblX_B(lngRow, 1) = 0
        Next
        
        '「w ＆ 逆伝播」の積和（加算の反復）
        For lngRow = LBound(dblW, 1) To UBound(dblW, 1)
            For lngColumn = LBound(dblW, 2) To UBound(dblW, 2)
                dblX_B(lngColumn, 1) = dblX_B(lngColumn, 1) + dblW(lngRow, lngColumn) * dblY_B(lngRow, 1)
            Next
        Next
    End Sub
    
    '********************************************
    ' 「wx+b⇒wの微分⇒x」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_WBack()
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '「x ＆ 逆伝播」の積和
        For lngRow = LBound(dblW_B, 1) To UBound(dblW_B, 1)
            For lngColumn = LBound(dblW_B, 2) To UBound(dblW_B, 2)
                dblW_B(lngRow, lngColumn) = dblX(lngColumn, 1) * dblY_B(lngRow, 1)
            Next
        Next
    End Sub
    
    '********************************************
    ' 「wx+b⇒bの微分⇒1」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_BBack()
        Call CopyArray(dblY_B, dblB_B)
    End Sub
    
    '********************************************
    ' パラメータの更新
    ' 「新パラメータ = 旧パラメータ - 学習率 * 各パラメータの逆伝播値」
    '********************************************
    Private Sub UpdateParams()
        Dim lngRow As Long
        Dim lngColumn As Long
        
        'w = w - LearningRate * w_b
        For lngRow = LBound(dblW_B, 1) To UBound(dblW_B, 1)
            For lngColumn = LBound(dblW_B, 2) To UBound(dblW_B, 2)
                dblW(lngRow, lngColumn) = dblW(lngRow, lngColumn) - dblW_B(lngRow, lngColumn) * dblLR
            Next
        Next
        
        'b = b - LearningRate * b_b
        For lngRow = LBound(dblB_B, 1) To UBound(dblB_B, 1)
            For lngColumn = LBound(dblB_B, 2) To UBound(dblB_B, 2)
                dblB(lngRow, lngColumn) = dblB(lngRow, lngColumn) - dblB_B(lngRow, lngColumn) * dblLR
            Next
        Next
            
    End Sub
    
    '********************************************
    ' 配列のコピー関数※２元配列限定
    '********************************************
    Private Sub CopyArray(ByVal vntFrom As Variant, ByRef vntTo As Variant)
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '配列の形を一致させる
        ReDim vntTo(LBound(vntFrom, 1) To UBound(vntFrom, 1), LBound(vntFrom, 2) To UBound(vntFrom, 2))
        
        '値をコピー
        For lngRow = 1 To UBound(vntFrom, 1)
            For lngColumn = 1 To UBound(vntFrom, 2)
                vntTo(lngRow, lngColumn) = vntFrom(lngRow, lngColumn)
            Next
        Next
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' 標準モジュール
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ConvolutionNeuralNetwork（予測に失敗・・・勉強中。）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
        
    Sub CNN_TEST()
        
        Dim wsTrain As Worksheet
        Set wsTrain = ThisWorkbook.Worksheets("data_train")
        
        Dim intTeacher() As Integer
        Dim dblImage() As Double
        
        
        '********************************************
        ' CNN　学習率0.0001
        ' Convolution intpu:1 output:4
        ' Maxpooling
        ' Convolution intpu:4 output:4
        ' Maxpooling
        ' Flatten
        ' Dense（ReLU）param:100
        ' Dense（ReLU）param:100
        ' Dense（SoftMax）output:10
        '********************************************
        Dim clsCNN As ClassCNN
        Set clsCNN = New ClassCNN
        Call clsCNN.Init(1, 2, 3, 4, 100, 10, 3, 0.0001)
        
        Dim lngRow As Long
        Dim lngEpoch As Long
        
        '学習
        For lngEpoch = 1 To 2
            For lngRow = 2 To 1001
                
                'エクセルシート上の行に変換した画像データを行列化
                ReDim intTeacher(1 To 10, 1 To 1)
                intTeacher(wsTrain.Range("B" & lngRow).Value + 1, 1) = 1
                Call FlatToSquare(wsTrain.Range("C" & lngRow & ":GP" & lngRow), dblImage)
                
                '学習
                Call clsCNN.Train(dblImage, intTeacher)
            Next
        Next
        
        Dim intGood As Integer
        Dim intBad As Integer
        
        For lngRow = 1002 To 2002
                        
            '予測と正解を表示
            Call FlatToSquare(wsTrain.Range("C" & lngRow & ":GP" & lngRow), dblImage)
            Debug.Print clsCNN.Predict(dblImage), wsTrain.Range("B" & lngRow).Value
            
            '成否を数える
            If clsCNN.Predict(dblImage) = wsTrain.Range("B" & lngRow).Value Then
                intGood = intGood + 1
            Else
                intBad = intBad + 1
            End If
        Next
        
        '成否の結果（最大15％程度・・・）
        Debug.Print intGood, intBad
        
        End Sub
    
        
    '********************************************
    ' 行に変換した画像を行列に復元※正方形限定
    '********************************************
        Function FlatToSquare(ByVal rngRow As Range, ByRef dblImage() As Double) As Double()
        
        Dim lngArrayRow As Long
        Dim lngArrayColumn As Long
        
        ReDim dblImage(1 To 1, 1 To Sqr(rngRow.Columns.Count), 1 To Sqr(rngRow.Columns.Count))
        
        Dim lngIndex As Long
        
        For lngArrayRow = 1 To Sqr(rngRow.Columns.Count)
            For lngArrayColumn = 1 To Sqr(rngRow.Columns.Count)
                lngIndex = lngIndex + 1
                dblImage(1, lngArrayRow, lngArrayColumn) = rngRow.Cells(1, lngIndex) / 255
            Next
        Next
        
        End Function
    
    '********************************************
    ' 配列のコピー関数（Double限定）
    '********************************************
    Sub CopyArray(ByRef dblFrom() As Double, ByRef dblTo() As Double)
        
        Dim intDummy As Integer
        Dim intDimensionCheck As Integer
        
        On Error Resume Next
        Do While True
            intDimensionCheck = intDimensionCheck + 1
            intDummy = UBound(dblFrom(), intDimensionCheck)
            If Err.Number <> 0 Then
                Exit Do
            End If
        Loop
        On Error GoTo 0
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        Dim intLayerDimension
        Dim intRowDimension
        Dim intColumnDimension
        
        '1次元配列（行配列）
        If intDimensionCheck = 2 Then
        
            '配列の形を一致させる
            intColumnDimension = 1
            ReDim dblTo(LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension))
            
            '値をコピー
            For intColumn = LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension)
                dblTo(intColumn) = dblFrom(intColumn)
            Next
            
        '2次元配列（行列配列）
        ElseIf intDimensionCheck = 3 Then
        
            '配列の形を一致させる
            intRowDimension = 1
            intColumnDimension = 2
            ReDim dblTo(LBound(dblFrom, intRowDimension) To UBound(dblFrom, intRowDimension), _
                        LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension))
            
            '値をコピー
            For intRow = LBound(dblFrom, intRowDimension) To UBound(dblFrom, intRowDimension)
                For intColumn = LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension)
                    dblTo(intRow, intColumn) = dblFrom(intRow, intColumn)
                Next
            Next
        
        '3次元配列（層行列配列）
        ElseIf intDimensionCheck = 4 Then
                        
            '配列の形を一致させる
            intLayerDimension = 1
            intRowDimension = 2
            intColumnDimension = 3
            ReDim dblTo(LBound(dblFrom, intLayerDimension) To UBound(dblFrom, intLayerDimension), _
                        LBound(dblFrom, intRowDimension) To UBound(dblFrom, intRowDimension), _
                        LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension))
            
            '値をコピー
            For intLayer = LBound(dblFrom, intLayerDimension) To UBound(dblFrom, intLayerDimension)
                For intRow = LBound(dblFrom, intRowDimension) To UBound(dblFrom, intRowDimension)
                    For intColumn = LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension)
                        dblTo(intLayer, intRow, intColumn) = dblFrom(intLayer, intRow, intColumn)
                    Next
                Next
            Next
        End If
        
    End Sub

    '********************************************
    ' 行列積（Double限定）
    '********************************************
    Function Dot(ByRef dblW() As Double, ByRef dblX() As Double) As Variant
        
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
        
        Dim dblWX() As Double
        ReDim dblWX(1 To UBound(dblW, 1), 1 To 1)
        
        For intArrayRow = LBound(dblW, 1) To UBound(dblW, 1)
            For intArrayColumn = LBound(dblW, 2) To UBound(dblW, 2)
                
                dblWX(intArrayRow, 1) = dblWX(intArrayRow, 1) + _
                    dblW(intArrayRow, intArrayColumn) * dblX(intArrayColumn, 1)
                
            Next
        Next
        
        Dot = dblWX
        
    End Function
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassCNN（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'クラス内ので管理するLayerの設定等
    Dim intInputCount As Integer
    Dim intOutputCount As Integer
    Dim intLayerCount As Integer
    Dim intUnitCount As Integer
    Dim dblLR As Double
    
    'クラス内でLayer・学習・予測を管理する
    Dim aryNetworks() As Variant
    Dim intT() As Integer
    Dim dblE As Double
    Dim dblZ() As Double
    Dim dblZ_B() As Double
    Dim dblP() As Double
    
    Dim clsConvolution() As ClassConvolution
    Dim clsFlatten As ClassFlatten
    Dim clsDense() As ClassLayer
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラスの初期設定・Layerの管理を代行
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Init(ByVal intInputLayerCount As Integer, ByVal intConvolutionLayerCount As Integer, ByVal intDenseLayerCount As Integer, _
                ByVal intConvolutionOutputCount As Integer, intDenseParamCount As Integer, ByVal intOutputCount As Integer, _
                ByVal intKernelSize As Integer, ByVal dblLearningRate As Double)
        
        ReDim clsConvolution(1 To intConvolutionLayerCount)
        ReDim clsDense(1 To intDenseLayerCount)
        
        Dim intIndex As Integer
        
        For intIndex = 1 To intConvolutionLayerCount
            Set clsConvolution(intIndex) = New ClassConvolution
            
            If intIndex = 1 Then
                Call clsConvolution(intIndex).Init(intInputLayerCount, intConvolutionOutputCount, intKernelSize, dblLearningRate)
            Else
                Call clsConvolution(intIndex).Init(intConvolutionOutputCount, intConvolutionOutputCount, intKernelSize, dblLearningRate)
            End If
        Next
        
        Set clsFlatten = New ClassFlatten
        
        For intIndex = 1 To intDenseLayerCount
            Set clsDense(intIndex) = New ClassLayer
            
            If intIndex = 1 Then
                Call clsDense(intIndex).Init(16, intDenseParamCount, "ReLU", dblLearningRate, intIndex)
            ElseIf intIndex = intDenseLayerCount Then
                Call clsDense(intIndex).Init(intDenseParamCount, intOutputCount, "SoftMax", dblLearningRate, intIndex)
            Else
                Call clsDense(intIndex).Init(intDenseParamCount, intDenseParamCount, "ReLU", dblLearningRate, intIndex)
            End If
        Next
        
        ReDim intT(1 To intOutputCount, 1 To 1)
        
    End Sub

'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 学習・予測に使用する陣伝播計算
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Train(ByRef dblX() As Double, ByRef intTeacher() As Integer)
        
        Call CopyArray(dblX, dblZ)
        Dim intIndex As Integer
        
        '教師データをコピー
        For intIndex = LBound(intTeacher) To UBound(intTeacher)
            intT(intIndex, 1) = intTeacher(intIndex, 1)
        Next
        
        'Convolution層の順伝播
        For intIndex = 1 To UBound(clsConvolution)
            Call clsConvolution(intIndex).Forward(dblZ, dblZ)
        Next
        
        '平面化（縦ベクトル）
        Call clsFlatten.Flatten(dblZ, dblZ)
        
        '全結合層の順伝播
        For intIndex = 1 To UBound(clsDense)
            Call clsDense(intIndex).Forward(dblZ, dblZ)
        Next
        
        '目的関数
        Call CalcError
        
        '全結合層の逆伝播
        For intIndex = UBound(clsDense) To 1 Step -1
            Call clsDense(intIndex).Backward(dblZ_B, dblZ_B)
        Next
        
        '平面の行列化（正方形）
        Call clsFlatten.FlattenBack(dblZ_B, dblZ_B)
        
        'Convolution層の逆伝播
        For intIndex = UBound(clsConvolution) To 1 Step -1
            Call clsConvolution(intIndex).Backward(dblZ_B, dblZ_B)
        Next
        
    End Sub
    
    '目的関数＆逆伝播初期数値生成
    Private Function CalcError() As Double
        
        ReDim dblZ_B(LBound(dblZ) To UBound(dblZ), 1 To 1)
        
        Dim dblError As Double
        Dim intArrayRow As Integer
        
        For intArrayRow = LBound(dblZ) To UBound(dblZ)
            
            dblError = dblError - intT(intArrayRow, 1) * Log(dblZ(intArrayRow, 1))
            dblZ_B(intArrayRow, 1) = dblZ(intArrayRow, 1) - intT(intArrayRow, 1)
            
        Next
        
        '誤差表示
        DoEvents
        Debug.Print dblError
        DoEvents
        
        CalcError = dblError
        
    End Function
    
    '予想
    Function Predict(ByRef dblX() As Double) As Integer
        
        Call CopyArray(dblX, dblP)
        
        Dim intIndex As Integer
        
        'Convolution層の順伝播
        For intIndex = 1 To UBound(clsConvolution)
            Call clsConvolution(intIndex).Forward(dblP, dblP)
        Next
        
        '平面化（縦ベクトル）
        Call clsFlatten.Flatten(dblP, dblP)
        
        '全結合層の順伝播
        For intIndex = 1 To UBound(clsDense)
            Call clsDense(intIndex).Forward(dblP, dblP)
        Next
        
        '出力された配列の最大値のインデックスが予測値
        Predict = Application.WorksheetFunction.Match(Application.WorksheetFunction.Max(dblP), dblP, False) - 1
        
    End Function
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassConvolution（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '1色画像処理のため3次元配列
    Const intLayerDimension As Integer = 1
    Const intRowDimension As Integer = 2
    Const intColumnDimension As Integer = 3
    
    'カーネルは別Layerのデータを受け取るため、4次元配列
    Const intKernelLayerDimension As Integer = 1    '自分自身の層番号
    Const intKernelGroupDimension As Integer = 2    'データを受け取る相手の層番号
    Const intKernelRowDimension As Integer = 3
    Const intKernelColumnDimension As Integer = 4
    
    '逆伝播カーネルは上下左右反転させる
    Dim dblKernel() As Double
    Dim dblkernelReverse() As Double
    
    '順伝播情報を保持する
    Dim dblInput() As Double
    Dim dblConvolution() As Double
    Dim dblActivate() As Double
    Dim dblOutput() As Double
    Dim dblW() As Double
    
    '逆伝播情報を保持する
    Dim dblInput_B() As Double
    Dim dblConvolution_B() As Double
    Dim dblConvolution_B_Margin() As Double
    Dim dblActivate_B() As Double
    Dim dblOutput_B() As Double
    Dim dblKernel_B() As Double
    Dim dblW_B() As Double
    
    'ユニットの設定
    Dim intInputSize As Integer
    Dim intOutputSize As Integer
    Dim intKernelSize As Integer
    Dim intMarginSize As Integer
    
    '学習率を保持
    Dim dblLR As Double
        
    'パラメータを出力できるようにするなど、
    '拡張性のためLayerに名前を保持する
    Dim strLayerName As String
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Layerの初期設定
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Init(ByVal intInputLayerSize As Integer, ByVal intOutputLayerSize As Integer, ByVal intMakeKernelSize As Integer, ByVal dblLearningRate As Double)
        intInputSize = intInputLayerSize
        intOutputSize = intOutputLayerSize
        intKernelSize = intMakeKernelSize
        intMarginSize = intKernelSize - 1
        dblLR = dblLearningRate
        Call MakeWeight
        Call MakeKernel
    End Sub
    
    '********************************************
    ' ウェイトの生成
    '********************************************
    Private Sub MakeWeight()
        
        ReDim dblW(1 To intOutputSize, 1 To 1)
        Dim lngArrayRow As Long
        For lngArrayRow = 1 To intOutputSize
            Randomize
            dblW(lngArrayRow, 1) = Application.WorksheetFunction.NormInv(Rnd(), 0, 1)
        Next
    End Sub
    
        
    '********************************************
    ' カーネルの生成
    '********************************************
    Private Sub MakeKernel()
        
        ReDim dblKernel(1 To intOutputSize, 1 To intInputSize, 1 To intKernelSize, 1 To intKernelSize)
        ReDim dblkernelReverse(1 To intOutputSize, 1 To intInputSize, 1 To intKernelSize, 1 To intKernelSize)
        
        Dim intKernelCount As Integer
        Dim intArrayLayer As Integer
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
        Dim dblRandom As Double
                
        '出力数と同数必要
        For intArrayLayer = 1 To intOutputSize
            
            '入力数と同数必要
            For intKernelCount = 1 To intInputSize
                
                'カーネル正方形のサイズ
                For intArrayRow = 1 To intKernelSize
                    For intArrayColumn = 1 To intKernelSize
                        
                        '上下左右反転カーネルも生成
                        Randomize
                        dblRandom = Application.WorksheetFunction.NormInv(Rnd(), 0, 1)
                        dblKernel(intArrayLayer, intKernelCount, intArrayRow, intArrayColumn) = dblRandom
                        dblkernelReverse(intArrayLayer, intKernelCount, intKernelSize - intArrayRow + 1, intKernelSize - intArrayColumn + 1) = dblRandom
                    Next
                Next
            Next
        Next
        
    End Sub
    

    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 学習の前進計算 ＆ 予測時に使用する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Forward(ByRef dblInputArray() As Double, ByRef dblOutputArray() As Double)
        
        Call CopyArray(dblInputArray, dblInput)
        Call Convolution
        Call ActivateFunction
        Call MaxPooling
        Call CopyArray(dblOutput, dblOutputArray)
        
    End Sub
    
    '********************************************
    ' コンボリューション
    '********************************************
    Private Sub Convolution()
        
        ReDim dblConvolution( _
            1 To intOutputSize, _
            LBound(dblInput, intRowDimension) To UBound(dblInput, intRowDimension) - intKernelSize + 1, _
            LBound(dblInput, intColumnDimension) To UBound(dblInput, intColumnDimension) - intKernelSize + 1)
        
        Dim intOutputLayer As Integer
        Dim intOutputRow As Integer
        Dim intOutputColumn As Integer
        
        Dim intInputLayer As Integer
        
        Dim intKernelLayer As Integer
        Dim intKernelGroup As Integer
        Dim intKernelRow As Integer
        Dim intKernelColumn As Integer
        
        Dim intAddRow As Integer
        Dim intAddColumn As Integer
        
        '計算結果を集約する配列の「層行列」
        For intOutputLayer = LBound(dblConvolution, intLayerDimension) To UBound(dblConvolution, intLayerDimension)
            For intOutputRow = LBound(dblConvolution, intRowDimension) To UBound(dblConvolution, intRowDimension)
                For intOutputColumn = LBound(dblConvolution, intColumnDimension) To UBound(dblConvolution, intColumnDimension)
                    
                    'ウェイトは単純加算
                    dblConvolution(intOutputLayer, intOutputRow, intOutputColumn) = dblW(intOutputLayer, 1)
                    
                    '別レイヤーのインプットを受け取り集計
                    For intInputLayer = LBound(dblInput, intLayerDimension) To UBound(dblInput, intLayerDimension)
                        
                        'カーネルを使用し各レイヤーデータをスキャン＋集計
                        For intKernelRow = LBound(dblKernel, intKernelRowDimension) To UBound(dblKernel, intKernelRowDimension)
                            For intKernelColumn = LBound(dblKernel, intKernelColumnDimension) To UBound(dblKernel, intKernelColumnDimension)
                                
                                intAddRow = intKernelRow - 1
                                intAddColumn = intKernelColumn - 1
                                
                                dblConvolution(intOutputLayer, intOutputRow, intOutputColumn) = dblConvolution(intOutputLayer, intOutputRow, intOutputColumn) + _
                                    dblKernel(intOutputLayer, intInputLayer, intKernelRow, intKernelColumn) * dblInput(intInputLayer, intOutputRow + intAddRow, intOutputColumn + intAddColumn)
                                
                            Next
                        Next
                    Next
                Next
            Next
        Next
                
    End Sub
    
    
    '********************************************
    ' ReLUによるアクティベート
    '********************************************
    Private Sub ActivateFunction()
        
        ReDim dblActivate( _
            LBound(dblConvolution, intLayerDimension) To UBound(dblConvolution, intLayerDimension), _
            LBound(dblConvolution, intRowDimension) To UBound(dblConvolution, intRowDimension), _
            LBound(dblConvolution, intColumnDimension) To UBound(dblConvolution, intColumnDimension))
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        For intLayer = LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension)
            For intRow = LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension)
                For intColumn = LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension)
                    dblActivate(intLayer, intRow, intColumn) = Application.WorksheetFunction.Max(0, dblConvolution(intLayer, intRow, intColumn))
                Next
            Next
        Next
                
    End Sub
    
    '********************************************
    ' 2×2のマックスプーリング
    '********************************************
    Private Sub MaxPooling()
        
        ReDim dblOutput( _
            LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension), _
            LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension) / 2, _
            LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension) / 2)
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        Dim intOutputRow As Integer
        Dim intOutputColumn As Integer
        
        For intLayer = LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension)
            For intRow = LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension)
                For intColumn = LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension)
                    
                    '出力結果は半分サイズ
                    intOutputRow = Application.WorksheetFunction.RoundUp(intRow / 2, 0)
                    intOutputColumn = Application.WorksheetFunction.RoundUp(intColumn / 2, 0)
                    
                    If dblOutput(intLayer, intOutputRow, intOutputColumn) < dblActivate(intLayer, intRow, intColumn) Then
                        dblOutput(intLayer, intOutputRow, intOutputColumn) = dblActivate(intLayer, intRow, intColumn)
                    End If
                    
                Next
            Next
        Next
        
    End Sub
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 誤差逆伝播計算によるパラーメータの更新
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Backward(ByRef dblInputArray_B() As Double, ByRef dblOutputArray_B() As Double) As Double()
        
        Call CopyArray(dblInputArray_B, dblOutput_B)
        Call MaxPoolingBack
        Call ActivateFunctionBack
        Call ConvolutionBack
        Call UpdateParams
        Call CopyArray(dblInput_B, dblOutputArray_B)
        
    End Function

    '********************************************
    ' MaxPoolingの逆伝播
    '********************************************
    Private Sub MaxPoolingBack()
        
        ReDim dblActivate_B( _
            LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension), _
            LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension), _
            LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension))
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        Dim intOutputRow As Integer
        Dim intOutputColumn As Integer
        
        For intLayer = LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension)
            For intRow = LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension)
                For intColumn = LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension)
                    
                    intOutputRow = Application.WorksheetFunction.RoundUp(intRow / 2, 0)
                    intOutputColumn = Application.WorksheetFunction.RoundUp(intColumn / 2, 0)
                    If dblActivate(intLayer, intRow, intColumn) = dblOutput(intLayer, intOutputRow, intOutputColumn) Then
                        dblActivate_B(intLayer, intRow, intColumn) = dblOutput_B(intLayer, intOutputRow, intOutputColumn)
                    End If
                    
                Next
            Next
        Next
        
    End Sub
    
    '********************************************
    ' ReLUによるアクティベートの逆伝播
    '********************************************
    Private Sub ActivateFunctionBack()
        
        ReDim dblConvolution_B( _
            LBound(dblConvolution, intLayerDimension) To UBound(dblConvolution, intLayerDimension), _
            LBound(dblConvolution, intRowDimension) To UBound(dblConvolution, intRowDimension), _
            LBound(dblConvolution, intColumnDimension) To UBound(dblConvolution, intColumnDimension))
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        For intLayer = LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension)
            For intRow = LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension)
                For intColumn = LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension)
                    
                    If dblConvolution(intLayer, intRow, intColumn) >= 0 Then
                        dblConvolution_B(intLayer, intRow, intColumn) = dblActivate_B(intLayer, intRow, intColumn)
                    End If
                Next
            Next
        Next
        
    End Sub
    
    '********************************************
    ' Convolutionの逆伝播
    '********************************************
    Private Sub ConvolutionBack()
        
        ReDim dblInput_B( _
            LBound(dblInput, intLayerDimension) To UBound(dblInput, intLayerDimension), _
            LBound(dblInput, intRowDimension) To UBound(dblInput, intRowDimension), _
            LBound(dblInput, intColumnDimension) To UBound(dblInput, intColumnDimension))
        
        '反転Kernel計算用の「余白付き」逆伝播信号
        Call MakeConvolutionBackMargin
        
        Dim intInputLayer As Integer
        Dim intInputRow As Integer
        Dim intInputColumn As Integer
        
        Dim intConvolutionLayer As Integer
        
        Dim intKernelRow As Integer
        Dim intKernelColumn As Integer
        
        Dim intAddRow As Integer
        Dim intAddColumn As Integer
        
        '********************************************
        ' Convolutionからインプットへの逆伝播
        '********************************************
        
        '計算結果を集約する配列の「層行列」
        For intInputLayer = LBound(dblInput_B, intLayerDimension) To UBound(dblInput_B, intLayerDimension)
            For intInputRow = LBound(dblInput_B, intRowDimension) To UBound(dblInput_B, intRowDimension)
                For intInputColumn = LBound(dblInput_B, intColumnDimension) To UBound(dblInput_B, intColumnDimension)
                    
                    '別レイヤーの逆伝播を受け取り集計
                    For intConvolutionLayer = LBound(dblConvolution_B_Margin, intLayerDimension) To UBound(dblConvolution_B_Margin, intLayerDimension)
                        
                        '反転カーネルを使用し各レイヤーデータをスキャン＋逆伝播集計
                        For intKernelRow = LBound(dblkernelReverse, intKernelRowDimension) To UBound(dblkernelReverse, intKernelRowDimension)
                            For intKernelColumn = LBound(dblkernelReverse, intKernelColumnDimension) To UBound(dblkernelReverse, intKernelColumnDimension)
                                
                                intAddRow = intKernelRow - 1
                                intAddColumn = intKernelColumn - 1
                                
                                dblInput_B(intInputLayer, intInputRow, intInputColumn) = dblInput_B(intInputLayer, intInputRow, intInputColumn) + _
                                    dblkernelReverse(intConvolutionLayer, intInputLayer, intKernelRow, intKernelColumn) * dblConvolution_B_Margin(intConvolutionLayer, intInputRow + intAddRow, intInputColumn + intAddColumn)
                                
                            Next
                        Next
                    Next
                Next
            Next
        Next
        
        
        Dim intKernelLayer As Integer
        Dim intKernelGroup As Integer
        Dim intConvolutionRow As Integer
        Dim intConvolutionColumn As Integer
        
        ReDim dblKernel_B( _
                LBound(dblKernel, intKernelLayerDimension) To UBound(dblKernel, intKernelLayerDimension), _
                LBound(dblKernel, intKernelGroupDimension) To UBound(dblKernel, intKernelGroupDimension), _
                LBound(dblKernel, intKernelRowDimension) To UBound(dblKernel, intKernelRowDimension), _
                LBound(dblKernel, intKernelColumnDimension) To UBound(dblKernel, intKernelColumnDimension))
        
        '********************************************
        ' カーネルの逆伝播
        '********************************************
        
        For intKernelLayer = LBound(dblKernel_B, intKernelLayerDimension) To UBound(dblKernel_B, intKernelLayerDimension)
            For intKernelGroup = LBound(dblKernel_B, intKernelGroupDimension) To UBound(dblKernel_B, intKernelGroupDimension)
                For intKernelRow = LBound(dblKernel_B, intKernelRowDimension) To UBound(dblKernel_B, intKernelRowDimension)
                    For intKernelColumn = LBound(dblKernel_B, intKernelColumnDimension) To UBound(dblKernel_B, intKernelColumnDimension)
                        
                        For intConvolutionRow = LBound(dblConvolution_B, intRowDimension) To UBound(dblConvolution_B, intRowDimension)
                            For intConvolutionColumn = LBound(dblConvolution_B, intColumnDimension) To UBound(dblConvolution_B, intColumnDimension)
                                
                                intAddRow = intKernelRow - 1
                                intAddColumn = intKernelColumn - 1
                                
                                dblKernel_B(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn) = _
                                    dblKernel_B(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn) + _
                                    dblConvolution_B(intKernelLayer, intConvolutionRow, intConvolutionColumn) * _
                                    dblInput(intKernelGroup, intConvolutionRow + intAddRow, intConvolutionColumn + intAddColumn)
                            Next
                        Next
                    Next
                Next
            Next
        Next
        
    End Sub
    
    '********************************************
    ' 余白付き逆伝播信号
    ' ※反転Kernelを使用した計算に使用
    '********************************************
    Private Sub MakeConvolutionBackMargin()
        
        ReDim dblConvolution_B_Margin( _
            LBound(dblConvolution_B, intLayerDimension) To UBound(dblConvolution_B, intLayerDimension), _
            LBound(dblConvolution_B, intRowDimension) To UBound(dblConvolution_B, intRowDimension) + (intMarginSize) * 2, _
            LBound(dblConvolution_B, intColumnDimension) To UBound(dblConvolution_B, intColumnDimension) + (intMarginSize) * 2)

        ReDim dblW_B( _
            LBound(dblW, intLayerDimension) To UBound(dblW, intLayerDimension), _
            LBound(dblW, intRowDimension) To UBound(dblW, intRowDimension))
    
        Dim intArrayLayer As Integer
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
                
        For intArrayLayer = LBound(dblConvolution_B, intLayerDimension) To UBound(dblConvolution_B, intLayerDimension)
            For intArrayRow = LBound(dblConvolution_B, intRowDimension) To UBound(dblConvolution_B, intRowDimension)
                For intArrayColumn = LBound(dblConvolution_B, intColumnDimension) To UBound(dblConvolution_B, intColumnDimension)
                    dblConvolution_B_Margin(intArrayLayer, intArrayRow + intMarginSize, intArrayColumn + intMarginSize) = _
                        dblConvolution_B(intArrayLayer, intArrayRow, intArrayColumn)
                
                    'ついでにウェイト（バイアス）の逆伝播信号集計
                    dblW_B(intArrayLayer, 1) = dblW_B(intArrayLayer, 1) + dblConvolution_B(intArrayLayer, intArrayRow, intArrayColumn)
                Next
            Next
        Next
    End Sub
    
    '********************************************
    ' パラメータの更新
    '********************************************
    Private Sub UpdateParams()
        
        Dim intKernelLayer As Integer
        Dim intKernelGroup As Integer
        Dim intKernelRow As Integer
        Dim intKernelColumn As Integer
        
        'カーネル・反転カーネルともに更新
        For intKernelLayer = LBound(dblKernel_B, intKernelLayerDimension) To UBound(dblKernel_B, intKernelLayerDimension)
            For intKernelGroup = LBound(dblKernel_B, intKernelGroupDimension) To UBound(dblKernel_B, intKernelGroupDimension)
                For intKernelRow = LBound(dblKernel_B, intKernelRowDimension) To UBound(dblKernel_B, intKernelRowDimension)
                    For intKernelColumn = LBound(dblKernel_B, intKernelColumnDimension) To UBound(dblKernel_B, intKernelColumnDimension)
                        
                        dblKernel(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn) = _
                            dblKernel(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn) - _
                            dblLR * dblKernel_B(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn)
                        
                        dblkernelReverse(intKernelLayer, intKernelGroup, intKernelSize - intKernelRow + 1, intKernelSize - intKernelColumn + 1) = _
                            dblKernel(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn)
    
                    Next
                Next
            Next
        Next
        
        'ウェイト（バイアス）の更新
        Dim intWeightRow As Integer
        For intWeightRow = LBound(dblW, intLayerDimension) To UBound(dblW, intLayerDimension)
            dblW(intWeightRow, 1) = dblW(intWeightRow, 1) - dblLR * dblW_B(intWeightRow, 1)
        Next
    
    End Sub
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassFlatten（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '配列の1次元化・復元を行うために、元の次元を保存
    Const intLayerDimension As Integer = 1
    Const intRowDimension As Integer = 2
    Const intColumnDimension As Integer = 3
        
    Dim intLayerCount As Integer
    Dim intRowCount As Integer
    Dim intColumnCount As Integer
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 配列の1次元化
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Flatten(ByRef dblInputArray() As Double, ByRef dblOutputArray() As Double)
        
        '元の次元を保存
        intLayerCount = UBound(dblInputArray, intLayerDimension)
        intRowCount = UBound(dblInputArray, intRowDimension)
        intColumnCount = UBound(dblInputArray, intColumnDimension)
        
        Dim intArrayLayer As Integer
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
        Dim intIndex As Integer
        
        Dim dblOutput() As Double
        ReDim dblOutput(1 To intLayerCount * intRowCount * intColumnCount, 1 To 1)
        
        For intArrayLayer = 1 To intLayerCount
            For intArrayRow = 1 To intRowCount
                For intArrayColumn = 1 To intColumnCount
                    intIndex = intIndex + 1
                    dblOutput(intIndex, 1) = dblInputArray(intArrayLayer, intArrayRow, intArrayColumn)
                Next
            Next
        Next
            
        Call CopyArray(dblOutput, dblOutputArray)
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 配列を3次元化に復元する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub FlattenBack(ByRef dblInputArray() As Double, ByRef dblOutputArray() As Double)
        
        Dim intArrayLayer As Integer
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
        Dim intIndex As Integer
        
        Dim dblOutput() As Double
        ReDim dblOutput(1 To intLayerCount, 1 To intRowCount, 1 To intColumnCount)
        
        For intArrayLayer = 1 To intLayerCount
            For intArrayRow = 1 To intRowCount
                For intArrayColumn = 1 To intColumnCount
                    intIndex = intIndex + 1
                    dblOutput(intArrayLayer, intArrayRow, intArrayColumn) = dblInputArray(intIndex, 1)
                Next
            Next
        Next
            
        Call CopyArray(dblOutput, dblOutputArray)
        
    End Sub
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassLayer（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'Layer設計のプロパティ
    '内部で保持する配列のサイズなどをダイナミックに作成
    Dim intXRowsCount As Integer
    Dim intXColumnsCount As Integer
    Dim intWRowsCount As Integer
    Dim intWColumnsCount As Integer
    
    'アクティベート関数の選択
    Dim blnReLU As Boolean
    Dim blnSigmoid As Boolean
    Dim blnSoftMax As Boolean
    
    '学習・予想の計算時に使用するパラメータ
    Dim dblX() As Double
    Dim dblW() As Double
    Dim dblB() As Double
    Dim dblY() As Double
    Dim dblZ() As Double
    
    '誤差逆伝播計算に使用
    '計算完了後「_Bなし」の変数を更新する
    '※逆伝播は値の保存必要ないかも？
    Dim dblX_B() As Double
    Dim dblW_B() As Double
    Dim dblB_B() As Double
    Dim dblY_B() As Double
    Dim dblZ_B() As Double
    
    '学習率を保持
    Dim dblLR As Double
    
    'パラメータを出力できるようにするなど、
    '拡張性のためLayerに名前を保持する
    Dim strLayerName As String

'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Layerの初期設定
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Sub Init(ByVal intInput As Integer, ByVal intOutput As Integer, ByVal strActivateFucntion As String, ByVal dblLearningRate As Double, ByVal intLayerNumber As Integer)
        
        '入力データの体裁
        intXRowsCount = intInput
        intXColumnsCount = 1
        
        'Wパラメータの体裁
        intWRowsCount = intOutput
        intWColumnsCount = intInput
        
        'アクティベート関数の選択
        If strActivateFucntion = "ReLU" Then
            blnReLU = True
        ElseIf strActivateFucntion = "Sigmoid" Then
            blnSigmoid = True
        ElseIf strActivateFucntion = "SoftMax" Then
            blnSoftMax = True
        End If
        
        '学習率の保持
        dblLR = dblLearningRate
        
        strLayerName = "Layer" & intLayerNumber
        
        '入出力の体裁によって、配列のサイズを決定
        ReDim dblX(1 To intXRowsCount, 1 To intXColumnsCount) As Double
        ReDim dblW(1 To intWRowsCount, 1 To intWColumnsCount) As Double
        ReDim dblB(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblY(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblZ(1 To intWRowsCount, 1 To 1) As Double
        
        '誤差逆伝播計算用配列は「_Bなし」と同じサイズ
        ReDim dblX_B(1 To intXRowsCount, 1 To intXColumnsCount) As Double
        ReDim dblW_B(1 To intWRowsCount, 1 To intWColumnsCount) As Double
        ReDim dblB_B(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblY_B(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblZ_B(1 To intWRowsCount, 1 To 1) As Double
        
        Dim lngRow As Long
        Dim lngColum As Long
        
        'Wをランダム（正規分布）な数値で埋める
        For lngRow = LBound(dblW, 1) To UBound(dblW, 1)
            For lngColum = LBound(dblW, 2) To UBound(dblW, 2)
                Randomize
                dblW(lngRow, lngColum) = Application.WorksheetFunction.Norm_Inv(Rnd(), 0, 1)
            Next
        Next
        
        'Bをランダム（正規分布）な数値で埋める
        For lngRow = LBound(dblB, 1) To UBound(dblB, 1)
            For lngColum = LBound(dblB, 2) To UBound(dblB, 2)
                Randomize
                dblB(lngRow, lngColum) = Application.WorksheetFunction.Norm_Inv(Rnd(), 0, 1)
            Next
        Next
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 学習の前進計算 ＆ 予測時に使用する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Forward(ByRef dblArrayX() As Double, ByRef dblArrayZ() As Double) As Double()
        Call CopyArray(dblArrayX, dblX)
        Call CalcWXB
        Call ActivateFunction
        Call CopyArray(dblZ, dblArrayZ)
        Forward = dblZ
    End Function
    
    '********************************************
    ' 「wx+b=y」の計算を実行
    '********************************************
    Private Sub CalcWXB()
        
        Dim vntWX As Variant
        vntWX = Dot(dblW, dblX)
        
        Dim lngRow As Long
        For lngRow = 1 To UBound(vntWX, 1)
            On Error Resume Next
            dblY(lngRow, 1) = vntWX(lngRow, 1) + dblB(lngRow, 1)
            If Err.Number <> 0 Then
                dblY(lngRow, 1) = vntWX(lngRow) + dblB(lngRow, 1)
            End If
            On Error GoTo 0
        Next
                
    End Sub

    '********************************************
    ' 「activate(y)=z」の計算を実行
    '********************************************
    Private Sub ActivateFunction()
        
        Dim lngRow As Long
        
        'ReLU関数によるActivate
        If blnReLU = True Then
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = Application.WorksheetFunction.Max(0, dblY(lngRow, 1))
            Next
        
        'Sigmoid関数によるActivate
        ElseIf blnSigmoid = True Then
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = 1 / (1 + Exp(-dblY(lngRow, 1)))
            Next
            
        ElseIf blnSoftMax = True Then
            
            Dim dblMax As Double
            Dim dblTotal As Double
            
            dblMax = Application.WorksheetFunction.Max(dblY)
            
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = Exp(dblY(lngRow, 1) - dblMax) + (1 / 10 ^ 6)
                dblTotal = dblTotal + dblZ(lngRow, 1)
            Next
            
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = dblZ(lngRow, 1) / dblTotal
            Next
            
        End If
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 誤差逆伝播計算によるパラーメータの更新
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Backward(ByRef dblZ() As Double, ByRef dblX() As Double) As Double()
        Call CopyArray(dblZ, dblZ_B)
        Call ActivateFunctionBack
        Call CalcWXB_XBack
        Call CalcWXB_WBack
        Call CalcWXB_BBack
        Call CopyArray(dblX_B, dblX)
        Call UpdateParams
        Backward = dblX_B
    End Function
    
    '********************************************
    ' 「activate(y)」の微分計算を実行
    '********************************************
    Sub ActivateFunctionBack()
        
        Dim lngRow As Long
        
        'ReLU関数の逆伝播
        If blnReLU = True Then
            For lngRow = 1 To UBound(dblY, 1)
                If dblY(lngRow, 1) >= 0 Then
                    dblY_B(lngRow, 1) = dblZ_B(lngRow, 1)
                Else
                    dblY_B(lngRow, 1) = 0
                End If
            Next
        
        'Sigmoid関数の逆伝播
        ElseIf blnSigmoid = True Then
            For lngRow = 1 To UBound(dblY_B, 1)
                dblY_B(lngRow, 1) = dblZ_B(lngRow, 1) * (dblZ(lngRow, 1) * (1 - dblZ(lngRow, 1)))
            Next
            
        'SoftMaxの逆伝播
        ElseIf blnSoftMax = True Then
            Call CopyArray(dblZ_B, dblY_B)
        End If
    End Sub
    
    '********************************************
    ' 「wx+b⇒xの微分⇒w」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_XBack()
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '「w ＆ 逆伝播の積和（加算の反復）」を計算するため一度過去データを消去
        For lngRow = LBound(dblX_B, 1) To UBound(dblX_B, 1)
            dblX_B(lngRow, 1) = 0
        Next
        
        '「w ＆ 逆伝播」の積和（加算の反復）
        For lngRow = LBound(dblW, 1) To UBound(dblW, 1)
            For lngColumn = LBound(dblW, 2) To UBound(dblW, 2)
                dblX_B(lngColumn, 1) = dblX_B(lngColumn, 1) + dblW(lngRow, lngColumn) * dblY_B(lngRow, 1)
            Next
        Next
    End Sub
    
    '********************************************
    ' 「wx+b⇒wの微分⇒x」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_WBack()
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '「x ＆ 逆伝播」の積和
        For lngRow = LBound(dblW_B, 1) To UBound(dblW_B, 1)
            For lngColumn = LBound(dblW_B, 2) To UBound(dblW_B, 2)
                dblW_B(lngRow, lngColumn) = dblX(lngColumn, 1) * dblY_B(lngRow, 1)
            Next
        Next
    End Sub
    
    '********************************************
    ' 「wx+b⇒bの微分⇒1」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_BBack()
        Call CopyArray(dblZ_B, dblB_B)
    End Sub
    
    '********************************************
    ' パラメータの更新
    ' 「新パラメータ = 旧パラメータ - 学習率 * 各パラメータの逆伝播値」
    '********************************************
    Private Sub UpdateParams()
        Dim lngRow As Long
        Dim lngColumn As Long
        
        'w = w - LearningRate * w_b
        For lngRow = LBound(dblW_B, 1) To UBound(dblW_B, 1)
            For lngColumn = LBound(dblW_B, 2) To UBound(dblW_B, 2)
                dblW(lngRow, lngColumn) = dblW(lngRow, lngColumn) - dblW_B(lngRow, lngColumn) * dblLR
            Next
        Next
        
        'b = b - LearningRate * b_b
        For lngRow = LBound(dblB_B, 1) To UBound(dblB_B, 1)
            For lngColumn = LBound(dblB_B, 2) To UBound(dblB_B, 2)
                dblB(lngRow, lngColumn) = dblB(lngRow, lngColumn) - dblB_B(lngRow, lngColumn) * dblLR
            Next
        Next
        
    End Sub
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassNeuralNetwork（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'クラス内ので管理するLayerの設定等
    Dim intInputCount As Integer
    Dim intOutputCount As Integer
    Dim intLayerCount As Integer
    Dim intUnitCount As Integer
    Dim dblLR As Double
    
    'クラス内でLayer・学習・予測を管理する
    Dim aryNetworks() As Variant
    Dim intT As Integer
    Dim dblE As Double
    Dim dblZ() As Double
    Dim dblZ_B() As Double
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラスの初期設定・Layerの管理を代行
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Sub Init(ByVal intInput As Integer, ByVal intOutput As Integer, ByVal intLayer As Integer, ByVal intUnits As Integer, ByVal dblLearningRate As Double)
        
        
        ReDim dblZ(1 To intOutput, 1 To 1) As Double
        ReDim dblZ_B(1 To intOutput, 1 To 1) As Double
        
        intInputCount = intInput
        intOutputCount = intOutput
        intLayerCount = intLayer
        intUnitCount = intUnits
        dblLR = dblLearningRate
        
        ReDim aryNetworks(1 To intLayerCount)
        
        Dim intLayerIndex As Integer
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            
            Set aryNetworks(intLayerIndex) = New ClassLayer
            
            If intLayerIndex = LBound(aryNetworks) Then
                Call aryNetworks(intLayerIndex).Init(intInputCount, intUnitCount, "ReLU", dblLearningRate, intLayerIndex)
            ElseIf intLayerIndex <> UBound(aryNetworks) Then
                Call aryNetworks(intLayerIndex).Init(intUnitCount, intUnitCount, "ReLU", dblLearningRate, intLayerIndex)
            Else
                Call aryNetworks(intLayerIndex).Init(intUnitCount, intOutputCount, "Sigmoid", dblLearningRate, intLayerIndex)
            End If
            
        Next
        
    End Sub
    
    '********************************************
    ' 学習
    '********************************************
    Public Sub Train(ByVal vntX As Variant, ByVal intTeach As Integer)
        
        Dim intLayerIndex As Integer
        Dim vntZ As Variant
        
        intT = intTeach
        vntZ = vntX
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            Call aryNetworks(intLayerIndex).Forward(vntZ, vntZ)
        Next
        
        dblZ(1, 1) = vntZ(1, 1)
        
        If dblZ(1, 1) <> 0 And dblZ(1, 1) <> 1 Then
            
            Call CrossEntropyLoss
            Call CrossEntropyLossBack
            
            Dim vntZ_B As Variant
            vntZ_B = dblZ_B
            
            For intLayerIndex = UBound(aryNetworks) To LBound(aryNetworks) Step -1
                Call aryNetworks(intLayerIndex).Backward(vntZ_B, vntZ_B)
            Next
        Else
            Debug.Print "error"
        End If
        
    End Sub
    
    '********************************************
    ' 目的関数・誤差計算
    '********************************************
    Private Sub CrossEntropyLoss()
        If intT = 1 Then
            dblE = (-intT) * Log(dblZ(1, 1))
        Else
            dblE = -(1 - intT) * Log(1 - dblZ(1, 1))
        End If
    End Sub
    
    '********************************************
    ' 目的関数・誤差計算逆伝播
    '********************************************
    Private Sub CrossEntropyLossBack()
        On Error Resume Next
        dblZ_B(1, 1) = (-intT / dblZ(1, 1)) + ((1 - intT) / (1 - dblZ(1, 1)))
        If Err.Number <> 0 Then
            dblZ_B(1, 1) = 0
        End If
        On Error GoTo 0
    End Sub
    
    '********************************************
    ' 予測
    '********************************************
    Public Function Predict(ByVal vntX As Variant) As Double
        
        Dim intLayerIndex As Integer
        Dim vntZ As Variant
        
        vntZ = vntX
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            Call aryNetworks(intLayerIndex).Forward(vntZ, vntZ)
        Next
        
        Predict = vntZ(1, 1)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　JsonConverterの環境依存を解消
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    Option Explicit

    ''
    ' VBA-JSON v2.3.1
    ' (c) Tim Hall - https://github.com/VBA-tools/VBA-JSON
    '
    ' JSON Converter for VBA
    '
    ' Errors:
    ' 10001 - JSON parse error
    '
    ' @class JsonConverter
    ' @author tim.hall.engr@gmail.com
    ' @license MIT (http://www.opensource.org/licenses/mit-license.php)
    '' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
    '
    ' Based originally on vba-json (with extensive changes)
    ' BSD license included below
    '
    ' JSONLib, http://code.google.com/p/vba-json/
    '
    ' Copyright (c) 2013, Ryo Yokoyama
    ' All rights reserved.
    '
    ' Redistribution and use in source and binary forms, with or without
    ' modification, are permitted provided that the following conditions are met:
    '     * Redistributions of source code must retain the above copyright
    '       notice, this list of conditions and the following disclaimer.
    '     * Redistributions in binary form must reproduce the above copyright
    '       notice, this list of conditions and the following disclaimer in the
    '       documentation and/or other materials provided with the distribution.
    '     * Neither the name of the <organization> nor the
    '       names of its contributors may be used to endorse or promote products
    '       derived from this software without specific prior written permission.
    '
    ' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    ' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    ' DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    ' DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    ' (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    ' LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ' ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    ' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    ' SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    ' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
    
    ' === VBA-UTC Headers
    #If Mac Then
    
    #If VBA7 Then
    
    ' 64-bit Mac (2016)
    Private Declare PtrSafe Function utc_popen Lib "/usr/lib/libc.dylib" Alias "popen" _
        (ByVal utc_Command As String, ByVal utc_Mode As String) As LongPtr
    Private Declare PtrSafe Function utc_pclose Lib "/usr/lib/libc.dylib" Alias "pclose" _
        (ByVal utc_File As LongPtr) As LongPtr
    Private Declare PtrSafe Function utc_fread Lib "/usr/lib/libc.dylib" Alias "fread" _
        (ByVal utc_Buffer As String, ByVal utc_Size As LongPtr, ByVal utc_Number As LongPtr, ByVal utc_File As LongPtr) As LongPtr
    Private Declare PtrSafe Function utc_feof Lib "/usr/lib/libc.dylib" Alias "feof" _
        (ByVal utc_File As LongPtr) As LongPtr
    
    #Else
    
    ' 32-bit Mac
    Private Declare Function utc_popen Lib "libc.dylib" Alias "popen" _
        (ByVal utc_Command As String, ByVal utc_Mode As String) As Long
    Private Declare Function utc_pclose Lib "libc.dylib" Alias "pclose" _
        (ByVal utc_File As Long) As Long
    Private Declare Function utc_fread Lib "libc.dylib" Alias "fread" _
        (ByVal utc_Buffer As String, ByVal utc_Size As Long, ByVal utc_Number As Long, ByVal utc_File As Long) As Long
    Private Declare Function utc_feof Lib "libc.dylib" Alias "feof" _
        (ByVal utc_File As Long) As Long
    
    #End If
    
    #ElseIf VBA7 Then
    
    ' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724421.aspx
    ' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724949.aspx
    ' http://msdn.microsoft.com/en-us/library/windows/desktop/ms725485.aspx
    Private Declare PtrSafe Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
    Private Declare PtrSafe Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
    Private Declare PtrSafe Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long
    
    #Else
    
    Private Declare Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
    Private Declare Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
    Private Declare Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long
    
    #End If
    
    #If Mac Then
    
    #If VBA7 Then
    Private Type utc_ShellResult
        utc_Output As String
        utc_ExitCode As LongPtr
    End Type
    
    #Else
    
    Private Type utc_ShellResult
        utc_Output As String
        utc_ExitCode As Long
    End Type
    
    #End If
    
    #Else
    
    Private Type utc_SYSTEMTIME
        utc_wYear As Integer
        utc_wMonth As Integer
        utc_wDayOfWeek As Integer
        utc_wDay As Integer
        utc_wHour As Integer
        utc_wMinute As Integer
        utc_wSecond As Integer
        utc_wMilliseconds As Integer
    End Type
    
    Private Type utc_TIME_ZONE_INFORMATION
        utc_Bias As Long
        utc_StandardName(0 To 31) As Integer
        utc_StandardDate As utc_SYSTEMTIME
        utc_StandardBias As Long
        utc_DaylightName(0 To 31) As Integer
        utc_DaylightDate As utc_SYSTEMTIME
        utc_DaylightBias As Long
    End Type
    
    #End If
    ' === End VBA-UTC
    
    Private Type json_Options
        ' VBA only stores 15 significant digits, so any numbers larger than that are truncated
        ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
        ' See: http://support.microsoft.com/kb/269370
        '
        ' By default, VBA-JSON will use String for numbers longer than 15 characters that contain only digits
        ' to override set `JsonConverter.JsonOptions.UseDoubleForLargeNumbers = True`
        UseDoubleForLargeNumbers As Boolean
    
        ' The JSON standard requires object keys to be quoted (" or '), use this option to allow unquoted keys
        AllowUnquotedKeys As Boolean
    
        ' The solidus (/) is not required to be escaped, use this option to escape them as \/ in ConvertToJson
        EscapeSolidus As Boolean
    End Type
    Public JsonOptions As json_Options
    
    ' ============================================= '
    ' Public Methods
    ' ============================================= '
    
    ''
    ' Convert JSON string to object (Dictionary/Collection)
    '
    ' @method ParseJson
    ' @param {String} json_String
    ' @return {Object} (Dictionary or Collection)
    ' @throws 10001 - JSON parse error
    ''
    Public Function ParseJson(ByVal JsonString As String) As Object
        Dim json_Index As Long
        json_Index = 1
    
        ' Remove vbCr, vbLf, and vbTab from json_String
        JsonString = VBA.Replace(VBA.Replace(VBA.Replace(JsonString, VBA.vbCr, ""), VBA.vbLf, ""), VBA.vbTab, "")
    
        json_SkipSpaces JsonString, json_Index
        Select Case VBA.Mid$(JsonString, json_Index, 1)
        Case "{"
            Set ParseJson = json_ParseObject(JsonString, json_Index)
        Case "["
            Set ParseJson = json_ParseArray(JsonString, json_Index)
        Case Else
            ' Error: Invalid JSON string
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(JsonString, json_Index, "Expecting '{' or '['")
        End Select
    End Function
    
    ''
    ' Convert object (Dictionary/Collection/Array) to JSON
    '
    ' @method ConvertToJson
    ' @param {Variant} JsonValue (Dictionary, Collection, or Array)
    ' @param {Integer|String} Whitespace "Pretty" print json with given number of spaces per indentation (Integer) or given string
    ' @return {String}
    ''
    Public Function ConvertToJson(ByVal JsonValue As Variant, Optional ByVal Whitespace As Variant, Optional ByVal json_CurrentIndentation As Long = 0) As String
        Dim json_Buffer As String
        Dim json_BufferPosition As Long
        Dim json_BufferLength As Long
        Dim json_Index As Long
        Dim json_LBound As Long
        Dim json_UBound As Long
        Dim json_IsFirstItem As Boolean
        Dim json_Index2D As Long
        Dim json_LBound2D As Long
        Dim json_UBound2D As Long
        Dim json_IsFirstItem2D As Boolean
        Dim json_Key As Variant
        Dim json_Value As Variant
        Dim json_DateStr As String
        Dim json_Converted As String
        Dim json_SkipItem As Boolean
        Dim json_PrettyPrint As Boolean
        Dim json_Indentation As String
        Dim json_InnerIndentation As String
    
        json_LBound = -1
        json_UBound = -1
        json_IsFirstItem = True
        json_LBound2D = -1
        json_UBound2D = -1
        json_IsFirstItem2D = True
        json_PrettyPrint = Not IsMissing(Whitespace)
    
        Select Case VBA.VarType(JsonValue)
        Case VBA.vbNull
            ConvertToJson = "null"
        Case VBA.vbDate
            ' Date
            json_DateStr = ConvertToIso(VBA.CDate(JsonValue))
    
            ConvertToJson = """" & json_DateStr & """"
        Case VBA.vbString
            ' String (or large number encoded as string)
            If Not JsonOptions.UseDoubleForLargeNumbers And json_StringIsLargeNumber(JsonValue) Then
                ConvertToJson = JsonValue
            Else
                ConvertToJson = """" & json_Encode(JsonValue) & """"
            End If
        Case VBA.vbBoolean
            If JsonValue Then
                ConvertToJson = "true"
            Else
                ConvertToJson = "false"
            End If
        Case VBA.vbArray To VBA.vbArray + VBA.vbByte
            If json_PrettyPrint Then
                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
                    json_InnerIndentation = VBA.String$(json_CurrentIndentation + 2, Whitespace)
                Else
                    json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
                    json_InnerIndentation = VBA.Space$((json_CurrentIndentation + 2) * Whitespace)
                End If
            End If
    
            ' Array
            json_BufferAppend json_Buffer, "[", json_BufferPosition, json_BufferLength
    
            On Error Resume Next
    
            json_LBound = LBound(JsonValue, 1)
            json_UBound = UBound(JsonValue, 1)
            json_LBound2D = LBound(JsonValue, 2)
            json_UBound2D = UBound(JsonValue, 2)
    
            If json_LBound >= 0 And json_UBound >= 0 Then
                For json_Index = json_LBound To json_UBound
                    If json_IsFirstItem Then
                        json_IsFirstItem = False
                    Else
                        ' Append comma to previous line
                        json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                    End If
    
                    If json_LBound2D >= 0 And json_UBound2D >= 0 Then
                        ' 2D Array
                        If json_PrettyPrint Then
                            json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
                        End If
                        json_BufferAppend json_Buffer, json_Indentation & "[", json_BufferPosition, json_BufferLength
    
                        For json_Index2D = json_LBound2D To json_UBound2D
                            If json_IsFirstItem2D Then
                                json_IsFirstItem2D = False
                            Else
                                json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                            End If
    
                            json_Converted = ConvertToJson(JsonValue(json_Index, json_Index2D), Whitespace, json_CurrentIndentation + 2)
    
                            ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                            If json_Converted = "" Then
                                ' (nest to only check if converted = "")
                                If json_IsUndefined(JsonValue(json_Index, json_Index2D)) Then
                                    json_Converted = "null"
                                End If
                            End If
    
                            If json_PrettyPrint Then
                                json_Converted = vbNewLine & json_InnerIndentation & json_Converted
                            End If
    
                            json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                        Next json_Index2D
    
                        If json_PrettyPrint Then
                            json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
                        End If
    
                        json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
                        json_IsFirstItem2D = True
                    Else
                        ' 1D Array
                        json_Converted = ConvertToJson(JsonValue(json_Index), Whitespace, json_CurrentIndentation + 1)
    
                        ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                        If json_Converted = "" Then
                            ' (nest to only check if converted = "")
                            If json_IsUndefined(JsonValue(json_Index)) Then
                                json_Converted = "null"
                            End If
                        End If
    
                        If json_PrettyPrint Then
                            json_Converted = vbNewLine & json_Indentation & json_Converted
                        End If
    
                        json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                    End If
                Next json_Index
            End If
    
            On Error GoTo 0
    
            If json_PrettyPrint Then
                json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
    
                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                Else
                    json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                End If
            End If
    
            json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
    
            ConvertToJson = json_BufferToString(json_Buffer, json_BufferPosition)
    
        ' Dictionary or Collection
        Case VBA.vbObject
            If json_PrettyPrint Then
                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
                Else
                    json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
                End If
            End If
    
            ' Dictionary
            If VBA.TypeName(JsonValue) = "Dictionary" Then
                json_BufferAppend json_Buffer, "{", json_BufferPosition, json_BufferLength
                For Each json_Key In JsonValue.Keys
                    ' For Objects, undefined (Empty/Nothing) is not added to object
                    json_Converted = ConvertToJson(JsonValue(json_Key), Whitespace, json_CurrentIndentation + 1)
                    If json_Converted = "" Then
                        json_SkipItem = json_IsUndefined(JsonValue(json_Key))
                    Else
                        json_SkipItem = False
                    End If
    
                    If Not json_SkipItem Then
                        If json_IsFirstItem Then
                            json_IsFirstItem = False
                        Else
                            json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                        End If
    
                        If json_PrettyPrint Then
                            json_Converted = vbNewLine & json_Indentation & """" & json_Key & """: " & json_Converted
                        Else
                            json_Converted = """" & json_Key & """:" & json_Converted
                        End If
    
                        json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                    End If
                Next json_Key
    
                If json_PrettyPrint Then
                    json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
    
                    If VBA.VarType(Whitespace) = VBA.vbString Then
                        json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                    Else
                        json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                    End If
                End If
    
                json_BufferAppend json_Buffer, json_Indentation & "}", json_BufferPosition, json_BufferLength
    
            ' Collection
            ElseIf VBA.TypeName(JsonValue) = "Collection" Then
                json_BufferAppend json_Buffer, "[", json_BufferPosition, json_BufferLength
                For Each json_Value In JsonValue
                    If json_IsFirstItem Then
                        json_IsFirstItem = False
                    Else
                        json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                    End If
    
                    json_Converted = ConvertToJson(json_Value, Whitespace, json_CurrentIndentation + 1)
    
                    ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                    If json_Converted = "" Then
                        ' (nest to only check if converted = "")
                        If json_IsUndefined(json_Value) Then
                            json_Converted = "null"
                        End If
                    End If
    
                    If json_PrettyPrint Then
                        json_Converted = vbNewLine & json_Indentation & json_Converted
                    End If
    
                    json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                Next json_Value
    
                If json_PrettyPrint Then
                    json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
    
                    If VBA.VarType(Whitespace) = VBA.vbString Then
                        json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                    Else
                        json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                    End If
                End If
    
                json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
            End If
    
            ConvertToJson = json_BufferToString(json_Buffer, json_BufferPosition)
        Case VBA.vbInteger, VBA.vbLong, VBA.vbSingle, VBA.vbDouble, VBA.vbCurrency, VBA.vbDecimal
            ' Number (use decimals for numbers)
            ConvertToJson = VBA.Replace(JsonValue, ",", ".")
        Case Else
            ' vbEmpty, vbError, vbDataObject, vbByte, vbUserDefinedType
            ' Use VBA's built-in to-string
            On Error Resume Next
            ConvertToJson = JsonValue
            On Error GoTo 0
        End Select
    End Function
    
    ' ============================================= '
    ' Private Functions
    ' ============================================= '
    
    Private Function json_ParseObject(json_String As String, ByRef json_Index As Long) As Object
        Dim json_Key As String
        Dim json_NextChar As String
    
        Set json_ParseObject = CreateObject("Scripting.Dictionary")
        json_SkipSpaces json_String, json_Index
        If VBA.Mid$(json_String, json_Index, 1) <> "{" Then
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '{'")
        Else
            json_Index = json_Index + 1
    
            Do
                json_SkipSpaces json_String, json_Index
                If VBA.Mid$(json_String, json_Index, 1) = "}" Then
                    json_Index = json_Index + 1
                    Exit Function
                ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                    json_Index = json_Index + 1
                    json_SkipSpaces json_String, json_Index
                End If
    
                json_Key = json_ParseKey(json_String, json_Index)
                json_NextChar = json_Peek(json_String, json_Index)
                If json_NextChar = "[" Or json_NextChar = "{" Then
                    Set json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
                Else
                    json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
                End If
            Loop
        End If
    End Function
    
    Private Function json_ParseArray(json_String As String, ByRef json_Index As Long) As Collection
        Set json_ParseArray = New Collection
    
        json_SkipSpaces json_String, json_Index
        If VBA.Mid$(json_String, json_Index, 1) <> "[" Then
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '['")
        Else
            json_Index = json_Index + 1
    
            Do
                json_SkipSpaces json_String, json_Index
                If VBA.Mid$(json_String, json_Index, 1) = "]" Then
                    json_Index = json_Index + 1
                    Exit Function
                ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                    json_Index = json_Index + 1
                    json_SkipSpaces json_String, json_Index
                End If
    
                json_ParseArray.Add json_ParseValue(json_String, json_Index)
            Loop
        End If
    End Function
    
    Private Function json_ParseValue(json_String As String, ByRef json_Index As Long) As Variant
        json_SkipSpaces json_String, json_Index
        Select Case VBA.Mid$(json_String, json_Index, 1)
        Case "{"
            Set json_ParseValue = json_ParseObject(json_String, json_Index)
        Case "["
            Set json_ParseValue = json_ParseArray(json_String, json_Index)
        Case """", "'"
            json_ParseValue = json_ParseString(json_String, json_Index)
        Case Else
            If VBA.Mid$(json_String, json_Index, 4) = "true" Then
                json_ParseValue = True
                json_Index = json_Index + 4
            ElseIf VBA.Mid$(json_String, json_Index, 5) = "false" Then
                json_ParseValue = False
                json_Index = json_Index + 5
            ElseIf VBA.Mid$(json_String, json_Index, 4) = "null" Then
                json_ParseValue = Null
                json_Index = json_Index + 4
            ElseIf VBA.InStr("+-0123456789", VBA.Mid$(json_String, json_Index, 1)) Then
                json_ParseValue = json_ParseNumber(json_String, json_Index)
            Else
                Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['")
            End If
        End Select
    End Function
    
    Private Function json_ParseString(json_String As String, ByRef json_Index As Long) As String
        Dim json_Quote As String
        Dim json_Char As String
        Dim json_Code As String
        Dim json_Buffer As String
        Dim json_BufferPosition As Long
        Dim json_BufferLength As Long
    
        json_SkipSpaces json_String, json_Index
    
        ' Store opening quote to look for matching closing quote
        json_Quote = VBA.Mid$(json_String, json_Index, 1)
        json_Index = json_Index + 1
    
        Do While json_Index > 0 And json_Index <= Len(json_String)
            json_Char = VBA.Mid$(json_String, json_Index, 1)
    
            Select Case json_Char
            Case "\"
                ' Escaped string, \\, or \/
                json_Index = json_Index + 1
                json_Char = VBA.Mid$(json_String, json_Index, 1)
    
                Select Case json_Char
                Case """", "\", "/", "'"
                    json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "b"
                    json_BufferAppend json_Buffer, vbBack, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "f"
                    json_BufferAppend json_Buffer, vbFormFeed, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "n"
                    json_BufferAppend json_Buffer, vbCrLf, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "r"
                    json_BufferAppend json_Buffer, vbCr, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "t"
                    json_BufferAppend json_Buffer, vbTab, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "u"
                    ' Unicode character escape (e.g. \u00a9 = Copyright)
                    json_Index = json_Index + 1
                    json_Code = VBA.Mid$(json_String, json_Index, 4)
                    json_BufferAppend json_Buffer, VBA.ChrW(VBA.Val("&h" + json_Code)), json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 4
                End Select
            Case json_Quote
                json_ParseString = json_BufferToString(json_Buffer, json_BufferPosition)
                json_Index = json_Index + 1
                Exit Function
            Case Else
                json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            End Select
        Loop
    End Function
    
    Private Function json_ParseNumber(json_String As String, ByRef json_Index As Long) As Variant
        Dim json_Char As String
        Dim json_Value As String
        Dim json_IsLargeNumber As Boolean
    
        json_SkipSpaces json_String, json_Index
    
        Do While json_Index > 0 And json_Index <= Len(json_String)
            json_Char = VBA.Mid$(json_String, json_Index, 1)
    
            If VBA.InStr("+-0123456789.eE", json_Char) Then
                ' Unlikely to have massive number, so use simple append rather than buffer here
                json_Value = json_Value & json_Char
                json_Index = json_Index + 1
            Else
                ' Excel only stores 15 significant digits, so any numbers larger than that are truncated
                ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
                ' See: http://support.microsoft.com/kb/269370
                '
                ' Fix: Parse -> String, Convert -> String longer than 15/16 characters containing only numbers and decimal points -> Number
                ' (decimal doesn't factor into significant digit count, so if present check for 15 digits + decimal = 16)
                json_IsLargeNumber = IIf(InStr(json_Value, "."), Len(json_Value) >= 17, Len(json_Value) >= 16)
                If Not JsonOptions.UseDoubleForLargeNumbers And json_IsLargeNumber Then
                    json_ParseNumber = json_Value
                Else
                    ' VBA.Val does not use regional settings, so guard for comma is not needed
                    json_ParseNumber = VBA.Val(json_Value)
                End If
                Exit Function
            End If
        Loop
    End Function
    
    Private Function json_ParseKey(json_String As String, ByRef json_Index As Long) As String
        ' Parse key with single or double quotes
        If VBA.Mid$(json_String, json_Index, 1) = """" Or VBA.Mid$(json_String, json_Index, 1) = "'" Then
            json_ParseKey = json_ParseString(json_String, json_Index)
        ElseIf JsonOptions.AllowUnquotedKeys Then
            Dim json_Char As String
            Do While json_Index > 0 And json_Index <= Len(json_String)
                json_Char = VBA.Mid$(json_String, json_Index, 1)
                If (json_Char <> " ") And (json_Char <> ":") Then
                    json_ParseKey = json_ParseKey & json_Char
                    json_Index = json_Index + 1
                Else
                    Exit Do
                End If
            Loop
        Else
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '""' or '''")
        End If
    
        ' Check for colon and skip if present or throw if not present
        json_SkipSpaces json_String, json_Index
        If VBA.Mid$(json_String, json_Index, 1) <> ":" Then
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting ':'")
        Else
            json_Index = json_Index + 1
        End If
    End Function
    
    Private Function json_IsUndefined(ByVal json_Value As Variant) As Boolean
        ' Empty / Nothing -> undefined
        Select Case VBA.VarType(json_Value)
        Case VBA.vbEmpty
            json_IsUndefined = True
        Case VBA.vbObject
            Select Case VBA.TypeName(json_Value)
            Case "Empty", "Nothing"
                json_IsUndefined = True
            End Select
        End Select
    End Function
    
    Private Function json_Encode(ByVal json_Text As Variant) As String
        ' Reference: http://www.ietf.org/rfc/rfc4627.txt
        ' Escape: ", \, /, backspace, form feed, line feed, carriage return, tab
        Dim json_Index As Long
        Dim json_Char As String
        Dim json_AscCode As Long
        Dim json_Buffer As String
        Dim json_BufferPosition As Long
        Dim json_BufferLength As Long
    
        For json_Index = 1 To VBA.Len(json_Text)
            json_Char = VBA.Mid$(json_Text, json_Index, 1)
            json_AscCode = VBA.AscW(json_Char)
    
            ' When AscW returns a negative number, it returns the twos complement form of that number.
            ' To convert the twos complement notation into normal binary notation, add 0xFFF to the return result.
            ' https://support.microsoft.com/en-us/kb/272138
            If json_AscCode < 0 Then
                json_AscCode = json_AscCode + 65536
            End If
    
            ' From spec, ", \, and control characters must be escaped (solidus is optional)
    
            Select Case json_AscCode
            Case 34
                ' " -> 34 -> \"
                json_Char = "\"""
            Case 92
                ' \ -> 92 -> \\
                json_Char = "\\"
            Case 47
                ' / -> 47 -> \/ (optional)
                If JsonOptions.EscapeSolidus Then
                    json_Char = "\/"
                End If
            Case 8
                ' backspace -> 8 -> \b
                json_Char = "\b"
            Case 12
                ' form feed -> 12 -> \f
                json_Char = "\f"
            Case 10
                ' line feed -> 10 -> \n
                json_Char = "\n"
            Case 13
                ' carriage return -> 13 -> \r
                json_Char = "\r"
            Case 9
                ' tab -> 9 -> \t
                json_Char = "\t"
            Case 0 To 31, 127 To 65535
                ' Non-ascii characters -> convert to 4-digit hex
                json_Char = "\u" & VBA.Right$("0000" & VBA.Hex$(json_AscCode), 4)
            End Select
    
            json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
        Next json_Index
    
        json_Encode = json_BufferToString(json_Buffer, json_BufferPosition)
    End Function
    
    Private Function json_Peek(json_String As String, ByVal json_Index As Long, Optional json_NumberOfCharacters As Long = 1) As String
        ' "Peek" at the next number of characters without incrementing json_Index (ByVal instead of ByRef)
        json_SkipSpaces json_String, json_Index
        json_Peek = VBA.Mid$(json_String, json_Index, json_NumberOfCharacters)
    End Function
    
    Private Sub json_SkipSpaces(json_String As String, ByRef json_Index As Long)
        ' Increment index to skip over spaces
        Do While json_Index > 0 And json_Index <= VBA.Len(json_String) And VBA.Mid$(json_String, json_Index, 1) = " "
            json_Index = json_Index + 1
        Loop
    End Sub
    
    Private Function json_StringIsLargeNumber(json_String As Variant) As Boolean
        ' Check if the given string is considered a "large number"
        ' (See json_ParseNumber)
    
        Dim json_Length As Long
        Dim json_CharIndex As Long
        json_Length = VBA.Len(json_String)
    
        ' Length with be at least 16 characters and assume will be less than 100 characters
        If json_Length >= 16 And json_Length <= 100 Then
            Dim json_CharCode As String
    
            json_StringIsLargeNumber = True
    
            For json_CharIndex = 1 To json_Length
                json_CharCode = VBA.Asc(VBA.Mid$(json_String, json_CharIndex, 1))
                Select Case json_CharCode
                ' Look for .|0-9|E|e
                Case 46, 48 To 57, 69, 101
                    ' Continue through characters
                Case Else
                    json_StringIsLargeNumber = False
                    Exit Function
                End Select
            Next json_CharIndex
        End If
    End Function
    
    Private Function json_ParseErrorMessage(json_String As String, ByRef json_Index As Long, ErrorMessage As String)
        ' Provide detailed parse error message, including details of where and what occurred
        '
        ' Example:
        ' Error parsing JSON:
        ' {"abcde":True}
        '          ^
        ' Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['
    
        Dim json_StartIndex As Long
        Dim json_StopIndex As Long
    
        ' Include 10 characters before and after error (if possible)
        json_StartIndex = json_Index - 10
        json_StopIndex = json_Index + 10
        If json_StartIndex <= 0 Then
            json_StartIndex = 1
        End If
        If json_StopIndex > VBA.Len(json_String) Then
            json_StopIndex = VBA.Len(json_String)
        End If
    
        json_ParseErrorMessage = "Error parsing JSON:" & VBA.vbNewLine & _
                                    VBA.Mid$(json_String, json_StartIndex, json_StopIndex - json_StartIndex + 1) & VBA.vbNewLine & _
                                    VBA.Space$(json_Index - json_StartIndex) & "^" & VBA.vbNewLine & _
                                    ErrorMessage
    End Function
    
    Private Sub json_BufferAppend(ByRef json_Buffer As String, _
                                    ByRef json_Append As Variant, _
                                    ByRef json_BufferPosition As Long, _
                                    ByRef json_BufferLength As Long)
        ' VBA can be slow to append strings due to allocating a new string for each append
        ' Instead of using the traditional append, allocate a large empty string and then copy string at append position
        '
        ' Example:
        ' Buffer: "abc  "
        ' Append: "def"
        ' Buffer Position: 3
        ' Buffer Length: 5
        '
        ' Buffer position + Append length > Buffer length -> Append chunk of blank space to buffer
        ' Buffer: "abc       "
        ' Buffer Length: 10
        '
        ' Put "def" into buffer at position 3 (0-based)
        ' Buffer: "abcdef    "
        '
        ' Approach based on cStringBuilder from vbAccelerator
        ' http://www.vbaccelerator.com/home/VB/Code/Techniques/RunTime_Debug_Tracing/VB6_Tracer_Utility_zip_cStringBuilder_cls.asp
        '
        ' and clsStringAppend from Philip Swannell
        ' https://github.com/VBA-tools/VBA-JSON/pull/82
    
        Dim json_AppendLength As Long
        Dim json_LengthPlusPosition As Long
    
        json_AppendLength = VBA.Len(json_Append)
        json_LengthPlusPosition = json_AppendLength + json_BufferPosition
    
        If json_LengthPlusPosition > json_BufferLength Then
            ' Appending would overflow buffer, add chunk
            ' (double buffer length or append length, whichever is bigger)
            Dim json_AddedLength As Long
            json_AddedLength = IIf(json_AppendLength > json_BufferLength, json_AppendLength, json_BufferLength)
    
            json_Buffer = json_Buffer & VBA.Space$(json_AddedLength)
            json_BufferLength = json_BufferLength + json_AddedLength
        End If
    
        ' Note: Namespacing with VBA.Mid$ doesn't work properly here, throwing compile error:
        ' Function call on left-hand side of assignment must return Variant or Object
        Mid$(json_Buffer, json_BufferPosition + 1, json_AppendLength) = CStr(json_Append)
        json_BufferPosition = json_BufferPosition + json_AppendLength
    End Sub
    
    Private Function json_BufferToString(ByRef json_Buffer As String, ByVal json_BufferPosition As Long) As String
        If json_BufferPosition > 0 Then
            json_BufferToString = VBA.Left$(json_Buffer, json_BufferPosition)
        End If
    End Function
    
    ''
    ' VBA-UTC v1.0.6
    ' (c) Tim Hall - https://github.com/VBA-tools/VBA-UtcConverter
    '
    ' UTC/ISO 8601 Converter for VBA
    '
    ' Errors:
    ' 10011 - UTC parsing error
    ' 10012 - UTC conversion error
    ' 10013 - ISO 8601 parsing error
    ' 10014 - ISO 8601 conversion error
    '
    ' @module UtcConverter
    ' @author tim.hall.engr@gmail.com
    ' @license MIT (http://www.opensource.org/licenses/mit-license.php)
    '' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
    
    ' (Declarations moved to top)
    
    ' ============================================= '
    ' Public Methods
    ' ============================================= '
    
    ''
    ' Parse UTC date to local date
    '
    ' @method ParseUtc
    ' @param {Date} UtcDate
    ' @return {Date} Local date
    ' @throws 10011 - UTC parsing error
    ''
    Public Function ParseUtc(utc_UtcDate As Date) As Date
        On Error GoTo utc_ErrorHandling
    
    #If Mac Then
        ParseUtc = utc_ConvertDate(utc_UtcDate)
    #Else
        Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
        Dim utc_LocalDate As utc_SYSTEMTIME
    
        utc_GetTimeZoneInformation utc_TimeZoneInfo
        utc_SystemTimeToTzSpecificLocalTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_UtcDate), utc_LocalDate
    
        ParseUtc = utc_SystemTimeToDate(utc_LocalDate)
    #End If
    
        Exit Function
    
    utc_ErrorHandling:
        Err.Raise 10011, "UtcConverter.ParseUtc", "UTC parsing error: " & Err.Number & " - " & Err.Description
    End Function
    
    ''
    ' Convert local date to UTC date
    '
    ' @method ConvertToUrc
    ' @param {Date} utc_LocalDate
    ' @return {Date} UTC date
    ' @throws 10012 - UTC conversion error
    ''
    Public Function ConvertToUtc(utc_LocalDate As Date) As Date
        On Error GoTo utc_ErrorHandling
    
    #If Mac Then
        ConvertToUtc = utc_ConvertDate(utc_LocalDate, utc_ConvertToUtc:=True)
    #Else
        Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
        Dim utc_UtcDate As utc_SYSTEMTIME
    
        utc_GetTimeZoneInformation utc_TimeZoneInfo
        utc_TzSpecificLocalTimeToSystemTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_LocalDate), utc_UtcDate
    
        ConvertToUtc = utc_SystemTimeToDate(utc_UtcDate)
    #End If
    
        Exit Function
    
    utc_ErrorHandling:
        Err.Raise 10012, "UtcConverter.ConvertToUtc", "UTC conversion error: " & Err.Number & " - " & Err.Description
    End Function
    
    ''
    ' Parse ISO 8601 date string to local date
    '
    ' @method ParseIso
    ' @param {Date} utc_IsoString
    ' @return {Date} Local date
    ' @throws 10013 - ISO 8601 parsing error
    ''
    Public Function ParseIso(utc_IsoString As String) As Date
        On Error GoTo utc_ErrorHandling
    
        Dim utc_Parts() As String
        Dim utc_DateParts() As String
        Dim utc_TimeParts() As String
        Dim utc_OffsetIndex As Long
        Dim utc_HasOffset As Boolean
        Dim utc_NegativeOffset As Boolean
        Dim utc_OffsetParts() As String
        Dim utc_Offset As Date
    
        utc_Parts = VBA.Split(utc_IsoString, "T")
        utc_DateParts = VBA.Split(utc_Parts(0), "-")
        ParseIso = VBA.DateSerial(VBA.CInt(utc_DateParts(0)), VBA.CInt(utc_DateParts(1)), VBA.CInt(utc_DateParts(2)))
    
        If UBound(utc_Parts) > 0 Then
            If VBA.InStr(utc_Parts(1), "Z") Then
                utc_TimeParts = VBA.Split(VBA.Replace(utc_Parts(1), "Z", ""), ":")
            Else
                utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "+")
                If utc_OffsetIndex = 0 Then
                    utc_NegativeOffset = True
                    utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "-")
                End If
    
                If utc_OffsetIndex > 0 Then
                    utc_HasOffset = True
                    utc_TimeParts = VBA.Split(VBA.Left$(utc_Parts(1), utc_OffsetIndex - 1), ":")
                    utc_OffsetParts = VBA.Split(VBA.Right$(utc_Parts(1), Len(utc_Parts(1)) - utc_OffsetIndex), ":")
    
                    Select Case UBound(utc_OffsetParts)
                    Case 0
                        utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), 0, 0)
                    Case 1
                        utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), 0)
                    Case 2
                        ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
                        utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), Int(VBA.Val(utc_OffsetParts(2))))
                    End Select
    
                    If utc_NegativeOffset Then: utc_Offset = -utc_Offset
                Else
                    utc_TimeParts = VBA.Split(utc_Parts(1), ":")
                End If
            End If
    
            Select Case UBound(utc_TimeParts)
            Case 0
                ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), 0, 0)
            Case 1
                ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), 0)
            Case 2
                ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
                ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), Int(VBA.Val(utc_TimeParts(2))))
            End Select
    
            ParseIso = ParseUtc(ParseIso)
    
            If utc_HasOffset Then
                ParseIso = ParseIso - utc_Offset
            End If
        End If
    
        Exit Function
    
    utc_ErrorHandling:
        Err.Raise 10013, "UtcConverter.ParseIso", "ISO 8601 parsing error for " & utc_IsoString & ": " & Err.Number & " - " & Err.Description
    End Function
    
    ''
    ' Convert local date to ISO 8601 string
    '
    ' @method ConvertToIso
    ' @param {Date} utc_LocalDate
    ' @return {Date} ISO 8601 string
    ' @throws 10014 - ISO 8601 conversion error
    ''
    Public Function ConvertToIso(utc_LocalDate As Date) As String
        On Error GoTo utc_ErrorHandling
    
        ConvertToIso = VBA.Format$(ConvertToUtc(utc_LocalDate), "yyyy-mm-ddTHH:mm:ss.000Z")
    
        Exit Function
    
    utc_ErrorHandling:
        Err.Raise 10014, "UtcConverter.ConvertToIso", "ISO 8601 conversion error: " & Err.Number & " - " & Err.Description
    End Function
    
    ' ============================================= '
    ' Private Functions
    ' ============================================= '
    
    #If Mac Then
    
    Private Function utc_ConvertDate(utc_Value As Date, Optional utc_ConvertToUtc As Boolean = False) As Date
        Dim utc_ShellCommand As String
        Dim utc_Result As utc_ShellResult
        Dim utc_Parts() As String
        Dim utc_DateParts() As String
        Dim utc_TimeParts() As String
    
        If utc_ConvertToUtc Then
            utc_ShellCommand = "date -ur `date -jf '%Y-%m-%d %H:%M:%S' " & _
                "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & "' " & _
                " +'%s'` +'%Y-%m-%d %H:%M:%S'"
        Else
            utc_ShellCommand = "date -jf '%Y-%m-%d %H:%M:%S %z' " & _
                "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & " +0000' " & _
                "+'%Y-%m-%d %H:%M:%S'"
        End If
    
        utc_Result = utc_ExecuteInShell(utc_ShellCommand)
    
        If utc_Result.utc_Output = "" Then
            Err.Raise 10015, "UtcConverter.utc_ConvertDate", "'date' command failed"
        Else
            utc_Parts = Split(utc_Result.utc_Output, " ")
            utc_DateParts = Split(utc_Parts(0), "-")
            utc_TimeParts = Split(utc_Parts(1), ":")
    
            utc_ConvertDate = DateSerial(utc_DateParts(0), utc_DateParts(1), utc_DateParts(2)) + _
                TimeSerial(utc_TimeParts(0), utc_TimeParts(1), utc_TimeParts(2))
        End If
    End Function
    
    Private Function utc_ExecuteInShell(utc_ShellCommand As String) As utc_ShellResult
    #If VBA7 Then
        Dim utc_File As LongPtr
        Dim utc_Read As LongPtr
    #Else
        Dim utc_File As Long
        Dim utc_Read As Long
    #End If
    
        Dim utc_Chunk As String
    
        On Error GoTo utc_ErrorHandling
        utc_File = utc_popen(utc_ShellCommand, "r")
    
        If utc_File = 0 Then: Exit Function
    
        Do While utc_feof(utc_File) = 0
            utc_Chunk = VBA.Space$(50)
            utc_Read = CLng(utc_fread(utc_Chunk, 1, Len(utc_Chunk) - 1, utc_File))
            If utc_Read > 0 Then
                utc_Chunk = VBA.Left$(utc_Chunk, CLng(utc_Read))
                utc_ExecuteInShell.utc_Output = utc_ExecuteInShell.utc_Output & utc_Chunk
            End If
        Loop
    
    utc_ErrorHandling:
        utc_ExecuteInShell.utc_ExitCode = CLng(utc_pclose(utc_File))
    End Function
    
    #Else
    
    Private Function utc_DateToSystemTime(utc_Value As Date) As utc_SYSTEMTIME
        utc_DateToSystemTime.utc_wYear = VBA.Year(utc_Value)
        utc_DateToSystemTime.utc_wMonth = VBA.Month(utc_Value)
        utc_DateToSystemTime.utc_wDay = VBA.Day(utc_Value)
        utc_DateToSystemTime.utc_wHour = VBA.Hour(utc_Value)
        utc_DateToSystemTime.utc_wMinute = VBA.Minute(utc_Value)
        utc_DateToSystemTime.utc_wSecond = VBA.Second(utc_Value)
        utc_DateToSystemTime.utc_wMilliseconds = 0
    End Function
    
    Private Function utc_SystemTimeToDate(utc_Value As utc_SYSTEMTIME) As Date
        utc_SystemTimeToDate = DateSerial(utc_Value.utc_wYear, utc_Value.utc_wMonth, utc_Value.utc_wDay) + _
            TimeSerial(utc_Value.utc_wHour, utc_Value.utc_wMinute, utc_Value.utc_wSecond)
    End Function
    
    #End If
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 頻出定数・短コード
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Const strFileFilterCsv As String = "CSVファイル(*.csv),*.csv"
    Const strFileFilterXL As String = "エクセルファイル (*.xls?),*.xls?"
    
    CreateObject("WScript.Shell").CurrentDirectory = "FileServer"                    
                    </pre>
                </div>
            </div>
        </div>
    </main>
    <footer>
        <div class="container">
            <a href="https://twitter.com/office_diet" target="_blank">all right not reserved 24時間散歩おじさん
        </div>
    </footer>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=vbs&skin=sons-of-obsidian"></script>
    <script src="vba.js"></script>
</body>
</html>