<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="vba.css">

    <title>24時間散歩おじさん～VBA汎用コード置き場～</title>
    <meta property="og:url" content="https://office-diet.github.io/vba.html" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="24時間散歩おじさん～VBA汎用コード置き場～" />
    <meta property="og:description" content="24時間散歩おじさん～VBA汎用コード置き場～" />
    <meta property="og:site_name" content="24時間散歩おじさん～VBA汎用コード置き場～" />
    <meta property="og:image" content="https://office-diet.github.io/vba.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@office_diet" />  
</head>
<body>
    <header>
        <div class="container">
            <a href="https://twitter.com/office_diet" target="_blank">24時間散歩おじさん VBA汎用コード置き場</a>
        </div>
    </header>
    <main>
        <div class="container">
            <div class="code-body">
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 最終行・列を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetLastRow(ByVal ws As Worksheet, Optional ByVal strColumn As String = "") As Long
                
        If strColumn = "" Then
            GetLastRow = ws.UsedRange.Cells(ws.UsedRange.Cells.Count).Row
        ElseIf IsNumeric(strColumn) Then
            GetLastRow = ws.Cells(ws.Rows.Count, strColumn * 1).End(xlUp).Row
        Else
            GetLastRow = ws.Cells(ws.Rows.Count, strColumn).End(xlUp).Row
        End If
        
    End Function
    
    Function GetLastColumn(ByVal ws As Worksheet, ByVal lngRow As Long) As Long
        
        GetLastColumn = ws.Cells(lngRow, ws.Columns.Count).End(xlToLeft).Column
        
    End Function
    
    Function SearchLastRow(ByVal ws As Worksheet, aryColumns As Variant)
        Dim vntColumn As Variant
        Dim lngFindLastRow As Long
        For Each vntColumn In aryColumns
            lngFindLastRow = Max(lngFindLastRow, GetLastRow(ws, vntColumn))
        Next
        SearchLastRow = lngFindLastRow
    End Function
    
    Function SearchLastColumn(ByVal ws As Worksheet, aryRows As Variant)
        Dim vntRow As Variant
        Dim lngFindLastColumn As Long
        For Each vntRow In aryRows
            lngFindLastColumn = Max(lngFindLastColumn, GetLastRow(ws, vntRow))
        Next
        SearchLastColumn = lngFindLastColumn
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' MIN・MAX関数をラップ・機能拡張
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '「Min（エクセル関数）」
    Function Min(ParamArray aryValues() As Variant) As Variant
        Min = Application.WorksheetFunction.Min(aryValues)
    End Function
    
    '「Max（エクセル関数）」
    Function Max(ParamArray aryValues() As Variant) As Variant
        Max = Application.WorksheetFunction.Max(aryValues)
    End Function
    
    '絶対値の最小値
    Function MinAbs(ParamArray aryValues() As Variant) As Variant
        
        Dim vntValue As Variant
        Dim vntMin As Variant
        
        vntMin = aryValues(0)
        For Each vntValue In aryValues
            If Abs(vntMin) > Abs(vntValue) Then
                vntMin = vntValue
            End If
        Next
        MinAbs = vntMin
        
    End Function
    
    '絶対値の最大値
    Function MaxAbs(ParamArray aryValues() As Variant) As Variant
        
        Dim vntValue As Variant
        Dim vntMax As Variant
        
        vntMax = aryValues(0)
        For Each vntValue In aryValues
            If Abs(vntMax) < Abs(vntValue) Then
                vntMax = vntValue
            End If
        Next
        MaxAbs = vntMax
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' VLOOKUP関数をラップ・機能拡張
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '文字列・数値の不一致による検索失敗・エラーを回避
    Function VlookUp(ByVal vntKey As Variant, ByVal rngTable As Range, lngColumn As Long) As Variant
        
        Dim vntFindValue As Variant
        
        '引数そのまま検索
        On Error Resume Next
        vntFindValue = Application.WorksheetFunction.VlookUp(vntKey, rngTable, lngColumn, False)
        If Err.Number = 0 Then
            VlookUp = vntFindValue
            Exit Function
        End If
        On Error GoTo 0
        
        '引数を文字列に変換
        On Error Resume Next
        vntFindValue = Application.WorksheetFunction.VlookUp("" & vntKey, rngTable, lngColumn, False)
        If Err.Number = 0 Then
            VlookUp = vntFindValue
            Exit Function
        End If
        On Error GoTo 0
        
        '引数を数値に変換
        On Error Resume Next
        vntFindValue = Application.WorksheetFunction.VlookUp(vntKey * 1, rngTable, lngColumn, False)
        If Err.Number = 0 Then
            VlookUp = vntFindValue
            Exit Function
        End If
        On Error GoTo 0
                
        VlookUp = ""
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' MATCH関数をラップ・機能拡張（検索に活用）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '「Match（エクセル関数）」の拡張
    '※文字列・数値の不一致による検索失敗・エラーを回避
    Function Match(ByVal vntSearchKey As Variant, ByVal rngSearchRange As Range) As Long
        
        Dim lngResult As Long
        
        '引数そのまま検索
        On Error Resume Next
        lngResult = Application.WorksheetFunction.Match(vntSearchKey, rngSearchRange, False)
        If Err.Number = 0 Then
            Match = lngResult
            Exit Function
        End If
        On Error GoTo 0
        
        '引数を文字列変換して検索
        On Error Resume Next
        lngResult = Application.WorksheetFunction.Match("" & vntSearchKey, rngSearchRange, False)
        If Err.Number = 0 Then
            Match = lngResult
            Exit Function
        End If
        On Error GoTo 0
            
        '引数を数値変換して検索
        On Error Resume Next
        lngResult = Application.WorksheetFunction.Match(vntSearchKey * 1, rngSearchRange, False)
        If Err.Number = 0 Then
            Match = lngResult
            Exit Function
        End If
        On Error GoTo 0
            
        Match = 0
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 空のDictionaryを生成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CreateNewDictionary() As Object
        
        Set CreateNewDictionary = CreateObject("Scripting.Dictionary")
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 参照する必要のない列等をグレーアウト＋細くする
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub GrayOutColumns(ByVal wsTarget As Worksheet, ByVal intColumnWidth As Integer, ParamArray aryColumns() As Variant)
        
        With wsTarget
            
            Dim vntColumn As Variant
            For Each vntColumn In aryColumns
                
                .Columns(vntColumn).ColumnWidth = intColumnWidth
                .Columns(vntColumn).Interior.Color = rgbGray
                
            Next
            
        End With
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ヘッダの固定＋シートの最上段を表示
' ※ヘッダの固定時にシートの選択＋最上段の表示が必須！！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'ヘッダの固定
    Sub FreezeHeader(ByVal rngEdgeCell As Range)
        
        Call ScrollToTop(rngEdgeCell.Parent)
        With ActiveWindow
            
            '既存のヘッダ固定を除去
            If .FreezePanes = True Then
                .FreezePanes = False
            End If
            
            '固定する境目のセルを選択⇒固定
            rngEdgeCell.Select
            .FreezePanes = True
        End With
        
    End Sub
    
    'シート最上段を表示
    Sub ScrollToTop(ByVal wsTarget As Worksheet)
        wsTarget.Parent.Activate
        wsTarget.Activate
        Application.Goto Reference:=wsTarget.Range("A1"), Scroll:=True
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' TextJoinの汎用化
' ※「,区切り」「空白無視」
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function TextJoin(ByVal aryValues As Variant, Optional ByVal strDelimiter As String = ",", Optional ByVal blnSkipBlank As Boolean = True)
        TextJoin = Application.WorksheetFunction.TextJoin(strDelimiter, blnSkipBlank, aryValues)
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 列番号⇔列文字変換
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'アルファベット⇒数値
    Function GetColumnNumberFromName(ByVal strColumnName As String) As Long
        GetColumnNumberFromName = ActiveSheet.Columns(strColumnName).Column
    End Function
    
    '数値⇒アルファベット
    Function GetColumnNameFromNumber(ByVal lngColumnNumber As Long) As String
        GetColumnNameFromNumber = Split(ActiveSheet.Columns(lngColumnNumber).Address(False, False), ":")(0)
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 複数条件でインデックス検索
' ※検索対象は5列まで！
' ※インデックスを返却するので注意！！
' 　検索範囲によってインデックスと行・列は一致しません。
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '条件に一致する最初のインデックスを検索する
    Function FindIfs(ByVal rngSearchArea1 As Range, ByVal strSearchKey1 As String, _
                Optional ByVal rngSearchArea2 As Range = Nothing, Optional ByVal strSearchKey2 As String = "", _
                Optional ByVal rngSearchArea3 As Range = Nothing, Optional ByVal strSearchKey3 As String = "", _
                Optional ByVal rngSearchArea4 As Range = Nothing, Optional ByVal strSearchKey4 As String = "", _
                Optional ByVal rngSearchArea5 As Range = Nothing, Optional ByVal strSearchKey5 As String = "") As Variant
        
        '無駄な検索ループを省くためCountIfs関数で存在確認を実行する
        Dim lngFindCount As Long
        
        'キーと範囲を配列に格納
        Dim arySearchKeys As Variant
        Dim arySearchArea As Variant
        
        '引数の数に応じて必要項目を配列に格納
        On Error Resume Next
        If rngSearchArea2 Is Nothing Then
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1)
            arySearchKeys = Array(strSearchKey1)
            arySearchArea = Array(rngSearchArea1)
        ElseIf rngSearchArea3 Is Nothing Then
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1, rngSearchArea2, strSearchKey2)
            arySearchKeys = Array(strSearchKey1, strSearchKey2)
            arySearchArea = Array(rngSearchArea1, rngSearchArea2)
        ElseIf rngSearchArea4 Is Nothing Then
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1, rngSearchArea2, strSearchKey2, rngSearchArea3, strSearchKey3)
            arySearchKeys = Array(strSearchKey1, strSearchKey2, strSearchKey3)
            arySearchArea = Array(rngSearchArea1, rngSearchArea2, rngSearchArea3)
        ElseIf rngSearchArea5 Is Nothing Then
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1, rngSearchArea2, strSearchKey2, rngSearchArea3, strSearchKey3, rngSearchArea4, strSearchKey4)
            arySearchKeys = Array(strSearchKey1, strSearchKey2, strSearchKey3, strSearchKey4)
            arySearchArea = Array(rngSearchArea1, rngSearchArea2, rngSearchArea3, rngSearchArea4)
        Else
            lngFindCount = Application.WorksheetFunction.CountIfs(rngSearchArea1, strSearchKey1, rngSearchArea2, strSearchKey2, rngSearchArea3, strSearchKey3, rngSearchArea4, strSearchKey4, rngSearchArea5, strSearchKey5)
            arySearchKeys = Array(strSearchKey1, strSearchKey2, strSearchKey3, strSearchKey4, strSearchKey5)
            arySearchArea = Array(rngSearchArea1, rngSearchArea2, rngSearchArea3, rngSearchArea4, rngSearchArea5)
        End If
        
        '① Countifs関数で発見されなかったら実行を終了
        '② 対象セル範囲に矛盾があったらエラーのため実行終了
        If lngFindCount = 0 Or Err.Number <> 0 Then
            FindIfs = 0
            Exit Function
        End If
        On Error GoTo 0
        
        Dim intItemIndex As Integer
        Dim lngCellIndex As Long
        
        For lngCellIndex = 1 To rngSearchArea1.Cells.Count
            
            '全件一致確認
            Dim blnMatch As Boolean
            blnMatch = True
            
            'キーワード・範囲配列を順次走査
            For intItemIndex = LBound(arySearchKeys) To UBound(arySearchKeys)
                
                'キーワードと検索対象セルの不一致が発見されたらFalseを設定
                '※エクセル関数の「"<>"（空欄・〇〇ではない）」を指定された場合は別処理
                If arySearchKeys(intItemIndex) = "<>" Then
                    If arySearchArea(intItemIndex).Cells(lngCellIndex).Value = "" Then
                        blnMatch = False
                    End If
                elseIf arySearchKeys(intItemIndex) Like "<>*" Then
                    dim strSearchKey as string
                    strSearchKey = right(arySearchKeys(intItemIndex), len(arySearchKeys(intItemIndex)) - 2)
                    If strSearchKey Like arySearchArea(intItemIndex).Cells(lngCellIndex).Value Then
                        blnMatch = False
                    End If
                Else
                    If Not arySearchKeys(intItemIndex) Like arySearchArea(intItemIndex).Cells(lngCellIndex).Value Then
                        blnMatch = False
                    End If
                End If
            Next
            '全件一致したら発見されたインデックスを返却
            If blnMatch = True Then
                FindIfs = lngCellIndex
                Exit Function
            End If
        Next
        
        FindIfs = 0
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' テキストファイルでメッセージを表示する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub MessageByTextFile(ByVal strMessage As String, Optional ByVal strFileName As String = "MESSAGE_LOG.txt", Optional ByVal blnKillLogFile As Boolean = False)
        
        'ADODB.Stream定数
        Const adTypeBinary As Integer = 1
        Const adTypeText As Integer = 2
        Const adSaveCreateNotExist As Integer = 1
        Const adSaveCreateOverWrite As Integer = 2
        Const adWriteChar As Integer = 0
        Const adWriteLine As Integer = 1
        
        Dim strLogFilePath As String
        strLogFilePath = TextJoinAsPath(ThisWorkbook.Path, strFileName)
        
        'テキストファイルを生成
        Dim objAdoStream As Object
        Set objAdoStream = CreateObject("ADODB.Stream")
        With objAdoStream
            .Type = adTypeText
            .Charset = "UTF-8"
            .Open
            .WriteText strMessage, adWriteLine
            .SaveToFile strLogFilePath, adSaveCreateOverWrite
            .Close
            Set objAdoStream = Nothing
        End With
        
        'テキストファイルを最前面に表示
        Shell ("notepad.exe" & " " & strLogFilePath), vbNormalFocus
        
        'テキストファイルは削除？
        If blnKillLogFile = True Then
            Kill strLogFilePath
        End If
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ★要改造★ ワードを画像出力する基本関数
'
' 参考：https://www.ka-net.org/blog/?p=6505
' ※「Word.Applicationの起動が遅い」「出力ファイル名を収集したい」
'　 「出力画像の重複回避」など必要な機能が多いので要改造！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub ConvertWordToEmf(ByVal strWordFilePath As String)
        
        'ワードアプリケーションの起動（起動が遅いので1回にしたい！）
        Dim objWord As Object
        Set objWord = CreateObject("Word.Application")
        
        'ファイルを開く（パスワード対応も必要）
        Dim objDocument As Object
        Set objDocument = objWord.Documents.Open(strWordFilePath)
        
        'ワードを1ページずつ画像出力
        Dim vntPage As Variant
        For Each vntPage In objDocument.ActiveWindow.ActivePane.Pages
            
            'ページ番号で重複を回避
            '※ただし元ファイルが多い場合は上書きしてしまう！
            Dim intPage As Integer
            intPage = intPage + 1
            
            With CreateObject("ADODB.Stream")
                .Type = 1   'adTypeBinary = 1
                .Open
                .Position = 0
                .Write vntPage.EnhMetaFileBits
                .SaveToFile ThisWorkbook.Path & "\Page_" & intPage & ".emf", 2
                .Close
            End With
            
        Next
        
        'ファイル・アプリを閉じて終了
        objDocument.Close
        objWord.Quit
        Set objDocument = Nothing
        Set objWord = Nothing
        
    End Sub
                                
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' EMFファイルをグラフに張り付け画像として保存
' ※画像加工用シートは「表示倍率100%」が必須！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function EmfToJpg(ByVal strEmfPath As String, ByVal strExportPath As String, ByVal wsGraph As Worksheet, Optional ByVal intDefaultWidth As Integer = 1200) As Variant
        
        Dim aryResultSizes(3) As Integer
        
        '元画像のサイズを取得
        Dim objPicture As Object
        Set objPicture = LoadPicture(strEmfPath)
        Dim sglWidth As Single
        Dim sglHeight As Single
        
        sglWidth = objPicture.width
        sglHeight = objPicture.height
        aryResultSizes(0) = sglWidth
        aryResultSizes(1) = sglHeight
        
        '横幅を基準にサイズ調整
        sglHeight = Int(sglHeight / sglWidth * intDefaultWidth)
        sglWidth = Int(sglWidth / sglWidth * intDefaultWidth)
        
        aryResultSizes(2) = sglWidth
        aryResultSizes(3) = sglHeight
        
        '画像加工用シートは「表示倍率100%」が必須！
        Dim objChart As Object
        Set objChart = wsGraph.ChartObjects.Add(0, 0, Int(sglWidth * 0.75), Int(sglHeight * 0.75)).Chart
        
        With objChart
            .SetBackgroundPicture strEmfPath
            .Parent.ShapeRange.Fill.TextureTile = False
            .Export strExportPath
            .Parent.Delete
        End With
        
        Set objPicture = Nothing
        Set objChart = Nothing
        
        EmfToJpg = aryResultSizes
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
Option Explicit

'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' WINAPIを使用して画像サイズを取得する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Private Declare PtrSafe Function GdiplusStartup Lib "gdiplus" ( _
                                            ByRef token As LongPtr, _
                                            ByRef inputBuf As GdiplusStartupInput, _
                                            ByVal outputBuf As Long) As Long
    Private Declare PtrSafe Sub GdiplusShutdown Lib "gdiplus" ( _
                                            ByVal token As LongPtr)
    Private Declare PtrSafe Function GdipLoadImageFromFile Lib "gdiplus" ( _
                                            ByVal FileName As LongPtr, _
                                            ByRef image As LongPtr) As Long
    Private Declare PtrSafe Function GdipGetImageDimension Lib "gdiplus" ( _
                                            ByVal image As LongPtr, _
                                            ByRef width As Single, _
                                            ByRef height As Single) As Long
    Private Type GdiplusStartupInput
        GdiplusVersion As Long
        DebugEventCallback As LongPtr
        SuppressBackgroundThread As Long
        SuppressExternalCodecs As Long
    End Type
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ファイルを参照し幅・高さを返却
' ※変数の参照を受け取り、値を格納して返却する。
' 　返り値は成否
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetImageSize(ByVal sImageFilePath As String, ByRef width As Single, ByRef height As Single) As Boolean
        
        Dim uGdiStartupInput As GdiplusStartupInput
        Dim nGdiToken As LongPtr
        Dim nStatus As Long
        Dim hImage As LongPtr
        
        GetImageSize = False
        
        uGdiStartupInput.GdiplusVersion = 1
        nStatus = GdiplusStartup(nGdiToken, uGdiStartupInput, 0&)
        If nStatus = 0 Then
            nStatus = GdipLoadImageFromFile(ByVal StrPtr(sImageFilePath), hImage)
            If nStatus = 0 Then
                nStatus = GdipGetImageDimension(hImage, width, height)
                If nStatus = 0 Then
                    GetImageSize = True
                End If
            End If
            Call GdiplusShutdown(nGdiToken)
        End If
    End Function
    
    '**********************************************
    ' 対象セルにファイルパスを記入すると同時にコメントに画像を挿入
    '**********************************************
    Function AddImageComment(ByVal strFilePath As String, ByVal rngTargetCell As Range, Optional ByVal blnOverWrite As Boolean = False) As Boolean
        
        '本関数途中終了は「エラー」
        AddImageComment = False
                
        'ファイルの存在確認
        '※ファイルが存在しなかったらエラーのまま終了
        If CreateObject("Scripting.FileSystemObject").FileExists(strFilePath) = True Then
            
            '画像サイズを受け取る変数
            Dim sglWidth As Single
            Dim sglHeight As Single
            
            '画像ファイルのデータ取得に失敗したら途中終了
            If GetImageSize(strFilePath, sglWidth, sglHeight) = False Then
                Exit Function
            End If
            
            '対象セルの加工
            With rngTargetCell
                
                '「要上書き」の場合はファイルパスをセルに記入
                If blnOverWrite = True Then
                    .Value = strFilePath
                End If
                
                'コメントがすでに存在する場合は削除
                On Error Resume Next
                .Comment.Delete
                On Error GoTo 0
                
                '画像縦横の最大値を取得
                Dim intMax As Integer
                intMax = Application.WorksheetFunction.Max(sglHeight, sglWidth)
                
                '画像の最大値が上限を超えていた場合は調整
                Const intMaxImageSize As Integer = 300
                If intMax > intMaxImageSize Then
                    If sglHeight > sglWidth Then
                        sglWidth = sglWidth * intMaxImageSize / sglHeight
                        sglHeight = intMaxImageSize
                    Else
                        sglHeight = sglHeight * intMaxImageSize / sglWidth
                        sglWidth = intMaxImageSize
                    End If
                End If
                
                'コメントに画像を表示⇒コメントのサイズを画像に合わせる
                .AddComment.Shape.Fill.UserPicture strFilePath
                .Comment.Shape.width = sglWidth
                .Comment.Shape.height = sglHeight
                
            End With
            
            '関数成功なのでTrue
            AddImageComment = True
            
        End If
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列のバイト数を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetLenB(ByVal strText As String) As Integer
        
        GetLenB = LenB(StrConv(strText, vbFromUnicode))
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' シートを名称の部分一致で取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '定数
    Const intHeadMatch As Integer = 0
    Const intMidMatch As Integer = 1
    Const intEndMatch As Integer = 2
    
    Function SearchWorksheet(ByVal strWorksheetBaseName As String, ByVal intMatchType As Integer) As Worksheet
        
        '先頭一致・中間一致・末尾一致
        Dim strSearchKey As String
        If intMatchType = intHeadMatch Then
            strSearchKey = strWorksheetBaseName & "*"
        ElseIf intMatchType = intMidMatch Then
            strSearchKey = "*" & strWorksheetBaseName & "*"
        Else
            strSearchKey = "*" & strWorksheetBaseName
        End If
        
        '部分一致（Like）で検索
        Dim ws As Variant
        For Each ws In ThisWorkbook.Worksheets
            If ws.Name Like strSearchKey Then
                Set SearchWorksheet = ws
                Exit Function
            End If
        Next
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 選択範囲がすべて空欄か？
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function IsBlank(ByVal rngSelectArea As Range) As Boolean
        If Application.WorksheetFunction.TextJoin("", True, rngSelectArea) = "" Then
            IsBlank = True
        Else
            IsBlank = False
        End If
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ランダム・無意味な文字列を生成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
        
    Const intAllChar As Integer = 0
    Const intAlphabetsOnly As Integer = 1
    Const intUpperAlphabetsOnly As Integer = 2
    Const intLowerAlphabetsOnly As Integer = 3
    Const intUpperOnly As Integer = 4
    Const intLowerOnly As Integer = 5
    Const intNumberOnly As Integer = 6
    
    Function MakeRandomString(ByVal intStringLength As Integer, Optional ByVal intType As Integer = 0) As String
        
        '元となる文字
        Const strUpperAlphabets As String = "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,U,R,T,U,V,W,X,Y,Z"
        Const strLowerAlphabets As String = "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z"
        Const strNumbers As String = "0,1,2,3,4,5,6,7,8,9"
        
        '文字を分割し格納する配列
        Dim aryCharacters As Variant
        
        '使用する文字種類の分岐
        Select Case intType
            Case intAlphabetsOnly
                aryCharacters = Split(strUpperAlphabets & "," & strLowerAlphabets, ",")
            Case intUpperAlphabetsOnly
                aryCharacters = Split(strUpperAlphabets, ",")
            Case intLowerAlphabetsOnly
                aryCharacters = Split(strLowerAlphabets, ",")
            Case intUpperOnly
                aryCharacters = Split(strUpperAlphabets & "," & strNumbers, ",")
            Case intLowerOnly
                aryCharacters = Split(strLowerAlphabets & "," & strNumbers, ",")
            Case intNumberOnly
                aryCharacters = Split(strNumbers, ",")
            Case Else
                aryCharacters = Split(strUpperAlphabets & "," & strLowerAlphabets & "," & strNumbers, ",")
        End Select
        
        Dim strResult As String
        Dim intCharacterCount As Integer
        Dim intRandomIndex As Integer
        
        '配列からランダムに文字を取得する
        For intCharacterCount = 1 To intStringLength
            Randomize
            intRandomIndex = Application.WorksheetFunction.RandBetween(LBound(aryCharacters), UBound(aryCharacters))
            strResult = strResult + aryCharacters(intRandomIndex)
        Next
        
        '生成されたランダム文字列を返却
        MakeRandomString = strResult
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 単純な暗号化処理
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '変換DictionaryのKey
    Const strENCRYPT As String = "ENCRYPT"
    Const strDECRYPT As String = "DECRYPT"
    Const strHead As String = "HEAD"
    
    '******************************************
    ' 暗号化例
    '******************************************
    Sub EncryptTest()
        
        Dim dctCipher As Object
        Set dctCipher = GetCipherDictionary()
        
        Dim intIndex As Integer
        For intIndex = 12300 To 12320
            
            Dim strOriginText As String
            Dim strEncryptText As String
            Dim strDecryptText As String
            strOriginText = Format(intIndex, "00000000")
            strEncryptText = EncryptString(strOriginText, dctCipher)
            strDecryptText = DecryptString(strEncryptText, dctCipher)
            
            Debug.Print strOriginText & " ⇒ " & strEncryptText & " ⇒ " & strDecryptText
            
        Next
        
    End Sub
    
    '******************************************
    ' 暗号・復号に使用するDictionary
    '******************************************
    Function GetCipherDictionary()
        
        Dim aryEncrypt As Variant
        Dim aryDecrypt As Variant
        Dim aryHead As Variant
        aryEncrypt = Split("0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z", ",")
        aryDecrypt = Split("a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,0,1,2,3,4,5,6,7,8,9", ",")
        aryHead = Split("a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z", ",")
        
        Dim dctCipher As Object
        Set dctCipher = CreateObject("Scripting.Dictionary")
        
        dctCipher.Add strENCRYPT, CreateObject("Scripting.Dictionary")
        dctCipher.Add strDECRYPT, CreateObject("Scripting.Dictionary")
        dctCipher.Add strHead, aryHead
        
        Dim intIndex As Integer
        For intIndex = LBound(aryEncrypt) To UBound(aryEncrypt)
            dctCipher(strENCRYPT).Add aryEncrypt(intIndex), aryDecrypt(intIndex)
            dctCipher(strDECRYPT).Add aryDecrypt(intIndex), aryEncrypt(intIndex)
        Next
        
        Set GetCipherDictionary = dctCipher
        
    End Function
    
    '******************************************
    ' 暗号化関数
    '******************************************
    Function EncryptString(ByVal strOrigin As String, ByRef dctCipher As Object) As String
        
        '「変換回数」「ランダムノイズ」をルールを決定
        Dim intHint As Integer
        intHint = Application.WorksheetFunction.RandBetween(1, 9)
        
        strOrigin = StrReverse(strOrigin)
        
        Dim intIndex As Integer
        For intIndex = 1 To Len(strOrigin)
            
            '1文字取り出し
            Dim strChar As String
            strChar = Mid(strOrigin, intIndex, 1)
            
            '変換を「変換回数」分繰り返す
            Dim intEncryptCount As Integer
            For intEncryptCount = 1 To intIndex * intHint
                strChar = dctCipher(strENCRYPT)(strChar)
            Next
            
            '変換結果を連結
            Dim strResult As String
            strResult = strResult & strChar
            
        Next
        
        'ノイズを混合する
        For intIndex = 1 To Len(strResult)
            
            '1文字取り出し
            strChar = Mid(strResult, intIndex, 1)
            
            'ノイズ文字
            Dim strRandom As String
            strRandom = GetRandom(dctCipher)
            
            'ヒントに応じて「ノイズの前後関係」を切替
            Dim strMixResult As String
            If intHint Mod 2 = 0 Then
                strMixResult = strMixResult & strChar & strRandom
            Else
                strMixResult = strMixResult & strRandom & strChar
            End If
            
        Next
        
        '変換回数を末尾に追加
        EncryptString = strMixResult & intHint
        
    End Function
    
    '******************************************
    ' 復号関数
    '******************************************
    Function DecryptString(ByVal strOrigin As String, ByRef dctCipher As Object) As String
        
        '末尾1桁から「変換回数」「ランダムノイズ」をルールを判別
        Dim intHint As Integer
        intHint = Right(strOrigin, 1)
        
        '文字列を切り抜き
        strOrigin = Left(strOrigin, Len(strOrigin) - 1)
        
        Dim intIndex As Integer
        For intIndex = 1 To Len(strOrigin)
            
            '1文字取り出し
            Dim strChar As String
            strChar = Mid(strOrigin, intIndex, 1)
            
            'ノイズ以外の文字を取り出し
            If intHint Mod 2 = 0 And intIndex Mod 2 = 1 Then
                Dim strPickUp As String
                strPickUp = strPickUp & strChar
            ElseIf intHint Mod 2 = 1 And intIndex Mod 2 = 0 Then
                strPickUp = strPickUp & strChar
            End If
            
        Next
        
        For intIndex = 1 To Len(strPickUp)
            
            '1文字取り出し
            strChar = Mid(strPickUp, intIndex, 1)
            
            '変換を「変換回数」分繰り返す
            Dim intDecryptCount As Integer
            For intDecryptCount = 1 To intIndex * intHint
                strChar = dctCipher(strDECRYPT)(strChar)
            Next
            
            '文字列を連結
            Dim strResult As String
            strResult = strResult & strChar
            
        Next
        
        '復号済みの文字列を返却
        DecryptString = StrReverse(strResult)
        
    End Function
    
    '******************************************
    ' ランダムノイズを混ぜる
    '******************************************
    Function GetRandom(ByRef dctCipher As Object) As String
        Dim intRandom As Integer
        intRandom = Application.WorksheetFunction.RandBetween(LBound(dctCipher(strHead)), UBound(dctCipher(strHead)))
        GetRandom = dctCipher(strHead)(intRandom)
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 指定したセル範囲の完全一致を確認
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CompareRange(ByVal rngAnwer As Range, ByVal rngCorrect As Range) As Boolean
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '行数・列数の一致確認
        If rngAnwer.Rows.Count <> rngCorrect.Rows.Count Or rngAnwer.Columns.Count <> rngCorrect.Columns.Count Then
            CompareRange = False
            Exit Function
        End If
        
        '指定範囲内の同位置セルの一致を確認
        For lngRow = 1 To rngAnwer.Rows.Count
            For lngColumn = 1 To rngAnwer.Columns.Count
                If rngAnwer.Cells(lngRow, lngColumn).Value <> rngCorrect.Cells(lngRow, lngColumn).Value Then
                    CompareRange = False
                    Exit Function
                End If
            Next
        Next
        
        CompareRange = True
    
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 2つのセルの差分を強調表示
' ※blnBlankSkip = Trueで「空白の不一致は無視」
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CompareColoringCellsLCS(ByVal rngA As Range, ByVal rngB As Range, Optional ByVal blnBlankSkip As Boolean = True) As Boolean
        
        '「本関数通過」は一致
        CompareColoringCellsLCS = True
        
        '「完全一致」は終了
        If rngA.Value = rngB.Value Then
            Exit Function
        End If
        
        '文字列を変数に格納
        Dim strTextA As String
        Dim strTextB As String
        strTextA = StrConv(rngA.Value, vbWide)
        strTextB = StrConv(rngB.Value, vbWide)
        
        '「index:0」を利用する
        Dim aryLcsMatrix() As Integer
        ReDim aryLcsMatrix(Len(strTextA), Len(strTextB))
        
        '「index0 = 0」を仕様して加算するため1スタート
        Dim intA As Integer
        Dim intB As Integer
        For intA = 1 To Len(strTextA)
            For intB = 1 To Len(strTextB)
                If SimpleConvert(Mid(strTextA, intA, 1)) = SimpleConvert(Mid(strTextB, intB, 1)) Then
                    aryLcsMatrix(intA, intB) = aryLcsMatrix(intA - 1, intB - 1) + 1
                Else
                    aryLcsMatrix(intA, intB) = Application.WorksheetFunction.Max(aryLcsMatrix(intA - 1, intB), aryLcsMatrix(intA, intB - 1))
                End If
            Next
        Next
        
        ' LCSを末尾から追跡して不一致部分をハイライト
        intA = Len(strTextA)
        intB = Len(strTextB)
        Do While intA > 0 And intB > 0
            
            '文字が一致したらMatrixを左上に
            If SimpleConvert(Mid(strTextA, intA, 1)) = SimpleConvert(Mid(strTextB, intB, 1)) Then
                
                If Mid(strTextA, intA, 1) <> Mid(strTextB, intB, 1) Then
                    rngA.Characters(intA, 1).Font.Color = rgbBlue
                    rngB.Characters(intB, 1).Font.Color = rgbBlue
                End If
                
                intA = intA - 1
                intB = intB - 1
            
            '一致しなかった場合Matrix内の「大きな数字」にそって移動
            '※一致してい文字が見つかるまで
            ElseIf aryLcsMatrix(intA - 1, intB) >= aryLcsMatrix(intA, intB - 1) Then
                
                Dim strChar As String
                strChar = rngA.Characters(intA, 1).Text
                
                If (strChar = "　" Or strChar = " ") And blnBlankSkip = True Then
                    '空白は無視
                Else
                    rngA.Characters(intA, 1).Font.Color = rgbRed
                    CompareColoringCellsLCS = False
                End If
                intA = intA - 1
                
            Else
                
                strChar = rngB.Characters(intB, 1).Text
                
                If (strChar = "　" Or strChar = " ") And blnBlankSkip = True Then
                    '空白は無視
                Else
                    rngB.Characters(intB, 1).Font.Color = rgbRed
                    CompareColoringCellsLCS = False
                End If
                intB = intB - 1
                
            End If
            
        Loop
        
        ' 残りの文字はすべて「一致していない」
        Do While intA > 0
            strChar = rngA.Characters(intA, 1).Text
            If (strChar = "　" Or strChar = " ") And blnBlankSkip = True Then
                '空白は無視
            Else
                rngA.Characters(intA, 1).Font.Color = rgbRed
                CompareColoringCellsLCS = False
            End If
            intA = intA - 1
        Loop
        
        Do While intB > 0
            strChar = rngB.Characters(intB, 1).Text
            If (strChar = "　" Or strChar = " ") And blnBlankSkip = True Then
                '空白は無視
            Else
                rngB.Characters(intB, 1).Font.Color = rgbRed
                CompareColoringCellsLCS = False
            End If
            intB = intB - 1
        Loop
        
    End Function
    
    '***********************************************
    ' 住所表示等で良くある文字を変換
    ' ※必要に応じてテーブルを活用した変換に修正せよ！
    '***********************************************
    Function SimpleConvert(ByVal strChar As String) As String
        
        Dim strResult As String
        strResult = strChar
        strResult = StrConv(strResult, vbWide)
        strResult = StrConv(strResult, vbUpperCase)
        strResult = Replace(strResult, "一", "１")
        strResult = Replace(strResult, "二", "２")
        strResult = Replace(strResult, "三", "３")
        strResult = Replace(strResult, "四", "４")
        strResult = Replace(strResult, "五", "５")
        strResult = Replace(strResult, "六", "６")
        strResult = Replace(strResult, "七", "７")
        strResult = Replace(strResult, "八", "８")
        strResult = Replace(strResult, "九", "９")
        SimpleConvert = strResult
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' セル内の指定文字列を着色
' ※重複未対応
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub ColoringTargetTextInCell(ByVal strTargetText As String, ByVal rngTarget As Range, Optional ByVal lngColor As Long = rgbRed, Optional ByVal blnBold As Boolean = True)
        
        '相手セル内に自セル内のキーワードが存在しなかったら
        If InStr(rngTarget.Value, strTargetText) > 0 Then
            
            '自セル内の着色すべき文字範囲を特定
            Dim intStartIndex As Integer
            Dim intLength As Integer
            intStartIndex = InStr(rngTarget.Value, strTargetText)
            intLength = Len(strTargetText)
            
            '自セル内の文字列の指定範囲を着色
            rngTarget.Characters(Start:=intStartIndex, Length:=intLength).Font.Color = lngColor
            rngTarget.Characters(Start:=intStartIndex, Length:=intLength).Font.Bold = blnBold
            
        End If
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' セル・文字色を設定
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function SetCellColor(ByVal rngTarget As Range, ByVal lngFontColor As Long, ByVal lngCellColor As Long, Optional ByVal blnBold As Boolean = True)
        With rngTarget
            .Interior.Color = lngCellColor
            .Font.Color = lngFontColor
            .Font.Bold = blnBold
        End With
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' エラーのセルが存在するか？
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function IsExistsErrorCell(ByVal rngTarget As Range, Optional ByVal blnSelectErrorCell As Boolean = False) As Boolean
        
        Dim rngCell As Range
        For Each rngCell In rngTarget
            
            'エラーセルが一つでも存在したら「あり」
            If IsError(rngCell) = True Then
                
                '「エラーセルを選択」する場合
                If blnSelectErrorCell = True Then
                    
                    '対象シートが表示されているとは限らないためエラー回避
                    On Error Resume Next
                    rngCell.Select
                    Application.Goto rngCell, True
                    On Error GoTo 0
                End If
                
                IsExistsErrorCell = True
                Exit Function
            End If
        Next
        
        'エラーが発見されなかったら「なし」
        IsExistsErrorCell = False
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Replaceのコーディングを簡略化
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ReplaceCellString(ByVal rngCell As Range, ByVal strPlaceHolder As String, ByVal strReplace As String) As Boolean
        
        rngCell.Value = Replace(rngCell.Value, strPlaceHolder, strReplace)
        
'        '置換が実行されたか否か返却
'        If InStr(rngCell.Value, strReplace) > 0 Then
'            ReplaceCellString = False
'        Else
'            ReplaceCellString = True
'        End If
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'　VBE上で表示出来ない「①の亜種」を「①（一般的な文字）」に置換
'　※「①の亜種」は「VBEで表示出来ない」だけで「変数への格納」や「比較」などの使用は出来る。
'　　ただし「人間には判別できな不一致」等を混入させないために置換推奨！！
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ReplaceCircleNumber(ByVal strOrigin As String) As String
            
            Dim aryReplacePairs As Variant
            aryReplacePairs = Array( _
                                Array(10112, 9312), _
                                Array(9461, 9312), _
                                Array(9462, 9313), _
                                Array(9463, 9314), _
                                Array(9464, 9315), _
                                Array(9465, 9316), _
                                Array(9466, 9317), _
                                Array(9467, 9318), _
                                Array(9468, 9319), _
                                Array(9469, 9320), _
                                Array(9470, 9321))
            
            Dim vntReplacePair As Variant
            For Each vntReplacePair In aryReplacePairs
                strOrigin = Replace(strOrigin, ChrW(vntReplacePair(0)), ChrW(vntReplacePair(1)))
            Next
            
            ReplaceCircleNumber = strOrigin
            
        End Function                
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　空白なのに、謎の値が入っているセルの中身を削除
'　※空白なのにCtrl+方向キーで停止しないセル
'　※SQLや各種マクロのエラーの原因
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ClearGhostCell(wsGhostCellCheck)
        
        Dim rngCell As Range
        
        For Each rngCell In wsGhostCellCheck.UsedRange.Cells
            
            If rngCell.Value = "" Then
                rngCell.ClearContents
            End If
            
        Next
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Keyとなるコードに【数値】【文字列】が混在した場合の補助関数
' ※「数値 or 文字列判定」未実装。すべて数値に変換する前提で作成。
' ※「数値 or 文字列判定」を実装する場合には、WorksheetFunction.IsNumber関数を使用する！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*****************************************
    'セル範囲を一気に「文字列⇒数値」変換
    '*****************************************
    Function RangeTextToNumber(rng As Range)
        rng.TextToColumns FieldInfo:=Array(1, xlGeneralFormat)
    End Function
    
    '*****************************************
    'セル範囲を一気に「数値⇒文字列」変換
    '*****************************************
    Function RangeNumberToText(rng As Range)
        rng.TextToColumns FieldInfo:=Array(1, xlTextFormat)
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ユニークな文字列（Key）を収集(KeyとValueの区別も可能)
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CollectUnique(ByVal rngKeyCells As Range, Optional ByVal rngValueCells As Range) As Object
        
        '値範囲が未指定だった場合、Key範囲を値範囲とみなす
        If rngValueCells Is Nothing Then
            Set rngValueCells = rngKeyCells
        End If
        
        'Dictionaryを生成
        Dim dctUnique As Object
        Set dctUnique = CreateObject("Scripting.Dictionary")
        
        '行範囲・列範囲料対応
        Dim lngRow As Long
        Dim lngColumn As Long
        
        For lngRow = LBound(rngKeyCells.Value, 1) To UBound(rngKeyCells.Value, 1)
            For lngColumn = LBound(rngKeyCells.Value, 2) To UBound(rngKeyCells.Value, 2)
                
                '重複確認を行いながら、UniqueなKeyを収集
                If dctUnique.exists(rngKeyCells.Cells(lngRow, lngColumn).Value) = False And rngKeyCells.Cells(lngRow, lngColumn).Value <> "" Then
                    dctUnique.Add rngKeyCells.Cells(lngRow, lngColumn).Value, rngValueCells.Cells(lngRow, lngColumn).Value
                End If
            Next
        Next
        
        Set CollectUnique = dctUnique
        
    End Function                    
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 対象範囲内のユニークを数える
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CountUnique(ByVal rngCells As Range, Optional ByVal blnCountBlank As Boolean = False)
        
        'Dictionaryにユニークを収集
        Dim dctUnique As Object
        Set dctUnique = CreateObject("Scripting.Dictionary")
        
        Dim vntCell As Range
        Dim intBlankExists As Integer
        
        '対象範囲全セルを走査
        For Each vntCell In rngCells
            
            '空欄が、無い=0、存在=1
            If vntCell.Value = "" Then
                intBlankExists = 1
            Else
                
                '重複無く収集
                If dctUnique.Exists(vntCell.Value) = False Then
                    dctUnique.Add vntCell.Value, vntCell.Value
                End If
            End If
        Next
        
        '空欄を数えるか否かで数値変更
        If blnCountBlank = True Then
            CountUnique = dctUnique.Count + intBlankExists
        Else
            CountUnique = dctUnique.Count
        End If
        
    End Function     
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文章中に指定した文字列が出現する回数を数える
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CountString(ByVal strOrigin As String, ByVal strSearchKey As String) As Integer
        
        Dim strReplace As String
        
        strReplace = Replace(strOrigin, strSearchKey, "")
        CountString = (Len(strOrigin) - Len(strReplace)) / Len(strSearchKey)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列中の前後スペース・ダブルスペースを削除
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function DeleteSpace(ByVal strOrigin As String, ByVal intType As vbWideOrNarrow) As String
        
        'ツール内では一旦半角スペースを基準に処理
        Const strSingleSpace As String = " "
        Const strDoubleSpace As String = "  "
        Const strWideSpace As String = "　"
        
        Dim strResult As String
        strResult = Replace(Trim(strOrigin), "　", " ")
        If InStr(strResult, strDoubleSpace) <> 0 Then
            
            'ダブルスペースがなくなるまでループ
            Do While InStr(strResult, strDoubleSpace) <> 0
                strResult = Replace(strResult, strDoubleSpace, strSingleSpace)
            Loop
        End If
        
        If intType = vbWide Then
            strResult = Replace(strResult, strSingleSpace, strWideSpace)
        End If
        
        DeleteSpace = strResult
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 選択パターン数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

    Function CountChoicePattern(ByVal lngNumber As Long, Optional ByVal blnCountChoiceNone = False) As Long
        
        Dim intPickUpCount As Integer
        Dim lngChoicePatternTotal As Long
        
        For intPickUpCount = 1 To lngNumber
            lngChoicePatternTotal = lngChoicePatternTotal + Application.WorksheetFunction.Combin(lngNumber, intPickUpCount)
        Next
        
        If blnCountChoiceNone = True Then
            CountChoicePattern = lngChoicePatternTotal + 1
        Else
            CountChoicePattern = lngChoicePatternTotal
        End If
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 正規表現Replace関数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ReplaceRegExp(ByVal strOrigin As String, ByVal strRegExp As String, ByVal strReplace As String) As String
        
        Dim objRegExp As Object
        Set objRegExp = CreateObject("VBScript.RegExp")
        
        With objRegExp
            
            .Pattern = strRegExp
            .Global = True
            ReplaceRegExp = .Replace(strOrigin, strReplace)
            
        End With
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 正規表現にマッチした文字列を抽出
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function PickUpRegExp(ByVal strOrigin As String, ByVal strRegExp As String) As String
        
        Dim objRegExp As Object
        Set objRegExp = CreateObject("VBScript.RegExp")
        
        With objRegExp
            .Pattern = strRegExp
            .Global = False
            
            On Error Resume Next
            PickUpRegExp = .Execute(strOrigin)(0).Value
            On Error GoTo 0
            
        End With
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 正規表現にマッチする数をカウント
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CountRegExp(ByVal strOrigin As String, ByVal strRegExp As String) As Long
        
        Dim ojbRegExp As Object
        Set ojbRegExp = CreateObject("VBScript.RegExp")
        
        With ojbRegExp
            .Pattern = strRegExp
            .IgnoreCase = True
            .Global = True
            CountRegExp = .Execute(strOrigin).Count
        End With
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 正規表現にマッチするパターンが文字列の中に含まれるか？
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function IncludeRegExp(ByVal strOrigin As String, ByVal strRegExp As String) As Boolean
        
        Dim objRegExp As Object
        Set objRegExp = CreateObject("VBScript.RegExp")
        
        With objRegExp
            
            .Pattern = strRegExp
            .Global = True
            
            If .Execute(strOrigin).Count > 0 Then
                IncludeRegExp = True
            Else
                IncludeRegExp = False
            End If
        End With
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Colorプロパティの「数値」からRGB分解・計算
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetRGB(ByVal lngColor As Long) As Variant
        
        Dim intR As Integer
        Dim intG As Integer
        Dim intB As Integer
        intR = lngColor Mod 256
        intG = ((lngColor Mod 256 ^ 2) - intB) / 256
        intB = Int(lngColor / (256 ^ 2))
        
        GetRGB = Array(intR, intG, intB)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 色を16進数⇔10進数変換
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '16進数⇒10進数
    Function ColorHexToLong(ByVal strHexColor As String) As Long
        
        If Left(strHexColor, 1) = "#" Then
            strHexColor = Mid(strHexColor, 2, Len(strHexColor) - 1)
        ElseIf strHexColor = "" Then
            strHexColor = "ffffff"
        End If
        
        If Len(strHexColor) = 3 Then
            Dim strR As String
            Dim strG As String
            Dim strB As String
            strR = Left(strHexColor, 1)
            strG = Mid(strHexColor, 2, 1)
            strB = Right(strHexColor, 1)
        Else
            strR = Left(strHexColor, 2)
            strG = Mid(strHexColor, 3, 2)
            strB = Right(strHexColor, 2)
        End If
        
        '※RGBをBGRに並べ替える必要あり！！
        strHexColor = strB & strG & strR
        
        ColorHexToLong = CLng("&H" & strHexColor)
        
    End Function
    
    '10進数⇒16進数
    Function ColorLongToHex(ByVal lngColor As Long) As String
        
        Dim intBlue As Integer
        Dim intGreen As Integer
        Dim intRed As Integer
        
        intBlue = Application.WorksheetFunction.RoundDown(lngColor / (256 ^ 2), 0)
        lngColor = lngColor Mod (256 ^ 2)
        intGreen = Application.WorksheetFunction.RoundDown(lngColor / 256, 0)
        intRed = lngColor Mod 256
        
        ColorLongToHex = Right("0" & Hex(intRed), 2) & Right("0" & Hex(intGreen), 2) & Right("0" & Hex(intBlue), 2)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 年度を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetYearPeriod(ByVal dteTarget As Date) As String
        If Month(dteTarget) < 4 Then
            GetYearPeriod = Format(Year(dteTarget) - 1, "0000年度")
        Else
            GetYearPeriod = Format(Year(dteTarget), "0000年度")
        End If
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 月次で変更されるシート名を生成
' ※「年度（「P」eriod）」「年（「Y」ear）」「月（「M」onth）」
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ReplaceDateName(ByVal strOrigin As String, ByVal dteTargetMonth As Date) As String
        
        '置換に使用するPlaceHolder
        Const strStar As String = "★"
        Dim aryPlaceHolders As Variant
        aryPlaceHolders = Array("YY", "YYYY", "M", "MM", _
                                "YYM", "YYMM", "YYYYM", "YYYYMM", _
                                "YYMD", "YYMMDD", "YYYYMd", "YYYYMMDD")
        Dim strResult As String
        strResult = strOrigin
        
        '一般的な表記パターンを総当たりで置換
        Dim vntPlaceHolder As Variant
        For Each vntPlaceHolder In aryPlaceHolders
            
            'PlaceHolder大文字
            strResult = Replace(strResult, _
                                strStar & vntPlaceHolder & strStar, _
                                Format(dteTargetMonth, vntPlaceHolder))
                                
            'PlaceHolder小文字
            strResult = Replace(strResult, _
                                strStar & StrConv(vntPlaceHolder, vbLowerCase) & strStar, _
                                Format(dteTargetMonth, vntPlaceHolder))
        Next
        
        '「年度」による置換
        '※4月を境に切り替え
        Dim intPeriod As Integer
        If Month(dteTargetMonth) < 4 Then
            intPeriod = Year(dteTargetMonth) - 1
        Else
            intPeriod = Year(dteTargetMonth)
        End If
        
        'PlaceHolder,書式設定を変更
        aryPlaceHolders = Array(Array("PP", "00"), Array("PPPP", "0000"))
        For Each vntPlaceHolder In aryPlaceHolders
            
            '大文字
            strResult = Replace(strResult, _
                                strStar & vntPlaceHolder(0) & strStar, _
                                Format(intPeriod, vntPlaceHolder(1)))
            
            '小文字
            strResult = Replace(strResult, _
                                strStar & StrConv(vntPlaceHolder(0), vbLowerCase) & strStar, _
                                Format(intPeriod, vntPlaceHolder(1)))
        Next
                        
        ReplaceDateName = strResult
    End Function                        
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ファイル・フォルダ処理
' ※本関数軍は依存関係が存在するのでコピペ注意！！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '************************************************
    ' 複数の文字列をPathとして「\」で連結
    '************************************************
    Function TextJoinAsPath(ParamArray aryString() As Variant) As String
        
        Dim vntString As Variant
        Dim strPath As String
        
        '「\」が既に存在するか？で条件分岐
        For Each vntString In aryString
            If strPath = "" Then
                strPath = vntString
            ElseIf Right(strPath, 1) = "\" And Left(vntString, 1) = "\" Then
                strPath = strPath & Right(vntString, Len(vntString) - 1)
            ElseIf Right(strPath, 1) = "\" Or Left(vntString, 1) = "\" Then
                strPath = strPath & vntString
            Else
                strPath = strPath & "\" & vntString
            End If
        Next
        
        TextJoinAsPath = strPath
    End Function
    
    '************************************************
    ' 指定したフォルダパスをたどり、発見された最も深いフォルダを返却
    '************************************************
    Function DigFolder(ByVal strTargetFolder As String) As String
        
        Do While True
            
            '指定フォルダが存在したら終了
            If IsFolderExists(strTargetFolder) = True Then
                Exit Do
                
            'サーバなど「"\\"」始まりの場合はサーバまでさかのぼったら終了
            '※「\\tdmfsv」はフォルダではないのでそれ以上さかのぼることはできない
            ElseIf InStr(strTargetFolder, "\\") = 1 And InStrRev(strTargetFolder, "\") = 2 Then
                Exit Do
                
            '「\」が一切なくなったら場合「ドライブ」の存在確認
            '※「C:ドライブ」はフォルダとして認識されている
            ElseIf InStr(strTargetFolder, "\") < 1 Then
                
                '指定ドライブが存在しなかったら空文字返却
                If IsFolderExists(strTargetFolder) = False Then
                    DigFolder = ""
                    Exit Function
                Else
                    Exit Do
                End If
            
            '1階層さかのぼる
            Else
                strTargetFolder = GetParentPath(strTargetFolder)
            End If
        Loop
        
        DigFolder = strTargetFolder
        
    End Function
    
    '************************************************
    ' 指定パスの1階層上位のフォルダパスを取得
    '************************************************
    Function GetParentPath(ByVal strTagerFolder As String) As String
        
        If Right(strTagerFolder, 1) = "\" Then
            strTagerFolder = Left(strTagerFolder, Len(strTagerFolder) - 1)
        End If
        
        GetParentPath = Left(strTagerFolder, InStrRev(strTagerFolder, "\") - 1)
        
    End Function
    
    '************************************************
    ' 元ファイルフルパス + コピー先「フォルダ」指定でファイルをコピー
    '************************************************
    Sub CopyFileToFolder(ByVal strOriginFilePath As String, ByVal strCopyToFolder)
        Dim strFileName As String
        strFileName = GetFileNameFromFullPath(strOriginFilePath)
        FileCopy strOriginFilePath, TextJoinAsPath(strCopyToFolder, strFileName)
    End Sub
    
    '************************************************
    ' フルパスからファイル名を抽出
    '************************************************
    Function GetFileNameFromFullPath(ByVal strFullPath As String) As String
        GetFileNameFromFullPath = CreateObject("Scripting.FileSystemObject").GetFileName(strFullPath)
    End Function
    
    '************************************************
    ' 【ファイル】の存在確認
    '************************************************
    Function IsFileExists(ByVal strFilePath As String) As Boolean
        
        'ワイルドカードが含まれていたら
        If InStr(strFilePath, "*") Then
            
            'Dir関数はフォルダが不正だとエラーが発生する
            On Error Resume Next
            Dim strFindFile As String
            strFindFile = Dir(strFilePath)
            
            'あいまい検索の結果を返却
            If strFindFile = "" Or Err.Number <> 0 Then
                IsFileExists = False
            Else
                IsFileExists = True
            End If
            On Error GoTo 0
        
        '完全一致の検索結果
        Else
            IsFileExists = CreateObject("Scripting.FileSystemObject").FileExists(strFilePath)
        End If
    End Function
    
    '************************************************
    ' 【フォルダ】の存在確認
    '************************************************
    Function IsFolderExists(ByVal strFolderPath As String) As Boolean
        
        'ワイルドカードが含まれていたら
        If InStr(strFolderPath, "*") Then
            
            'Dir関数はフォルダが不正だとエラーが発生する
            On Error Resume Next
            Dim strFindFolder As String
            strFindFolder = Dir(strFolderPath, vbDirectory)
            
            'あいまい検索の結果を返却
            If strFindFolder = "" Or Err.Number <> 0 Then
                IsFolderExists = False
            Else
                IsFolderExists = True
            End If
            On Error GoTo 0
        
        '完全一致の検索結果
        Else
            IsFolderExists = CreateObject("Scripting.FileSystemObject").FolderExists(strFolderPath)
        End If
    End Function
    
    '************************************************
    ' 初期表示フォルダの切り替え
    '************************************************
    Function ChangeDefaultFolder(ByVal strDefaultFolder As String, Optional ByVal strNextFolder As String = "") As Boolean
        
        'フォルダが存在しなければエラーが発生する
        On Error Resume Next
        CreateObject("WScript.Shell").CurrentDirectory = strDefaultFolder
        
        '関数の戻り値で処理を分岐したいときのために返り値を用意
        If Err.Number <> 0 Then
            
            'エラー時の第二候補がなければ終了
            If strNextFolder = "" Then
                ChangeDefaultFolder = False
            
            'エラー時の第二候補のフォルダに挑戦
            Else
                On Error GoTo 0
                On Error Resume Next
                CreateObject("WScript.Shell").CurrentDirectory = strNextFolder
                If Err.Number <> 0 Then
                    ChangeDefaultFolder = False
                Else
                    ChangeDefaultFolder = True
                End If
            End If
            
        'エラー値が「0」なら成功
        Else
            ChangeDefaultFolder = True
        End If
        On Error GoTo 0
    End Function
    
    '************************************************
    ' 指定フォルダ内の全ファイルを削除
    ' ※ファイルフィルタ設定可能
    '************************************************
    Function DeleteAllFileInFolder(ByVal strTargetFolder As String, Optional ByVal strFileFilter As String = "*")
        
        'Dir関数でファイル検索を実施するため末尾に「\」を付加
        If Right(strTargetFolder, 1) <> "\" Then
            strTargetFolder = strTargetFolder & "\"
        End If
        
        Dim strFindFile As String
        strFindFile = Dir(strTargetFolder & strFileFilter)
        
        'フォルダ内で発見されたファイルを順次削除
        Do While strFindFile <> ""
            Kill strTargetFolder & strFindFile
            strFindFile = Dir()
        Loop
        
    End Function
    
    '************************************************
    ' 指定フォルダ内のファイル数を確認
    '************************************************
    Function GetFilesCountInFolder(ByVal strTargetFolder As String, Optional ByVal strFileFilter As String = "") As Integer
        
        'ファイルフィルタが存在しなければループ無しでファイル数を取得
        If strFileFilter = "" Then
            
            'フォルダが存在しないなど、エラーが発生したら0を返却
            On Error Resume Next
            GetFilesCountInFolder = CreateObject("Scripting.FileSystemObject").GetFolder(strTargetFolder).Files.Count
            On Error GoTo 0
        
        'ファイルフィルタが存在したらDir関数のループでカウント
        Else
            Dim intFilesCount As Integer
            Dim strFindFileName As String
            strFindFileName = Dir(TextJoinAsPath(strTargetFolder, strFileFilter))
            
            Do While strFindFileName <> ""
                intFilesCount = intFilesCount + 1
                strFindFileName = Dir()
            Loop
            
            GetFilesCountInFolder = intFilesCount
            
        End If
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 階層をさかのぼって親フォルダを取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetParentFolderPath(Optional ByVal intBackCount = 0) As String
        
        Dim strFolderPath As String
        strFolderPath = ThisWorkbook.Path
        
        Dim intBackIndex As Integer
        
        '親階層をさかのぼる回数は「絶対値」を使用
        'さかのぼる回数が0ならば自身の保存フォルダを返却
        For intBackIndex = 1 To Abs(intBackCount)
            
            '「\」が無くなったら空文字を返却
            If InStr(strFolderPath, "\") = 0 Then
                GetParentFolderPath = ""
                Exit Function
            End If
            strFolderPath = Left(strFolderPath, InStrRev(strFolderPath, "\") - 1)
        Next
        
        GetParentFolderPath = strFolderPath
        
    End Function                            
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 指定フォルダのファイル数をカウント
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CountFileInFolder(ByVal strSearchKey) As Long
        
        Dim lngCount As Long
        Dim strFindFile As String
        
        strFindFile = Dir(strSearchKey)
        
        Do While strFindFile <> ""
            lngCount = lngCount + 1
            strFindFile = Dir()
        Loop
        
        CountFileInFolder = lngCount
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' オートフィルタの解除（可変長引数）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ClearAutoFilter(ParamArray aryWorksheets() As Variant)
        
        Dim vntWorksheet As Variant
        For Each vntWorksheet In aryWorksheets
            If vntWorksheet.AutoFilterMode = True Then vntWorksheet.AutoFilterMode = False
        Next
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 24:00超えの時刻文字列をDate型に変換
' ※Date型内では26:00は1日＋2:00として扱われています。
' ※IsDateチェックは要注意！！
' 　IsDate (0.5)がTrueになり「0.5⇒0:05:00」に変換されます。
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function TimeConvert(ByVal vntTimeValue As Variant) As Date
        
        '文字列だったら「24時間超表現」考慮
        If TypeName(vntTimeValue) = "String" Then
                        
            '「[h]:mm」「[h]:mmss」の場合処理実施
            '※時間は最大3桁
            If IncludeRegExp(vntTimeValue, "^\d{1,3}:\d{2}(:\d{2})?$") = True Then
                
                Dim aryHoursMinutes As Variant
                aryHoursMinutes = Split(vntTimeValue, ":")
                
                '「:」が複数あったら処理終了
                If UBound(aryHoursMinutes) - LBound(aryHoursMinutes) <> 1 Then
                    TimeConvert = 0
                    Exit Function
                End If
                
                Dim strHours As String
                Dim strMinutes As String
                strHours = aryHoursMinutes(LBound(aryHoursMinutes))     '1～3文字
                strMinutes = aryHoursMinutes(LBound(aryHoursMinutes) + 1)   '絶対2文字
                
                '「時間」「分」のみ処理
                TimeConvert = CDate("1:00") * strHours * 1 + CDate("0:01") * strMinutes * 1
            
            '「mm/dd hh:mm」「yyyy/mm/dd hh:mm:ss」等の場合
            ElseIf IncludeRegExp(vntTimeValue, "^(\d{2,4}/)?\d{1,2}/\d{1,2}\s\d{1,2}:\d{2}(:\d{2})?$") = True Then
                TimeConvert = DateValue(vntTimeValue) + TimeValue(vntTimeValue)
            End If
        
        'Date型はDate型のまま
        ElseIf TypeName(vntTimeValue) = "Date" Then
            TimeConvert = vntTimeValue
        
        '何らかの数値はDateに変換
        ElseIf IsNumeric(vntTimeValue) Then
            TimeConvert = vntTimeValue * 1
        
        '処理が不可能ならなければ0を出力
        Else
            TimeConvert = 0
        End If
        
    End Function
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' マクロでは小数誤差が原因で時刻の一致確認が困難
' 指定した誤差範囲以内であれば「一致」と判断する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function TimeEqual(ByVal dteTimeA As Date, dteTimeB As Date, Optional ByVal dteTimeRange = 0)
        
        'デフォルトで「1秒未満」の誤差を許容する
        If dteTimeRange = 0 Then
            dteTimeRange = CDate("0:00:01")
        End If
        
        '誤差範囲内の確認「誤差下限 ～ 基準 ～ 誤差上限」
        If dteTimeA > dteTimeB - dteTimeRange And dteTimeA < dteTimeB + dteTimeRange Then
            TimeEqual = True
        Else
            TimeEqual = False
        End If
        
    End Function
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' エクセル内で「マイナスの時間」を扱えないため時間を分（整数）に変換
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function TimeToLongMinutes(ByVal strTimeValue As String) As Long
                
        '文字列内に「:」があれば変換開始
        If InStr(strTimeValue, ":") > 0 Then
            
            Dim aryHoursMinutes As Variant
            aryHoursMinutes = Split(strTimeValue, ":")
            
            '「:」が複数あったら処理終了
            If UBound(aryHoursMinutes) - LBound(aryHoursMinutes) <> 1 Then
                TimeToLongMinutes = 0
                Exit Function
            End If
            
            Dim strHours As String
            Dim strMinutes As String
            strHours = aryHoursMinutes(LBound(aryHoursMinutes))     '1～3文字
            strMinutes = aryHoursMinutes(UBound(aryHoursMinutes))   '絶対2文字
            
            '「時間：1～3文字」「分：2文字」の場合のみ処理
            If Len(strHours) > 0 And Len(strHours) < 4 And Len(strMinutes) = 2 And IsNumeric(strHours) And IsNumeric(strMinutes) Then
                TimeToLongMinutes = 60 * strHours + strMinutes * 1
                Exit Function
            End If
        
        'エクセルシート上の時刻は「小数」になってしまう
        ElseIf IsNumeric(strTimeValue) = True Then
            TimeToLongMinutes = strTimeValue * 60 * 24
            Exit Function
        End If
        
        '体裁が時刻の形出なければ0を出力
        TimeToLongMinutes = 0
                
    End Function
    
    '「分（整数）」を「Date型」に復元
    Function LongMinutesToTime(ByVal lngMinutes As Long) As Date
        
        LongMinutesToTime = CDate("0:01") * lngMinutes
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 日時の〇分刻み関数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '************************************
    ' 〇分切り捨て
    '************************************
    Function MinuteFloor(ByVal dteTarget As Date, ByVal intFloorMinute As Integer) As Date
        
        MinuteFloor = DateSerial(Year(dteTarget), Month(dteTarget), Day(dteTarget)) + _
                        TimeSerial(Hour(dteTarget), Application.WorksheetFunction.Floor(Minute(dteTarget), intFloorMinute), 0)
        
    End Function
    
    '************************************
    ' 〇分切り上げ
    '************************************
    Function MinuteCeiling(ByVal dteTarget As Date, ByVal intCeilingMinute As Integer) As Date
        
        MinuteCeiling = DateSerial(Year(dteTarget), Month(dteTarget), Day(dteTarget)) + _
                        TimeSerial(Hour(dteTarget), Application.WorksheetFunction.Ceiling(Minute(dteTarget), intCeilingMinute), 0)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 対象月の週数（カレンダーの行数）をカウント
' ※月またぎ週時間外を計算するため
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetWeekCount(ByVal dteMonthStart As Date, Optional ByVal intStartWeekday As Integer = vbSunday) As Integer
        
        '「カレンダーの左上」に当たる日付を特定
        
        '★通常カレンダー⇒26日を求める
        '|----|----|----|------|----|----|----|
        '| 日 | 月 | 火 |【水】| 木 | 金 | 土 |
        '|----|----|----|------|----|----|----|
        '| 26 | 27 | 28 |【01】| 02 | 03 | 04 |
        '|----|----|----|------|----|----|----|
        
        '★月曜開始カレンダー⇒27日を求める
        '|----|----|------|----|----|----|----|
        '| 月 | 火 |【水】| 木 | 金 | 土 | 日 |
        '|----|----|------|----|----|----|----|
        '| 27 | 28 |【01】| 02 | 03 | 04 | 05 |
        '|----|----|------|----|----|----|----|
        
        '★木曜開始カレンダー⇒23日を求める
        '|----|----|----|----|----|----|------|
        '| 木 | 金 | 土 | 日 | 月 | 火 |【水】|
        '|----|----|----|----|----|----|------|
        '| 23 | 24 | 25 | 26 | 27 | 28 |【01】|
        '|----|----|----|----|----|----|------|
        
        '① 1日より前の曜日がカレンダー初日の場合
        '　⇒指定曜日にさかのぼる
        If Weekday(dteMonthStart) >= intStartWeekday Then
            Dim dteCalenderLeftTop As Date
            dteCalenderLeftTop = dteMonthStart - Weekday(dteMonthStart) + intStartWeekday
        
        '② 1日より後ろの曜日がカレンダー初日の場合
        '　⇒指定曜日に進んでから1週間前にさかのぼる
        Else
            dteCalenderLeftTop = dteMonthStart + (intStartWeekday - Weekday(dteMonthStart)) - 7
        End If
        
        'カレンダー各行の「左端」の月が変化したら当該月のカレンダー行数確定
        '※
        Dim dteCalenderLeftBottom As Date
        dteCalenderLeftBottom = dteCalenderLeftTop
        
        'カレンダー「左端」の月が変化したらカウント終了
        Do While dteCalenderLeftBottom <= Application.WorksheetFunction.EoMonth(dteMonthStart, 0)
            Dim intWeekCount As Integer
            intWeekCount = intWeekCount + 1
            dteCalenderLeftBottom = dteCalenderLeftBottom + 7
        Loop
        
        '当該月のカレンダー行数を返却
        GetWeekCount = intWeekCount
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' コメントで履歴を残しながらセルの値を更新
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub UpdateCellAddComment(ByVal rngCell As Range, ByVal strUpdateValue As String)
        If TypeName(rngCell.Comment) = "Nothing" Then
            rngCell.AddComment "【変更前】" & rngCell.Value
        Else
            rngCell.Comment.Text rngCell.Comment.Text & vbCrLf & _
                                            "【変更前】" & rngCell.Value
        End If
        rngCell.Value = strUpdateValue
        rngCell.Interior.Color = rgbYellow
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' コメントを追加するだけ
' ※コメントが既に存在した際は「追記」に切り替え
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub AddComment(ByVal rngTarget As Range, ByVal strText As String)
        
        'コメントが存在するとエラーが発生するので回避
        On Error Resume Next
        
        'コメントを新規追加
        rngTarget.AddComment strText
        
        'コメントが既に存在しているとエラー発生
        '⇒「文字追記」に切り替え
        If Err.Number <> 0 Then
            rngTarget.Comment.Text rngTarget.Comment.Text & vbCrLf & _
                                    strText
        End If
        On Error GoTo 0
        
    End Sub     
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列をクリップボードに送信
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub SendClipboard(ByVal strText as string)
        
        With CreateObject("Forms.TextBox.1")
            .MultiLine = True
            .Text = strText
            .SelStart = 0
            .SelLength = .TextLength
            .Copy
        End With
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　OutlookMail作成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Const strSplitDelimiter As String = ";"
    
    '構造体にメールセッティングをまとめる
    Type MailSettings
        OutlookApp As Object
        From As String
        To As String
        Cc As String
        Bcc As String
        Subject As String
        HtmlBody As String
        
        '添付ファイル
        '※複数項目存在する場合は「SplitDelimiter」区切り
        AttachFolder As String
        AttachFileNames As String
        
        '本文中の置換・画像の挿入
        '※複数項目存在する場合は「SplitDelimiter」区切り
        ReplaceContents As String
        InsertImages As String
        
        '「添付ファイル」「置換文字」「挿入画像」の区切り文字
        SplitDelimiter As String
        MacroFolder As Object
        EntryId As String
        ConversationIndex As String
    End Type
    
    Public Const strMacroFolder As String = "マクロ用"
    Const olMailItem As Integer = 0
    Const olFormatHTML As Integer = 2
    Const olFolderSentMail As Integer = 5
    Const strImagePlaceHolderKey As String = "◆"
    Const strTextPlaceHolderKey As String = "★"
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　構造体の設定に基づき個別メールを作成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function CreateMailItem(ByRef typMailSettings As MailSettings, Optional ByVal blnRemind As Boolean = False) As Boolean
        
        With typMailSettings
            
            If blnRemind = False Then
                
                Dim objOutlookMailItem As Object
                Set objOutlookMailItem = .OutlookApp.CreateItem(olMailItem)
                objOutlookMailItem.To = .To
                objOutlookMailItem.Cc = .Cc
                objOutlookMailItem.Bcc = .Bcc
                objOutlookMailItem.Subject = .Subject
                objOutlookMailItem.HtmlBody = .HtmlBody
                
                '本文置換
                If .ReplaceContents <> "" Then
                    
                    If InStr(.ReplaceContents, strSplitDelimiter) = 0 And InStr(.ReplaceContents, vbLf) > 0 Then
                        .SplitDelimiter = vbLf
                    Else
                        .SplitDelimiter = strSplitDelimiter
                    End If
                    
                    Dim aryReplaceContents As Variant
                    aryReplaceContents = Split(.ReplaceContents, .SplitDelimiter)
                    
                    Dim intContentIndex As Integer
                    For intContentIndex = LBound(aryReplaceContents) To UBound(aryReplaceContents)
                        objOutlookMailItem.HtmlBody = Replace(objOutlookMailItem.HtmlBody, StrConv(strTextPlaceHolderKey & (intContentIndex + 1) & strTextPlaceHolderKey, vbWide), aryReplaceContents(intContentIndex))
                        objOutlookMailItem.HtmlBody = Replace(objOutlookMailItem.HtmlBody, StrConv(strTextPlaceHolderKey & (intContentIndex + 1) & strTextPlaceHolderKey, vbNarrow), aryReplaceContents(intContentIndex))
                    Next
                    
                End If
                
                '挿入画像も「添付」する必要がある
                '※「空欄;ファイル名1;ファイル名2」となっていてもエラーが発生しない設計になっています。
                If .InsertImages <> "" Then
                    
                    Const strImageRenameBase As String = "InsertImages"
                    
                    If InStr(.InsertImages, strSplitDelimiter) = 0 And InStr(.InsertImages, vbLf) > 0 Then
                        .SplitDelimiter = vbLf
                    Else
                        .SplitDelimiter = strSplitDelimiter
                    End If
                    
                    Dim aryInsertImageFiles As Variant
                    aryInsertImageFiles = Split(.InsertImages, .SplitDelimiter)
                    
                    Dim intImageIndex As Integer
                    For intImageIndex = LBound(aryInsertImageFiles) To UBound(aryInsertImageFiles)
                        
                        '挿入画像として別名を設定して添付⇒本文中に挿入
                        If aryInsertImageFiles(intImageIndex) <> "" Then
                            
                            With objOutlookMailItem.Attachments.Add(.AttachFolder & aryInsertImageFiles(intImageIndex))
                                .PropertyAccessor.SetProperty "http://schemas.microsoft.com/mapi/proptag/0x3712001F", strImageRenameBase & intImageIndex
                            End With
                            
                            Dim strImageHtml As String
                            strImageHtml = "<img src='cid:" & strImageRenameBase & intImageIndex & "'>"
                            objOutlookMailItem.HtmlBody = Replace(objOutlookMailItem.HtmlBody, StrConv(strImagePlaceHolderKey & (intImageIndex + 1) & strImagePlaceHolderKey, vbWide), strImageHtml)
                            objOutlookMailItem.HtmlBody = Replace(objOutlookMailItem.HtmlBody, StrConv(strImagePlaceHolderKey & (intImageIndex + 1) & strImagePlaceHolderKey, vbNarrow), strImageHtml)
                            
                        '空欄だったらPlaceHolderを削除
                        Else
                            objOutlookMailItem.HtmlBody = Replace(objOutlookMailItem.HtmlBody, StrConv(strImagePlaceHolderKey & (intImageIndex + 1) & strImagePlaceHolderKey, vbWide), "")
                            objOutlookMailItem.HtmlBody = Replace(objOutlookMailItem.HtmlBody, StrConv(strImagePlaceHolderKey & (intImageIndex + 1) & strImagePlaceHolderKey, vbNarrow), "")
                        End If
                        
                    Next
                    
                End If
                
                'ファイル添付 & 挿入画像も添付
                If .AttachFileNames <> "" Then
                    
                    If InStr(.AttachFileNames, strSplitDelimiter) = 0 And InStr(.AttachFileNames, vbLf) > 0 Then
                        .SplitDelimiter = vbLf
                    Else
                        .SplitDelimiter = strSplitDelimiter
                    End If
                    
                    'セミコロンで区切って複数登録
                    Dim vntAttachFile As Variant
                    For Each vntAttachFile In Split(.AttachFileNames, .SplitDelimiter)
                        
                        'セミコロン区切りに空欄が含まれてい場合を考慮
                        If vntAttachFile <> "" Then
                            
                            'エラーが発生したら終了
                            On Error Resume Next
                            objOutlookMailItem.Attachments.Add .AttachFolder & vntAttachFile
                            If Err.Number <> 0 Then
                                MsgBox "添付・挿入ファイル「 " & vntAttachFile & " 」が格納されていませんでした。" & vbCr & "処理を中断します。"
                                CreateMailItem = False
                                Exit Function
                            End If
                            On Error GoTo 0
                        End If
                    Next
                End If
                
            Else
                
                Set objOutlookMailItem = GetMailItemByConversationIndex(.From, .ConversationIndex)
                Dim objRemindItem As Object
                Set objRemindItem = objOutlookMailItem.Forward
                
                objRemindItem.Subject = .Subject
                objRemindItem.To = .To
                objRemindItem.Cc = .Cc
                objRemindItem.Bcc = .Bcc
                objRemindItem.HtmlBody = .HtmlBody & objRemindItem.HtmlBody
                
                Set objOutlookMailItem = objRemindItem
                
            End If
            
            '指定アカウントの下書きフォルダに保存
            Dim objAccounts As Object
            Set objAccounts = objOutlookMailItem.Parent.Session.Accounts.Item(.From)
            Set objOutlookMailItem.SendUsingAccount = objAccounts
            objOutlookMailItem.Save
            Set objOutlookMailItem = objOutlookMailItem.Move(typMailSettings.MacroFolder)
            
            '保存実施後にIDが発行されるのでIDを取得
            .EntryId = objOutlookMailItem.EntryId
            Set objOutlookMailItem = Nothing
            
        End With
        
        CreateMailItem = True
        
    End Function
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　指定したアカウントの下書きフォルダの指定メールを送信
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function SendMailByAccountAndMailId(ByVal strOutlookAccount As String, ByVal strMailId As String) As String
        
        'Outlookオブジェクト生成
        Dim objOutlook As Object
        Dim objAccounts As Object
        Dim objNameSpace As Object
        Dim objItem As Object
        
        Set objOutlook = CreateObject("Outlook.Application")
        Set objAccounts = objOutlook.Session.Accounts
        
        '指定アカウント・指定メールにアクセスできなかったら終了
        On Error Resume Next
        Set objNameSpace = objAccounts(strOutlookAccount).Application.GetNamespace("MAPI")
        Set objItem = objNameSpace.GetItemFromID(strMailId)
        
        If Err.Number <> 0 Then
            SendMailByAccountAndMailId = False
            Exit Function
        End If
        
        Dim strConversationIndex As String
        strConversationIndex = objItem.ConversationIndex
        
        'マクロでメール送信すると謎のエラーが発生することが多いため
        '表示してから送信することでエラーを回避
        objItem.display
        objItem.Send
        On Error GoTo 0
        
        'オブジェクト解放
        Set objOutlook = Nothing
        Set objAccounts = Nothing
        Set objNameSpace = Nothing
        Set objItem = Nothing
        
        SendMailByAccountAndMailId = strConversationIndex
        
    End Function
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Outlook操作各種
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'Outlook画面が開いているか？確認
    Function IsOpenOutlookWindow(ByVal blnShowMessage As String)
        
        If CreateObject("Outlook.Application").Explorers.Count > 0 Then
            IsOpenOutlookWindow = True
        Else
            If blnShowMessage = True Then
                MsgBox "Outlookアプリが起動されていません。" & vbCrLf & _
                    "Outlookアプリを手動で起動・ログインしてからマクロを実行してください。" & vbCrLf & _
                    "実行を中止します。", vbExclamation
            End If
            
            IsOpenOutlookWindow = False
            
        End If
        
    End Function
    
    'Outlookの指定アカウントにログインしているか確認
    Function IsLoginOutlook(ByVal strOutlookAccount As String, ByVal blnShowMessage As Boolean) As Boolean
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        
        '指定アカウントを操作できない⇒ログインしていないと判断
        '※DisplayNameを取得する事に特別な意味はありません。
        On Error Resume Next
        Dim strDisplayName As String
        strDisplayName = objOutlookAccount(strOutlookAccount).DisplayName
        
        If Err.Number <> 0 Then
            IsLoginOutlook = False
            If blnShowMessage = True Then
                MsgBox "指定アカウント「" & strOutlookAccount & "」にログインしていません。" & vbCrLf & _
                        "指定アカウントにログインしてから再度実行してください。" & vbCrLf & _
                        "実行を中止します。", vbExclamation
            End If
            
        Else
            IsLoginOutlook = True
        End If
        On Error GoTo 0
        
    End Function
    
    'メインアカウントの確認
    Function GetOutlookDefaultAccount() As String
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        GetOutlookDefaultAccount = objOutlookAccount(1).DisplayName
        
    End Function
    
    '下書きフォルダの現在の保存件数
    Function CheckOutlookFolderItemsCount(ByVal strOutlookAccount As String)
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        CheckOutlookFolderItemsCount = objOutlookAccount(strOutlookAccount).DeliveryStore.GetDefaultFolder(16).Items.Count
        
    End Function
    
    '下書きフォルダの本文のHTMLを取得
    Function GetHTML(ByVal strOutlookAccount As String)
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        GetHTML = objOutlookAccount(strOutlookAccount).DeliveryStore.GetDefaultFolder(16).Items(1).HtmlBody
        
    End Function
    
    '下書きフォルダの本文のHTMLを変更
    Function SetHtml(ByVal strOutlookAccount As String)
        
        '★Outlookの参照設定を行っていない場合、Accountsのインデックスを指定するとがエラーが発生します。
        Dim objOutlookAccount As Object
        Dim objMailItem As Object
        Set objOutlookAccount = CreateObject("Outlook.Application").Session.Accounts
        Set objMailItem = objOutlookAccount(strOutlookAccount).DeliveryStore.GetDefaultFolder(16).Items(2)
        objMailItem.HtmlBody = "楽しいだろうか？"
        objMailItem.Save
        
    End Function
    
    '「下書き」フォルダ内にマクロ用フォルダを生成して返却
    Function GetMacroFolder(ByVal strOutlookAccount As String, ByVal strFolderName As String) As Object
        
        On Error Resume Next
        With CreateObject("Outlook.Application").GetNamespace("MAPI").Folders(strOutlookAccount).Folders("下書き")
            .Folders.Add strFolderName
            Set GetMacroFolder = .Folders(strFolderName)
        End With
        On Error GoTo 0
        
    End Function
    
    '***************************************
    ' リマインドメール作成のために「送信済みアイテム」よりメールを作成
    ' 送信しても変化しない「ConversationIndex」を利用し対象メールを探し出す
    '***************************************
    Function GetMailItemByConversationIndex(ByVal strOutlookAccount As String, ByVal strConversationIndex As String) As Object
        
        Dim objOutlookAccounts As Object
        Dim objMailItems As Object
        Set objOutlookAccounts = CreateObject("Outlook.Application").Session.Accounts
        Set objMailItems = objOutlookAccounts(strOutlookAccount).DeliveryStore.GetDefaultFolder(olFolderSentMail).Items
        
        '直近100日分を調査
        Dim strFilter As String
        strFilter = "[CreationTime] > '" & Format(Now - 100, "ddddd h:nn AMPM") & "'"
        
        Dim objResultItems As Object
        Set objResultItems = objMailItems.Restrict(strFilter)
        
        '直近から順に調査
        Dim lngIndex As Long
        For lngIndex = objResultItems.Count To 1 Step -1
            
            If objResultItems(lngIndex).ConversationIndex = strConversationIndex Then
                Set GetMailItemByConversationIndex = objResultItems(lngIndex)
                Exit Function
            End If
            
        Next
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　セル内文字を個別に調査しHTMLに変換
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ConvertHtmlFromCell(ByVal rngTarget As Range) As String
        
        Const strTEXT As String = "TEXT"
        Const strCOLOR As String = "COLOR"
        Const strBOLD As String = "BOLD"
        Const strUNDERLINE As String = "UNDERLINE"
        Const strTAG_START As String = "TAG_START"
        Const strTAG_END As String = "TAG_END"
        
        '空文字だったら改行のみ
        If rngTarget.Value = "" Then
            ConvertHtmlFromCell = "&ltbr>"
            Exit Function
        End If
        
        Dim dctText As Object
        Set dctText = CreateNewDictionary
        
        Dim intIndex As Integer
        intIndex = 0
        
        '「0文字目」には既定値を設定
        dctText.Add intIndex, CreateNewDictionary
        dctText(intIndex).Add strTEXT, ""
        dctText(intIndex).Add strCOLOR, rgbBlack
        dctText(intIndex).Add strBOLD, False
        dctText(intIndex).Add strUNDERLINE, False
        dctText(intIndex).Add strTAG_START, ""
        dctText(intIndex).Add strTAG_END, ""
        
        'セル内の全文字の詳細を調査
        For intIndex = 1 To Len(rngTarget.Value)
            
            With rngTarget.Characters(Start:=intIndex, Length:=1)
                
                '1文字ずつ状態を確認
                dctText.Add intIndex, CreateNewDictionary
                dctText(intIndex).Add strTEXT, .Text
                dctText(intIndex).Add strCOLOR, .Font.color
                dctText(intIndex).Add strBOLD, .Font.Bold
                
                '下線は「有無」のみ判別
                If .Font.Underline = xlUnderlineStyleNone Then
                    dctText(intIndex).Add strUNDERLINE, False
                Else
                    dctText(intIndex).Add strUNDERLINE, True
                End If
                
                '開始タグ・終了タグを格納
                dctText(intIndex).Add strTAG_START, ""
                dctText(intIndex).Add strTAG_END, ""
                
            End With
            
        Next
        
        '「末尾+1文字目」にも既定値を設定
        intIndex = dctText.Count
        dctText.Add intIndex, CreateNewDictionary
        dctText(intIndex).Add strTEXT, ""
        dctText(intIndex).Add strCOLOR, rgbBlack
        dctText(intIndex).Add strBOLD, False
        dctText(intIndex).Add strUNDERLINE, False
        dctText(intIndex).Add strTAG_START, ""
        dctText(intIndex).Add strTAG_END, ""
        
        '「0文字目」「末尾+1文字」以外を走査し「変化部分」にタグを追加する
        For intIndex = 1 To Len(rngTarget.Value)
            
            '「n-1文字目」と色が違う
            If dctText(intIndex - 1)(strCOLOR) <> dctText(intIndex)(strCOLOR) And dctText(intIndex)(strCOLOR) <> vbBlack Then
                dctText(intIndex)(strTAG_START) = dctText(intIndex)(strTAG_START) & "&ltfont style='color:" & GetCssColor(dctText(intIndex)(strCOLOR)) & ";'>"
            End If
            
            '「n+1文字目」と色が違う
            If dctText(intIndex + 1)(strCOLOR) <> dctText(intIndex)(strCOLOR) And dctText(intIndex)(strCOLOR) <> vbBlack Then
                dctText(intIndex)(strTAG_END) = dctText(intIndex)(strTAG_END) & "&lt/font>"
            End If
            
            '「n-1文字目」と太さが違う
            If dctText(intIndex - 1)(strBOLD) <> dctText(intIndex)(strBOLD) And dctText(intIndex)(strBOLD) = True Then
                dctText(intIndex)(strTAG_START) = dctText(intIndex)(strTAG_START) & "&ltb>"
            End If
            
            '「n+1文字目」と太さが違う
            If dctText(intIndex + 1)(strBOLD) <> dctText(intIndex)(strBOLD) And dctText(intIndex)(strBOLD) = True Then
                dctText(intIndex)(strTAG_END) = dctText(intIndex)(strTAG_END) & "&lt/b>"
            End If
            
            '「n-1文字目」と下線
            If dctText(intIndex - 1)(strUNDERLINE) <> dctText(intIndex)(strUNDERLINE) And dctText(intIndex)(strUNDERLINE) = True Then
                dctText(intIndex)(strTAG_START) = dctText(intIndex)(strTAG_START) & "&ltu>"
            End If
            
            '「n+1文字目」と下線
            If dctText(intIndex + 1)(strUNDERLINE) <> dctText(intIndex)(strUNDERLINE) And dctText(intIndex)(strUNDERLINE) = True Then
                dctText(intIndex)(strTAG_END) = dctText(intIndex)(strTAG_END) & "&lt/u>"
            End If
            
        Next
        
        '全ての「文字＋タグ」を連結し、最終的な文字列を生成
        Dim strResultHtml As String
        For intIndex = 1 To Len(rngTarget.Value)
            strResultHtml = strResultHtml & dctText(intIndex)(strTAG_START) & dctText(intIndex)(strTEXT) & dctText(intIndex)(strTAG_END)
        Next
        
        'セルごとに改行を挿入
        ConvertHtmlFromCell = strResultHtml & "&ltbr>"
        
    End Function
    
    '*******************************************
    ' エクセル上のHTML用の16進数に変換
    '※RGBの順番が逆なので注意！
    '*******************************************
    
    Function GetCssColor(ByVal lngColor As Long) As String
        
        With Application.WorksheetFunction
            
            Dim intRed As Integer
            Dim intGreen As Integer
            Dim intBlue As Integer
            intRed = lngColor Mod 256
            intGreen = .RoundDown(lngColor / 256, 0) Mod 256
            intBlue = .RoundDown(.RoundDown(lngColor / 256, 0) / 256, 0)
            
            Dim strRed As String
            Dim strGreen As String
            Dim strBlue As String
            strRed = Right("00" & Hex(intRed), 2)
            strGreen = Right("00" & Hex(intGreen), 2)
            strBlue = Right("00" & Hex(intBlue), 2)
            
            GetCssColor = "#" & strRed & strGreen & strBlue
            
        End With
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 「角」の座標配列を渡すと「角丸」図形を生成する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '座標管理用構造体
    Type CornerPoints
        X As Double
        Y As Double
        OffsetX As Double
        OffsetY As Double
        HandleX As Double
        HandleY As Double
    End Type
    
    '座標計算用構造体
    Type ShapePoints
        From As CornerPoints
        To As CornerPoints
        Distance As Double
    End Type
    
    '*************************************************
    ' サンプルコード
    '*************************************************
    Sub ShowSmoothShape()
        
        Dim aryXYs(7, 1) As Double
        aryXYs(0, 0) = Range("C2").Left
        aryXYs(0, 1) = Range("C2").Top
        
        aryXYs(1, 0) = Range("I2").Left
        aryXYs(1, 1) = Range("I2").Top
        
        aryXYs(2, 0) = Range("I7").Left
        aryXYs(2, 1) = Range("I7").Top
        
        aryXYs(3, 0) = Range("E7").Left
        aryXYs(3, 1) = Range("E7").Top
        
        aryXYs(4, 0) = Range("E6").Left
        aryXYs(4, 1) = Range("E6").Top
        
        aryXYs(5, 0) = Range("D6").Left
        aryXYs(5, 1) = Range("D6").Top
        
        aryXYs(6, 0) = Range("D5").Left
        aryXYs(6, 1) = Range("D5").Top
        
        aryXYs(7, 0) = Range("C5").Left
        aryXYs(7, 1) = Range("C5").Top
        
        Call MakeSmoothShape(aryXYs, "TEST_SHAPE", ActiveSheet)
        
    End Sub
    
    '*************************************************
    ' ポイント配列を受け取り「角丸」図形を生成する
    '*************************************************
    
    Function MakeSmoothShape(ByVal aryXYs As Variant, ByVal strShapeName As String, ByVal wsTarget As Worksheet) As Object
        
        Dim typShapePoints As ShapePoints
        Dim typShapePointsNext As ShapePoints
            
        Dim intPoint As Integer
        For intPoint = 0 To UBound(aryXYs, 1)
            
            '対象配列⇒次の配列を取得し「始点・終点」を取得
            '※配列末尾は先頭に戻る
            Dim intNextPoint As Integer
            intNextPoint = (intPoint + 1) Mod (UBound(aryXYs, 1) + 1)
            
            With typShapePoints
                
                '始点終点を取得
                .From.X = aryXYs(intPoint, 0)
                .From.Y = aryXYs(intPoint, 1)
                .To.X = aryXYs(intNextPoint, 0)
                .To.Y = aryXYs(intNextPoint, 1)
                
                '角丸を作るために長さを調整した値を計算
                Call CalcPoints(typShapePoints)
                
                '「完全初回」は「始点」を生成
                Dim shpFreeForm As Object
                If shpFreeForm Is Nothing Then
                    Set shpFreeForm = wsTarget.Shapes.BuildFreeform(msoEditingAuto, .From.OffsetX, .From.OffsetY)
                End If
                
                '「始点ハンドルx, y, 終点ハンドルx, y, 終点x, y」の順に座標を指定
                shpFreeForm.AddNodes msoSegmentCurve, msoEditingCorner, .From.HandleX, .From.HandleY, .To.HandleX, .To.HandleY, .To.OffsetX, .To.OffsetY
                
                '角丸を作るために「実際の角」にハンドルを設置
                .From.HandleX = aryXYs(intNextPoint, 0)
                .From.HandleY = aryXYs(intNextPoint, 1)
                .To.HandleX = .From.HandleX
                .To.HandleY = .From.HandleY
            
            End With
            
            Dim intNextNextPoint As Integer
            intNextNextPoint = (intPoint + 2) Mod (UBound(aryXYs, 1) + 1)
            
            '「角丸」作成のために「次の始点」を計算
            With typShapePointsNext
                .From.X = aryXYs(intNextPoint, 0)
                .From.Y = aryXYs(intNextPoint, 1)
                .To.X = aryXYs(intNextNextPoint, 0)
                .To.Y = aryXYs(intNextNextPoint, 1)
                Call CalcPoints(typShapePointsNext)
            End With
            
            '「次の始点」に向けて角丸を生成
            With typShapePoints
                
                .To.OffsetX = typShapePointsNext.From.OffsetX
                .To.OffsetY = typShapePointsNext.From.OffsetY
                
                shpFreeForm.AddNodes msoSegmentCurve, msoEditingCorner, .From.HandleX, .From.HandleY, .To.HandleX, .To.HandleY, .To.OffsetX, .To.OffsetY
                
            End With
            
        Next
        
        '線をシェイプに変換⇒名称を設定して返却
        Dim shpSmoothShape As Shape
        Set shpSmoothShape = shpFreeForm.ConvertToShape
        shpSmoothShape.Name = strShapeName
        Set MakeSmoothShape = shpSmoothShape
        
    End Function
    
    '*************************************************
    ' 始点・終点から内分点を計算
    '*************************************************
    Sub CalcPoints(ByRef typShapePoints As ShapePoints, Optional ByVal intOffset As Integer = 10)
        
        With typShapePoints
            
            'From⇒Toの長さ
            .Distance = Sqr((.From.X - .To.X) ^ 2 + (.From.Y - .To.Y) ^ 2)
            
            '内分点を計算し総延長を短縮
            .From.OffsetX = (intOffset / .Distance) * .To.X + ((.Distance - intOffset) / .Distance) * .From.X
            .From.OffsetY = (intOffset / .Distance) * .To.Y + ((.Distance - intOffset) / .Distance) * .From.Y
            .To.OffsetX = (intOffset / .Distance) * .From.X + ((.Distance - intOffset) / .Distance) * .To.X
            .To.OffsetY = (intOffset / .Distance) * .From.Y + ((.Distance - intOffset) / .Distance) * .To.Y
            
            '内分点を計算しハンドル位置を計算
            .From.HandleX = (intOffset * 2 / .Distance) * .To.X + ((.Distance - intOffset * 2) / .Distance) * .From.X
            .From.HandleY = (intOffset * 2 / .Distance) * .To.Y + ((.Distance - intOffset * 2) / .Distance) * .From.Y
            .To.HandleX = (intOffset * 2 / .Distance) * .From.X + ((.Distance - intOffset * 2) / .Distance) * .To.X
            .To.HandleY = (intOffset * 2 / .Distance) * .From.Y + ((.Distance - intOffset * 2) / .Distance) * .To.Y
            
        End With
        
    End Sub
    
    '*************************************************
    ' ポイント計算を可視化するため「点」を表示する
    '*************************************************
    Function AddPoint(ByVal dblX As Double, ByVal dblY As Double, ByVal wsTarget As Worksheet, Optional ByVal intSize As Integer = 4)
        
        Call wsTarget.Shapes.AddShape(msoShapeRectangle, dblX - intSize / 2, dblY - intSize / 2, intSize, intSize)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ShapeFormの生成・コントロール
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'ヘッダの色・定型文
    Const rgbHeaderBlue As Long = 13998939
    Const strOpenMark As String = "〇"
    Const strCloseMark As String = "―"
    Const intMaxCount As Integer = 10
    
    Const strParentName As String = "f_Parent_"
    Const strHeaderName As String = "f_Header_"
    Const strOpenName As String = "f_Open_"
    Const strCloseName As String = "f_Close_"
    Const strBodyName As String = "f_Body_"
    Const strShadowName As String = "f_Shadow_"
    
    
    '初期表示時のサイズ表示
    Enum DefaultSize
        HeaderHeight = 20
        HeaderWidth = 200
        BodyHeight = 100
    End Enum
    
    'フォームのパーツを管理する構造体
    Type ShapeForm
        
        Parent As Shape
        Header As Shape
        Open As Shape
        Close As Shape
        Body As Shape
        Shadow As Shape
        
        ParentName As String
        HeaderName As String
        OpenName As String
        CloseName As String
        BodyName As String
        ShadowName As String
        
    End Type
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ShapeFormの新規作成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub AddNewShape()
        
        'オートシェイプの名称が一致しない「番号」を探す
        Dim intFormNumber As Integer
        For intFormNumber = 1 To intMaxCount
            
            '「f_00_partsname」でフォーム番号を管理
            Dim strFormNumber As String
            strFormNumber = Format(intFormNumber, "00")
            
            Dim blnNumberDuplicate As Boolean
            blnNumberDuplicate = False
            
            '既存のAutoShapeと名称が一致するか？チェック
            Dim vntShape As Variant
            For Each vntShape In ActiveSheet.Shapes
                If vntShape.Name Like "f_*_" & strFormNumber Then
                    blnNumberDuplicate = True
                    Exit For
                End If
            Next
            
            '名称の重複がなかったらループを終了しその番号を使用
            If blnNumberDuplicate = False Then
                Exit For
            End If
            
            '上限に達したらフォーム生成断念
            If intFormNumber = intMaxCount Then
                MsgBox "フォームが" & intMaxCount & "個以上生成されているます。" & vbCrLf & _
                        "実行を中止します。", vbExclamation
                Exit Sub
            End If
            
        Next
        
        Dim typShapeForm As ShapeForm
        With typShapeForm
            
            '各種パーツを新規作成
            Set .Shadow = MakeShadow(strFormNumber)
            Set .Body = MakeBody(strFormNumber)
            Set .Header = MakeHeader(strFormNumber)
            Set .Open = MakeOpen(strFormNumber)
            Set .Close = MakeClose(strFormNumber)
            
            '各種パーツの名称を改めて取得
            .ShadowName = .Shadow.Name
            .BodyName = .Body.Name
            .HeaderName = .Header.Name
            .OpenName = .Open.Name
            .CloseName = .Close.Name
            .ParentName = strParentName & strFormNumber
            
            '新規作成したパーツを基本位置に配置
            .Body.Top = .Header.Top + .Header.Height
            .Body.Left = .Header.Left
            .Shadow.Height = .Header.Height + .Body.Height
            .Open.Left = .Header.Left + .Header.Width - (DefaultSize.HeaderHeight * 2)
            .Close.Left = .Header.Left + .Header.Width - DefaultSize.HeaderHeight
            
        End With
        
        '個々のパーツをグループ化
        Call FormGrouping(typShapeForm)
        
    End Sub
    
    '*******************************************
    ' ヘッダの生成
    '*******************************************
    Function MakeHeader(ByVal strCallerNumber As String) As Shape
        
        Dim shpHeader As Shape
        Set shpHeader = ActiveSheet.Shapes.AddShape(msoShapeRectangle, 0, 0, 200, DefaultSize.HeaderHeight)
            
        With shpHeader
            .Fill.ForeColor.RGB = rgbHeaderBlue
            .Line.ForeColor.RGB = rgbGray
            
            .TextFrame2.TextRange.Font.NameFarEast = "Meiryo UI"
            .TextFrame.Characters.Font.Color = rgbWhite
            .TextFrame.Characters.Font.Bold = True
            .TextFrame.Characters.Font.Size = 10
            .TextFrame.Characters.Text = "　シェイプフォーム"
            
            .TextFrame.MarginBottom = 0
            .TextFrame.MarginLeft = 0
            .TextFrame.MarginRight = 0
            .TextFrame.MarginTop = 0
            .TextFrame.VerticalAlignment = xlVAlignCenter
            .Name = strHeaderName & strCallerNumber
        End With
        
        Set MakeHeader = shpHeader
        
    End Function
    
    '*******************************************
    ' 展開ボタン
    '*******************************************
    Function MakeOpen(ByVal strCallerNumber As String) As Shape
        
        Dim shpOpen As Shape
        Set shpOpen = ActiveSheet.Shapes.AddShape(msoShapeRectangle, 0, 0, DefaultSize.HeaderHeight, DefaultSize.HeaderHeight)
            
        With shpOpen
            .Fill.ForeColor.RGB = rgbGold
            .Line.ForeColor.RGB = rgbGray
            .TextFrame.Characters.Font.Color = rgbWhite
            .TextFrame.Characters.Font.Bold = True
            .TextFrame.Characters.Font.Size = 10
            .TextFrame.Characters.Text = strOpenMark
            
            .TextFrame.MarginBottom = 0
            .TextFrame.MarginLeft = 0
            .TextFrame.MarginRight = 0
            .TextFrame.MarginTop = 0
            .TextFrame.VerticalAlignment = xlVAlignCenter
            .TextFrame.HorizontalAlignment = xlHAlignCenter
            .Name = strOpenName & strCallerNumber
            .OnAction = "FormOpen"
        End With
        
        Set MakeOpen = shpOpen
        
    End Function
    
    '*******************************************
    ' 最小化ボタン
    '*******************************************
    Function MakeClose(ByVal strCallerNumber As String) As Shape
        
        Dim shpClose As Shape
        Set shpClose = ActiveSheet.Shapes.AddShape(msoShapeRectangle, 0, 0, DefaultSize.HeaderHeight, DefaultSize.HeaderHeight)
            
        With shpClose
            .Fill.ForeColor.RGB = rgbRed
            .Line.ForeColor.RGB = rgbFireBrick
            .TextFrame.Characters.Font.Color = rgbWhite
            .TextFrame.Characters.Font.Bold = True
            .TextFrame.Characters.Font.Size = 14
            .TextFrame.Characters.Text = "×"
            
            .TextFrame.MarginBottom = 0
            .TextFrame.MarginLeft = 0
            .TextFrame.MarginRight = 0
            .TextFrame.MarginTop = 0
            .TextFrame.VerticalAlignment = xlVAlignCenter
            .TextFrame.HorizontalAlignment = xlHAlignCenter
            .Name = strCloseName & strCallerNumber
            .OnAction = "FormClose"
        End With
        
        Set MakeClose = shpClose
        
    End Function
    
    '*******************************************
    ' 本文部分
    '*******************************************
    Function MakeBody(ByVal strCallerNumber As String) As Shape
        
        Dim shpBody As Shape
        Set shpBody = ActiveSheet.Shapes.AddShape(msoShapeRectangle, 0, 0, 200, DefaultSize.BodyHeight)
            
        With shpBody
            .Fill.ForeColor.RGB = rgbWhite
            .Line.ForeColor.RGB = rgbGray
            
            .TextFrame2.TextRange.Font.NameFarEast = "Meiryo UI"
            .TextFrame.Characters.Font.Color = RGB(70, 70, 70)
            .TextFrame.Characters.Font.Size = 10
            .TextFrame.Characters.Text = "ヘッダとこの部分は自由に記入することが出来ます。" & vbCrLf & _
                                            "サイズの伸縮も可能で、フォームが崩れても開閉すると自動調整されます。"
            
            .TextFrame.MarginBottom = 2
            .TextFrame.MarginLeft = 6
            .TextFrame.MarginRight = 6
            .TextFrame.MarginTop = 2
            .Name = strBodyName & strCallerNumber
        End With
        
        Set MakeBody = shpBody
        
    End Function
    
    '*******************************************
    ' 最背面の影
    '*******************************************
    Function MakeShadow(ByVal strCallerNumber As String) As Shape
        
        Dim shpShadow As Shape
        Set shpShadow = ActiveSheet.Shapes.AddShape(msoShapeRectangle, 0, 0, 200, DefaultSize.BodyHeight + DefaultSize.HeaderHeight)
            
        With shpShadow
            .Fill.ForeColor.RGB = rgbWhite
            .Line.ForeColor.RGB = rgbGray
            .TextFrame.Characters.Font.Color = RGB(80, 80, 80)
            .TextFrame.Characters.Font.Bold = True
            .TextFrame.Characters.Font.Size = 10
            
            .TextFrame.MarginBottom = 0
            .TextFrame.MarginLeft = 0
            .TextFrame.MarginRight = 0
            .TextFrame.MarginTop = 0
            .Name = strShadowName & strCallerNumber
            .Shadow.Type = msoShadow21
        End With
        
        Set MakeShadow = shpShadow
        
    End Function
    
    '*******************************************
    ' 全てのパーツをグループ化
    '*******************************************
    Sub FormGrouping(ByRef typShapeForm As ShapeForm)
        
        '全てをグループ化し1つのフォームへ
        With ActiveSheet.Shapes.Range(Array(typShapeForm.HeaderName, typShapeForm.OpenName, typShapeForm.CloseName, typShapeForm.BodyName, typShapeForm.ShadowName)).Group
            .Name = typShapeForm.ParentName
            .Placement = xlFreeFloating
        End With
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ShapeFormの表示切り替え機能
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*******************************************
    ' 最小化
    '*******************************************
    Sub FormClose()
        
        'フォームの枝番を取得
        Dim strCallerNumber As String
        strCallerNumber = Split(Application.Caller, "_")(2)
        
        Dim typShapeForm As ShapeForm
        Call SetFormDefault(strCallerNumber, typShapeForm, True)
        
    End Sub
    
    '*******************************************
    ' 展開
    '*******************************************
    Sub FormOpen()
        
        'フォームの枝番を取得
        Dim strCallerNumber As String
        strCallerNumber = Split(Application.Caller, "_")(2)
        
        Dim typShapeForm As ShapeForm
        Call SetFormDefault(strCallerNumber, typShapeForm, False)
        
    End Sub
    
    '*******************************************
    ' 最小化
    '*******************************************
    Sub SetFormDefault(ByVal strCallerNumber As String, ByRef typShapeForm As ShapeForm, ByVal blnClose As Boolean)
        
        With typShapeForm
            
            '枝番から各種パーツの名称を特定
            .ParentName = strParentName & strCallerNumber
            .HeaderName = strHeaderName & strCallerNumber
            .OpenName = strOpenName & strCallerNumber
            .CloseName = strCloseName & strCallerNumber
            .BodyName = strBodyName & strCallerNumber
            .ShadowName = strShadowName & strCallerNumber
            
            '各種パーツを取得
            Set .Parent = ActiveSheet.Shapes(.ParentName)
            Set .Header = ActiveSheet.Shapes(.HeaderName)
            Set .Close = ActiveSheet.Shapes(.CloseName)
            Set .Open = ActiveSheet.Shapes(.OpenName)
            Set .Body = ActiveSheet.Shapes(.BodyName)
            Set .Shadow = ActiveSheet.Shapes(.ShadowName)
            
            'グループ化を解除
            '※グループ化を解除しないとパーツのサイズ変更が全て連動してしまう！！
            .Parent.Ungroup
            
            'ヘッダの調整
            .Header.Height = DefaultSize.HeaderHeight
            If .Header.Width > .Body.Width Then
                .Body.Width = .Header.Width
            Else
                .Header.Width = .Body.Width
            End If
            
            '「〇」ボタンの調整
            .Open.Height = DefaultSize.HeaderHeight
            .Open.Width = DefaultSize.HeaderHeight
            
            '「×」ボタンの調整
            .Close.Height = DefaultSize.HeaderHeight
            .Close.Width = DefaultSize.HeaderHeight
            
            '本文部分の調整
            .Body.Left = .Header.Left
            .Body.Top = .Header.Top + DefaultSize.HeaderHeight
            
            '閉じる際に「閉じる前のサイズ」を保存
            If blnClose = True Then
                
                '本文が「展開状態」だったらサイズを「Shadow」に保存
                If .Body.Height > 0 Then
                    .Shadow.TextFrame.Characters.Text = .Body.Height
                End If
                .Body.Height = 0
                
            '「展開」の場合は「Shadow」に保存された数値から復元
            ElseIf .Body.Height = 0 Then
                
                If IsNumeric(.Shadow.TextFrame.Characters.Text) = True Then
                    .Body.Height = .Shadow.TextFrame.Characters.Text
                Else
                    .Body.Height = DefaultSize.BodyHeight
                End If
                
            '「展開」を何度もクリックされていたらサイズを保存
            '※サイズ微調整の可能性があるため
            Else
                .Shadow.TextFrame.Characters.Text = .Body.Height
            End If
            
            'ボタンをヘッダ右端に寄せる
            .Close.Top = .Header.Top
            .Open.Top = .Header.Top
            .Close.Left = .Header.Left + .Header.Width - DefaultSize.HeaderHeight
            .Open.Left = .Close.Left - DefaultSize.HeaderHeight
            
            '「Shadow」最背面で全体のサイズと一致させる
            .Shadow.Top = .Header.Top
            .Shadow.Left = .Header.Left
            .Shadow.Height = .Header.Height + .Body.Height
            .Shadow.Width = .Header.Width
            
        End With
        
        '全てのパーツをグループ化
        Call FormGrouping(typShapeForm)
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 「○○シートに戻る」ボタンを生成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function MakeBackLinkButton(ByVal wsTarget As Worksheet, ByVal wsHome As Worksheet) As Shape
        
        Dim shpLinkButton As Shape
        Set shpLinkButton = wsTarget.Shapes.AddShape(msoShapeRectangle, 0, 0, 130, 16)
            
        With shpLinkButton
            .Fill.ForeColor.RGB = rgbYellow
            .Line.ForeColor.RGB = rgbRed
            
            '.TextFrame2.TextRange.Font.NameFarEast = "Meiryo UI"
            .TextFrame.Characters.Font.Color = rgbRed
            .TextFrame.Characters.Font.Bold = True
            .TextFrame.Characters.Font.Size = 9
            .TextFrame.Characters.Text = "←「" & wsHome.Name & "」シートに戻る"
            
            .TextFrame.MarginBottom = 0
            .TextFrame.MarginLeft = 0
            .TextFrame.MarginRight = 0
            .TextFrame.MarginTop = 0
            .TextFrame.VerticalAlignment = xlVAlignCenter
            .TextFrame.HorizontalAlignment = xlHAlignCenter
            
            .Left = wsTarget.Range("B1").Left
            
            wsTarget.Hyperlinks.Add shpLinkButton, "", "'" & wsHome.Name & "'!A1"
            
        End With
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 散布図作成の手抜き機能
' 全データを別系列として登録することにより、ラベルを付加できる！！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub ScatterPlot(ByVal rngLabel As Range, ByVal rngX As Range, ByVal rngY As Range)
        
        'データと同じシート上にグラフを生成
        Dim wsTarget As Worksheet
        Set wsTarget = rngLabel.Parent
        
        'グラフを追加
        Dim objScatterPlot As Object
        Set objScatterPlot = wsTarget.Shapes.AddChart2
        
        With objScatterPlot.Chart
            
            .ChartType = xlXYScatter
            .HasTitle = False
            .HasLegend = False
            
            'グラフ内のデフォルトデータを削除
            Dim intIndex As Integer
            For intIndex = .SeriesCollection.Count To 1 Step -1
                .SeriesCollection(intIndex).Delete
            Next
            
            'グラフのデータ範囲指定が「文字列」のためシート名を取得
            Dim strWsName As String
            strWsName = wsTarget.Name
            
            Dim lngRow As Long
            For lngRow = 1 To rngLabel.Rows.Count
                
                '新しい系列としてデータを追記
                With .SeriesCollection.NewSeries
                    .Name = "='" & strWsName & "'!" & rngLabel.Cells(lngRow, 1).Address
                    .XValues = "='" & strWsName & "'!" & rngX.Cells(lngRow, 1).Address
                    .Values = "='" & strWsName & "'!" & rngY.Cells(lngRow, 1).Address
                    .HasDataLabels = True
                    .HasLeaderLines = True
                    .DataLabels.Position = xlLabelPositionRight
                    .DataLabels.ShowSeriesName = True
                    .DataLabels.ShowValue = False
                End With
                
            Next
        End With
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' PowerPointを使用した動画編集
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*************************************************
    ' 指定動画ファイルのプロパティを取得
    ' ※動画ファイルじゃない場合、指定プロパティが空欄のはずなので
    ' 　返り値が無になる前提で関数を作成しています
    '*************************************************
    
    Function GetVideoData(ByVal strVideoDataPath As String) As Variant
        
        Dim objFSO As Object
        Set objFSO = CreateObject("Scripting.FileSystemObject")
        
        Dim strFileName As String
        Dim vntDataFolder As Variant
        strFileName = objFSO.GetFileName(strVideoDataPath)
        vntDataFolder = objFSO.GetParentFolderName(strVideoDataPath)
        
        Dim objNameSpace As Object
        Set objNameSpace = CreateObject("Shell.Application").Namespace(vntDataFolder)
        
        '「ファイル名」「長さ」「フレーム幅」「フレーム高」
        Dim aryResult(1 To 4) As Variant
        aryResult(1) = strFileName
        
        'プロパティの数は膨大なのでとりあえず「500」まで調査する
        Dim intIndex As Integer
        For intIndex = 0 To 500
            
            '動画ファイルであれば下記プロパティがすべてあるはず！！
            If objNameSpace.GetDetailsOf(Nothing, intIndex) = "長さ" Then
                aryResult(2) = objNameSpace.GetDetailsOf(objNameSpace.ParseName(strFileName), intIndex)
            ElseIf objNameSpace.GetDetailsOf(Nothing, intIndex) = "フレーム幅" Then
                aryResult(3) = objNameSpace.GetDetailsOf(objNameSpace.ParseName(strFileName), intIndex)
            ElseIf objNameSpace.GetDetailsOf(Nothing, intIndex) = "フレーム高" Then
                aryResult(4) = objNameSpace.GetDetailsOf(objNameSpace.ParseName(strFileName), intIndex)
            End If
            
            '全てのプロパティが揃ったら配列を返却
            '※「プロパティが揃わなかったら動画ではない」と判断し値を返さない
            If aryResult(2) <> "" And aryResult(3) <> "" And aryResult(4) <> "" Then
                GetVideoData = aryResult
                Exit Function
            End If
        Next
        
    End Function
    
    
    '*************************************************
    ' 指定動画ファイル・設定を適用したスライドを追加
    ' ※PowerPointPresentationは関数外で作成済み
    '
    '   'PowerPointファイルを新規作成
    '   Dim objPowerPointPresentation As Object
    '   Set objPowerPointPresentation = CreateObject("PowerPoint.Application").Presentations.Add
    '
    '   '各種設定の完了したパワポを動画出力
    '   objPowerPointPresentation.CreateVideo Filename:=wsMain.Range(strRngOutputFileName).Value, VertResolution:=1080, Quality:=80
    '
    '*************************************************
    
    Sub AddMovieSlide(ByVal strFilePath As String, ByVal dteStartTime As Date, ByVal dteEndTime As Date, ByVal objPowerPointPresentation As Object)
        
        '「時間」を「1/1000秒単位の整数」に変換
        Dim lngStartTime As Long
        Dim lngEndTime As Long
        lngStartTime = dteStartTime * 24 * 60 * 60 * 1000
        lngEndTime = dteEndTime * 24 * 60 * 60 * 1000
        
        '末尾にスライドを追加
        Dim intSlideIndex As Integer
        intSlideIndex = objPowerPointPresentation.Slides.Count + 1
        objPowerPointPresentation.Slides.Add intSlideIndex, 1
        
        '追加した末尾のスライドを操作
        With objPowerPointPresentation.Slides(intSlideIndex)
            
            'スライドに動画を追加
            '※スライドいっぱいのサイズに引き伸ばし
            Call .Shapes.AddMediaObject2(Top:=0, Left:=0, _
                    Width:=objPowerPointPresentation.PageSetup.SlideWidth, _
                    Height:=objPowerPointPresentation.PageSetup.SlideHeight, _
                    Filename:=strFilePath)
            
            '動画の開始・終了タイミングを設定
            With .Shapes(.Shapes.Count)
                .MediaFormat.StartPoint = lngStartTime
                .MediaFormat.EndPoint = lngEndTime
            End With
            
            '動画の自動再生などを設定
            With .Shapes(.Shapes.Count).AnimationSettings
                .AdvanceMode = 2
                .AdvanceTime = 0
                .Animate = True
                .PlaySettings.PlayOnEntry = True
            End With
            
            '動画の再生時間とスライドの表示時間を一致させる
            '※スライドは「秒」指定なので「/1000」必須！
            With .SlideShowTransition
                .AdvanceOnTime = True
                .AdvanceTime = (lngEndTime - lngStartTime) / 1000
            End With
            
        End With
                
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 「7-Zip」or「Lhaplus」を使用してフォルダをパスワードZipに圧縮
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '標準的なインストール先
    Const strLhaplusPath As String = "C:\Program Files (x86)\Lhaplus\Lhaplus.exe"
    Const str7ZipPath As String = "C:\Program Files\7-Zip\7z.exe"
    
    '**********************************
    ' 「7-Zip」or「Lhaplus」がインストールされているか？
    '**********************************
    Function IsZipApplicationExists() As Boolean
        
        If Is7ZipExists = False And IsLhaplusExists = False Then
            IsZipApplicationExists = False
        Else
            IsZipApplicationExists = True
        End If
        
    End Function
    
    '**********************************
    ' 「7-Zip」がインストールされているか？
    '**********************************
    Function Is7ZipExists() As Boolean
        
        If Dir(str7ZipPath) = "" Then
            Is7ZipExists = False
        Else
            Is7ZipExists = True
        End If
        
    End Function
    
    '**********************************
    ' 「Lhaplus」がインストールされているか？
    '**********************************
    Function IsLhaplusExists() As Boolean
        
        If Dir(strLhaplusPath) = "" Then
            IsLhaplusExists = False
        Else
            IsLhaplusExists = True
        End If
        
    End Function
        
    '**********************************
    ' 「7-Zip」or「Lhaplus」による出力
    ' ※事前チェック実施済みが前提
    ' 　「Else」にメッセージを追加しても良いかも？
    '**********************************
    Function CompressPasswordZip(ByVal strTargetFolder As String, ByVal strOutputFolder As String, ByVal strPassword As String, ByVal blnUse7Zip As Boolean, ByVal blnUseLhaplus As Boolean)
        
        If blnUse7Zip = True Then
            Call CompressPasswordZipBy7Zip(strTargetFolder, strOutputFolder, strPassword)
        ElseIf blnUseLhaplus = True Then
            Call CompressPasswordZipByLhaplus(strTargetFolder, strOutputFolder, strPassword)
        End If
        
    End Function
    
    '**********************************
    ' 「7-Zip」による出力
    '**********************************
    Function CompressPasswordZipBy7Zip(ByVal strTargetFolder As String, ByVal strOutputFolder As String, Optional ByVal strPassword As String = "") As Boolean
        
        'パスワード指定なし
        If strPassword = "" Then
        
            Dim strCommand As String
            strCommand = """" & str7ZipPath & """ a -tzip """ & strOutputFolder & """ """ & strTargetFolder & """"
        
        'パスワード指定あり
        Else
            strCommand = """" & str7ZipPath & """ a -tzip -p" & strPassword & " """ & strOutputFolder & """ """ & strTargetFolder & """"
        End If
        
        'コマンド実行⇒完了まで待ち
        Dim objExec As Object
        Set objExec = CreateObject("WScript.Shell").Exec(strCommand)
        
        Do Until objExec.Status
            DoEvents
        Loop
        
    End Function
    
    '**********************************
    ' 「Lhaplus」による出力
    '**********************************
    Function CompressPasswordZipByLhaplus(ByVal strTargetFolder As String, ByVal strOutputFolder As String, Optional ByVal strPassword As String = "") As Boolean
        
        'コマンドを連結⇒まずは「出力先フォルダ」を指定
        Dim strCommand As String
        strCommand = strLhaplusPath & " /c:zip /o:""" & strOutputFolder & """"
        
        'パスワードの指定があれば追加
        If strPassword <> "" Then
            strCommand = strCommand & " /p:" & strPassword
        End If
        
        '圧縮対象フォルダを選択
        strCommand = strCommand & " " & """" & strTargetFolder & """"
        
        'コマンド実行⇒完了まで待ち
        Dim objExec As Object
        Set objExec = CreateObject("WScript.Shell").Exec(strCommand)
        Do Until objExec.Status
            DoEvents
        Loop
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' PDF加工関数
' ※PowerShellコマンドを生成して実行
' ※itextsharp.dllを使用
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '************************************************
    ' PDF用パスワード設定関数
    '************************************************
    Function SetPasswordPDF(ByVal strInFilePath As String, ByVal strOutFilePath As String, ByVal strPassword As String, ByVal strDllPath As String) As Boolean
                        
        Dim strCommand As String
        
        strCommand = "" & _
            "$inpath = '" & strInFilePath & "';" & vbCrLf & _
            "$outpath = '" & strOutFilePath & "';" & vbCrLf & _
            "$password = '" & strPassword & "';" & vbCrLf & _
            "$dllpath = '" & strDllPath & "';" & vbCrLf & _
            "Add-Type -Path ($dllpath);" & vbCrLf & _
            "$reader = New-Object iTextSharp.text.pdf.PdfReader($inpath);" & vbCrLf & _
            "$fs = New-Object System.IO.FileStream($outpath,[System.IO.FileMode]::OpenOrCreate);" & vbCrLf & _
            "[iTextSharp.text.pdf.PdfEncryptor]::Encrypt($reader, $fs, $true, $password, $password, [iTextSharp.text.pdf.PdfWriter]::ALLOW_PRINTING);" & vbCrLf & _
            "$fs.Close();" & vbCrLf & _
            "$reader.Close();"
        
        Dim objWSH As Object
        Set objWSH = CreateObject("WScript.Shell")
        objWSH.Run "powershell -Command " & strCommand, 0, True
        
        SetPasswordPDF = CreateObject("Scripting.FileSystemObject").FileExists(strOutFilePath)
        
    End Function
    
    '********************************************************************
   ' PDFファイルページ数を取得
    '********************************************************************
    Function GetPdfPageCount(ByVal strTargetFilePath As String, ByVal strDllPath As String) As Long
        
        '※コマンド最後のExitは本来はステータスを返却するためのものなので、
        '　エラーが発生した際など、意図しない数値を返却する恐れあり
        Dim strCommand As String
        
        '変数設定
        strCommand = "" & _
            "$dllpath = '" & strDllPath & "';" & _
            "$targetpath = '" & strTargetFilePath & "';"
        
        'PDFファイルのページ数を取得
        strCommand = strCommand & _
            "Add-Type -Path ($dllpath);" & _
            "$reader = New-Object iTextSharp.text.pdf.PdfReader($targetpath);" & _
            "$pages = $reader.NumberOfPages;" & _
            "$reader.Close();" & _
            "exit $pages"
        
        'コマンドを実行し返り値を返却
        GetPdfPageCount = CreateObject("WScript.Shell").Run("PowerShell " & strCommand, 0, True)
        
    End Function
    
    '********************************************************************
    ' PDFファイルをページ範囲を指定して分割別ファイル出力
    '********************************************************************
    Sub SplitPdfByPageNumber(ByVal strTargetFilePath As String, ByVal strOutFilePath As String, ByVal intStartPage As Integer, ByVal intEndPage As Integer, ByVal strDllPath As String)
        
        Dim strCommand As String
        
        '変数設定
        strCommand = "" & _
                    "$infilepath = '" & strTargetFilePath & "';" & _
                    "$outfilepath = '" & strOutFilePath & "';" & _
                    "$dllpath = '" & strDllPath & "';" & _
                    "$startpage = " & intStartPage & ";" & _
                    "$endpage = " & intEndPage & ";"
        
        'DLL読み込み⇒実行
        strCommand = strCommand & _
                    "Add-Type -Path ($dllpath);" & _
                    "$pdfReader = New-Object iTextSharp.text.pdf.PdfReader($infilepath);" & _
                    "$pageTo = $page + 3;" & _
                    "$document = New-Object iTextSharp.text.Document;" & _
                    "$filestream = New-Object System.IO.FileStream($outfilepath, [System.IO.FileMode]::Create);" & _
                    "$pdfCopy = New-Object iTextSharp.text.pdf.PdfSmartCopy($document, $filestream);" & _
                    "$document.Open();" & _
                    "foreach ($addPage in $startpage..$endpage) {" & _
                        "$pdfcopy.AddPage($pdfcopy.GetImportedPage($pdfReader, $addPage));" & _
                    "}" & _
                   "$document.Close();" & _
                    "$pdfCopy.Close();" & _
                    "$filestream.Close();" & _
                    "$pdfReader.Close();"
        
        '指定ページ範囲の分割出力を実行
        Call CreateObject("WScript.Shell").Run("PowerShell " & strCommand, 0, True)
        
    End Sub
    
    
    '********************************************************************
    ' 配列にて指定されたすべてのPDFファイルを結合して出力
    '********************************************************************
    Sub JoinPdfFiles(ByVal strOutFilePath As String, ByRef aryPdfFilePath As Variant, ByVal strDllPath As String)
        
        Dim intIndex As Integer
        Dim strAllPdfFileNamesArray As String
        
        'PowerShellの配列形式に変換 @('A', 'B', 'C')
        strAllPdfFileNamesArray = "@("
        For intIndex = LBound(aryPdfFilePath) To UBound(aryPdfFilePath)
            strAllPdfFileNamesArray = strAllPdfFileNamesArray & _
                        "'" & aryPdfFilePath(intIndex) & "',"
        Next
        strAllPdfFileNamesArray = Left(strAllPdfFileNamesArray, Len(strAllPdfFileNamesArray) - 1) & ")"
        
        Dim strCommand As String
        
        '変数設定
        strCommand = "" & _
                    "$outfilepath = '" & strOutFilePath & "';" & _
                    "$dllpath = '" & strDllPath & "';" & _
                    "$infiles = " & strAllPdfFileNamesArray & ";"
        
        '配列に格納されたファイルをすべて開き結合
        strCommand = strCommand & _
                    "Add-Type -Path ($dllpath);" & _
                    "$filestream = New-Object System.IO.FileStream($outfilepath, [System.IO.FileMode]::Create);" & _
                    "$document = New-Object iTextSharp.text.Document;" & _
                    "$pdfCopy = New-Object iTextSharp.text.pdf.PdfSmartCopy($document, $fileStream);" & _
                    "$document.Open();" & _
                    "foreach($infile in $infiles) {" & _
                        "$reader = New-Object iTextSharp.text.pdf.PdfReader($infile);" & _
                        "$pdfCopy.AddDocument($reader);" & _
                        "$reader.Close();" & _
                    "}" & _
                    "$pdfCopy.Close();" & _
                    "$document.Close();" & _
                    "$filestream.Close();"
        
        'ファイル結合コマンドの実行
        Call CreateObject("WScript.Shell").Run("PowerShell " & strCommand, 0, True)
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 指定シートをそのままCSVファイルとして出力
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function OutputCsvFromWorksheet(ByVal wsTarget As Worksheet, ByVal strFileName As String) As Boolean
        
        With wsTarget
            
            '本関数途中終了はエラー
            OutputCsvFromWorksheet = False
            
            Dim lngLastRow As Long
            Dim lngLastColumn As Long
            lngLastRow = GetLastRow(.Cells.Parent, "A")
            lngLastColumn = GetLastColumn(.Cells.Parent, 1)
            
            'データが存在しないので出力不要
            If lngLastRow = 1 Then
                Exit Function
            End If
            
            'CSV生成開始
            Dim intFileNumber As Integer
            intFileNumber = FreeFile
            Open ThisWorkbook.Path & "\" & strFileName For Output As #intFileNumber
            
            Dim lngRow As Long
            For lngRow = 1 To lngLastRow
                
                Dim lngColumn As Long
                For lngColumn = 1 To lngLastColumn
                    
                    If lngColumn <> lngLastColumn Then
                        Print #intFileNumber, """" & .Cells(lngRow, lngColumn).Value & """,";
                    Else
                        Print #intFileNumber, """" & .Cells(lngRow, lngColumn).Value & """" & vbLf;
                    End If
                    
                Next
            Next
            
        End With
        
        Close #intFileNumber
        
        '全ての処理が完了したので処理継続OK
        OutputCsvFromWorksheet = True
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' シートやCSVファイルに対してSQLを実行
' ※接続先を変更すればCSV、AccessDB区別なく処理可能
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ※エクセル内でSQLを実行するためにはIDを文字列にする必要がありそう（？）
' ※CSVファイルを直接結合する方法は不安なので
'  「①ブック内に読み込み ⇒ ②キーを文字列に変換 ⇒ ③SQLを実行」
' 　が安全そうではある。
' ※エクセル内SQLは「文字列・数値」が混在した場合「列の型を勝手に定義して、不正なデータを消す」
' 　という仕様があるので、データが消滅していないか？の確認は必須！
' ※エクセルは「"" or Null」の判別が困難なので、下記方法で判断を行うこと！
' 　× ⇒ IsNull(カラム名)
' 　〇 ⇒ カラム名 & '' = ''
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ファイル自身の各シートに対してSQLを実行する関数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '************************************************
    ' 本エクセルブック内のシートに対してSQL実行
    '************************************************
    Function AddDataBySql(ByVal wsDataTable As Worksheet, ByVal strSql As String, Optional ByVal blnRefresh As Boolean = False, Optional ByVal blnOverWrite As Boolean)
        
        Dim adoConnection As Object
        Dim adoRecordset As Object
        Set adoConnection = AdoConnectThisBook
        Set adoRecordset = CreateObject("ADODB.Recordset")
        
        Const adOpenKeyset = 1
        Const adLockReadOnly = 1
        
        adoRecordset.Open strSql, adoConnection, adOpenKeyset, adLockReadOnly
        
        With wsDataTable
            
            '貼り付け先シート初期化？
            If blnRefresh = True Then
                .Rows.Delete
            End If
            
            Dim lngWriteRow As Long
            
            '上書きの際は2行目から転記
            If blnOverWrite = True Then
                lngWriteRow = 2
            Else
                lngWriteRow = GetLastRow(wsDataTable, "A") + 1
            End If
            
            'SQLレコードセットを貼り付け
            .Cells(lngWriteRow, 1).CopyFromRecordset adoRecordset
            
            'ヘッダは毎回再設定
            .Rows(1).Clear
            Dim intIndex As Integer
            For intIndex = 0 To adoRecordset.Fields.Count - 1
                .Cells(1, intIndex + 1).Value = adoRecordset.Fields(intIndex).Name
            Next
        End With
        
        'オブジェクト破棄
        adoRecordset.Close
        Set adoRecordset = Nothing
        adoConnection.Close
        Set adoConnection = Nothing
        
    End Function
    
    '************************************************
    ' 本エクセルブックにDB接続
    '************************************************
    Function AdoConnectThisBook() As Object
        
        Dim adoConnection As Object
        
        Set adoConnection = CreateObject("ADODB.Connection")
        adoConnection.Provider = "Microsoft.ACE.OLEDB.12.0"
        adoConnection.Properties("Extended Properties") = "Excel 12.0;HDR=YES;IMEX=1"
        adoConnection.Open ThisWorkbook.FullName
        
        Set AdoConnectThisBook = adoConnection
        
    End Function
    
    '************************************************
    ' CSVファイルが保存されているフォルダにDB接続
    '************************************************
    Function AdoConnectCsvFolder(ByVal strCsvFolder As String) As Object
        
        Dim adoConnection As Object
        
        Set adoConnection = CreateObject("ADODB.Connection")
        adoConnection.Provider = "Microsoft.ACE.OLEDB.12.0"
        adoConnection.Properties("Extended Properties") = "text;HDR=YES;FMT=Delimited"
        adoConnection.Open strCsvFolder
        
        Set AdoConnectCsvFolder = adoConnection
                
    End Function
    
    '************************************************
    ' AccessDBに接続※パスワード対応
    '************************************************
    Function AdoConnectAccessDB(ByVal strAccessPath As String, Optional ByVal strPassword As String = "") As Object
        
        Dim adoConnection As Object
        
        Set adoConnection = CreateObject("ADODB.Connection")
        If strPassword = "" Then
            adoConnection.Open = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & strAccessPath
        Else
            adoConnection.Open = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & strAccessPath & ";Password=" & strPassword & ";"
        End If
        
        Set AdoConnectAccessDB = adoConnection
                
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' AccessDBをデータ格納用として使用するサンプル
' ※1ファイル1テーブルの単純設計
' ※「テーブル名」＝「DBファイル名」＝「エクセルシート名」で設計
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Const strAccessExtension As String = ".accdb"
    
    'AccessDB設定
    Type MstDB
        Path As String
        TableName As String
        CreateSQL As String
        FromToPairs As Variant
    End Type
        
    'Access定数
    Const adOpenForwardOnly As Integer = 0
    Const adOpenKeyset As Integer = 1
    Const adLockReadOnly As Integer = 1
    Const adLockPessimistic As Integer = 2
    Const adLockOptimistic As Integer = 3
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 構造体に処理対象シート・設定などを格納
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub AccessSample()
        
        Dim typTestDB As MstDB
        
        With typTestDB
            
            '************************************
            ' 処理対象AccessDB・テーブルの設定
            ' ※「テーブル名」＝「DBファイル名」＝「エクセルシート名」で設計
            '************************************
            .TableName = "TestTable"
            .Path = ThisWorkbook.Path & "\" & .TableName & ".accdb"
            
            'テーブル生成SQL
            .CreateSQL = "" & _
                    "CREATE TABLE " & _
                        .TableName & " (" & _
                            "氏名 TEXT(20), " & _
                            "点数 LONG, " & _
                            "誕生日 DATE)"
                            
            'シートの列⇒テーブルのフィールドの対応関係
            .FromToPairs = Array( _
                            Array("A", "氏名"), _
                            Array("D", "点数"), _
                            Array("K", "誕生日"))
            
            '************************************
            ' 処理開始開始
            '************************************
            
            '【0】実行前確認
            If MsgBox("「" & .TableName & "」の更新を実行してよろしいですか？", vbQuestion + vbYesNo) <> vbYes Then
                MsgBox "実行を中止します。"
                Exit Sub
            End If
                        
            '【1】既存テーブルを破棄
            Call DropTable(typTestDB)
            
            '【2】新規作成
            Call CreateTable(typTestDB)
            
            '【3】エクセル表をDBに格納
            Call InsertMst(typTestDB)
            
            '【4】AccessDBの最適化
            Call OptimizeAccessDb(typTestDB)
            
            MsgBox "「" & .TableName & "」の更新が完了しました。"
            
        End With
        
    End Sub
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' AccessDB操作関数
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '******************************************
    ' テーブルの削除関数
    '******************************************
    Sub DropTable(ByRef typMstDb As MstDB)
        
        'AccessDBへ接続
        Dim AdoConnection As Object
        Set AdoConnection = AdoConnectAccessDB(typMstDb.Path)
        
        'テーブルを削除
        AdoConnection.Execute "DROP TABLE " & typMstDb.TableName
        AdoConnection.Close
        Set AdoConnection = Nothing
        
    End Sub
    
    '******************************************
    ' テーブル生成関数
    '******************************************
    Sub CreateTable(ByRef typMstDb As MstDB)
        
        'AccessDBへ接続
        Dim AdoConnection As Object
        Set AdoConnection = AdoConnectAccessDB(typMstDb.Path)
        
        'テーブルを生成
        AdoConnection.Execute typMstDb.CreateSQL
        AdoConnection.Close
        Set AdoConnection = Nothing
        
    End Sub
    
    '******************************************
    ' テーブルへのデータ格納関数
    '******************************************
    Sub InsertMst(ByRef typMstDb As MstDB)
        
        With ThisWorkbook.Worksheets(typMstDb.TableName)
            
            'AccessDBに接続
            Dim AdoConnection As Object
            Set AdoConnection = AdoConnectAccessDB(typMstDb.Path)
            
            '対象テーブルに書き込み開始
            Dim adoRecordset As Object
            Set adoRecordset = CreateObject("ADODB.Recordset")
            adoRecordset.Open "[" & typMstDb.TableName & "]", AdoConnection, , adLockOptimistic
            
            'シート上のデータを順次投入
            Dim lngRow As Long
            For lngRow = 2 To GetLastRow(.Cells.Parent, "A")
                
                '新レコード（行）生成
                adoRecordset.addNew
                
                'エクセル列⇒DB列に転記
                Dim intIndex As Integer
                For intIndex = LBound(typMstDb.FromToPairs) To UBound(typMstDb.FromToPairs)
                    adoRecordset.Fields(typMstDb.FromToPairs(intIndex)(1)) = .Cells(lngRow, typMstDb.FromToPairs(intIndex)(0)).Value
                Next
                
                '行に値を適用
                adoRecordset.Update
                
            Next
            
            'オブジェクト破棄
            adoRecordset.Close
            Set adoRecordset = Nothing
            AdoConnection.Close
            Set AdoConnection = Nothing
            
        End With
        
    End Sub
    
    '******************************************
    ' AccessDBファイルの最適化・軽量化
    ' ※Accessファイルが「ファイルを閉じる際に最適化を実行する設定」
    ' 　になっているので、ファイルを開いて閉じるだけ。
    '******************************************
    Sub OptimizeAccessDb(ByRef typMstDb As MstDB)
        
        Dim objAccess As Object
        Set objAccess = CreateObject("Access.Application")
        
        With objAccess
            .OpenCurrentDatabase typMstDb.Path
            .CloseCurrentDatabase
            .Quit
        End With
        
    End Sub
    
    '************************************************
    ' AccessDBに接続※パスワード対応
    '************************************************
    Function AdoConnectAccessDB(ByVal strAccessPath As String, Optional ByVal strPassword As String = "") As Object
        
        Dim AdoConnection As Object
        
        Set AdoConnection = CreateObject("ADODB.Connection")
        If strPassword = "" Then
            AdoConnection.Open = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & strAccessPath
        Else
            AdoConnection.Open = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & strAccessPath & ";Jet OLEDB:Database Password=" & strPassword & ";"
        End If
        
        Set AdoConnectAccessDB = AdoConnection
                
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　WebAPIを使用したスクレイピング・クローリング備忘録
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub WebApiSample()
        
        'シンプルなWebApiリクエスト
        Dim objHttpRequest As Object
        Set objHttpRequest = CreateObject("MSXML2.XMLHTTP")
        
        With objHttpRequest
            .Open "GET", "https://sample.sample.jp", False
            .Send
            
            Do While .readyState < 4
                Application.Wait Now + TimeValue("00:00:01")
                DoEvents
            Loop
            
        End With
        
        '取得したHTMLファイルを直接操作
        '※ブラウザ不要
        Dim objHtmlDoc As Object
        Set objHtmlDoc = CreateObject("htmlfile")
        objHtmlDoc.write objHttpRequest.responseText
        
        '原因不明のエラーが起こるので実行速度調整
        Application.Wait Now + TimeValue("00:00:01")
        DoEvents
        
        'HTMLから必要なデータを抽出
        If InStr(objHtmlDoc.Title, "404エラー") = 0 Then
            Debug.Print objHtmlDoc.Title
            Debug.Print objHtmlDoc.querySelector(".titleLink a").innerText
        End If
        
        '連続データ収集を実行する際は必ずメモリを開放する
        '※メモリを大量に消費します！！
        Set objHttpRequest = Nothing
        Set objHtmlDoc = Nothing
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　Geminiと対話
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function PostToGemini(ByVal strQuestion As String)
        
        Const strGeminiUrl As String = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=API_KEY"
        
        Dim strPostData As String
        strPostData = "{""contents"": [{""parts"":[{""text"": """ + strQuestion + """}]}]}"
        
        Dim objHttp As Object
        Set objHttp = CreateObject("MSXML2.XMLHTTP")
        
        objHttp.Open "POST", strGeminiUrl, False
        objHttp.setRequestHeader "Content-Type", "application/json"
        objHttp.Send strPostData
        
        Dim strResponse As String
        strResponse = objHttp.strResponseText
        
        Debug.Print "Response: " & strResponse
        
        Dim dctResponse As Object
        Set dctResponse = JsonConverter.ParseJson(strResponse)
        
        Dim strResponseText As String
        If Not dctResponse Is Nothing Then
            If dctResponse.Exists("candidates") Then
                strResponseText = dctResponse("candidates")(1)("content")("parts")(1)("text")
            Else
                strResponseText = dctResponse("error")("message")
            End If
        Else
            strResponseText = "No valid JSON response"
        End If
        
        PostToGemini = Replace(Replace(Replace(strResponseText, "\n", vbLf), vbCr, ""), "*", "")
    
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　GoogleSpreaSheetをAPI経由で操作
'　※SpreadSheet経由でGmail、GoogleMap等を操作
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub GooglePost()
        
        'シンプルなWebApiリクエスト
        Dim objHttpRequest As Object
        Set objHttpRequest = CreateObject("MSXML2.ServerXMLHTTP")
        
        With objHttpRequest
            .Open "POST", strApiUrl, False
            .SetRequestHeader "Content-Type", "application/json"
            .send "{""a"":1,""b"":2,""d"":3}"
        End With
        
        Debug.Print objHttpRequest.responseText
        
    End Sub
    
    Sub GoogleGet()
        
        'シンプルなWebApiリクエスト
        Dim objHttpRequest As Object
        Set objHttpRequest = CreateObject("MSXML2.ServerXMLHTTP")
        
        Dim strUrlQuery As String
        strUrlQuery = strApiUrl & "?type=mail&to=test@gmail.com&subject=TESTMAIL&body=TESTMAILBODY"
        strUrlQuery = strApiUrl & "?type=holiday&start=2024/01/01&end=2024/12/31"
        strUrlQuery = strApiUrl & "?type=map&home=東京駅&shop=京王多摩センター駅"
        
        With objHttpRequest
            .Open "GET", strUrlQuery, False
            .SetRequestHeader "Content-Type", "application/x-www-form-urlencoded"
            .send
        End With
        
        Debug.Print objHttpRequest.responseText
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' GASコード
' ※デプロイ⇒ウェブアプリでURL取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'    function doPost(e) {
'      let book = SpreadsheetApp.getActiveSpreadsheet();
'      let sheet = book.getActiveSheet();
'      let params = JSON.parse(e.postData.getDataAsString());
'      sheet.getRange("A2").setValue(params.a);
'      sheet.getRange("B2").setValue(params.b);
'      sheet.getRange("C2").setValue(params.d);
'      sheet.getRange("D2").setValue("POST");
'      return;
'    }
'
'    function doGet(e) {
'      const parameter = e.parameter;
'
'      if (parameter.type == "map") {
'        return ContentService.createTextOutput(getBestRoute(parameter.home, parameter.shop));
'      } else if (parameter.type == "holiday") {
'        return ContentService.createTextOutput(getHolidays(parameter.start, parameter.end));
'      } else if (parameter.type == "mail") {
'        MailApp.sendEmail(parameter.to, parameter.subject, parameter.body, {htmlBody: parameter.body})
'        return ContentService.createTextOutput("OK");
'      }
'    }
'
'    function getBestRoute(home, shop) {
'      Const directions = Maps.newDirectionFinder()
'        .setOrigin (home)
'        .setAlternatives (True)
'        .setLanguage ("ja")
'        .setDestination (shop)
'        .setMode (Maps.DirectionFinder.Mode.TRANSIT)
'        .getDirections();
'
'      let results = [];
'      for (let i = 0; i < 5; i++) {
'        if (i < directions.routes.length) {
'          let route = directions.routes[i];
'          let distance = route.legs[0].distance.text;
'          let duration = route.legs[0].duration.text;
'          let fare = route.fare.text.replaceAll(",", "");
'          let text = home + "★⇒★";
'          route.legs[0].steps.forEach(function(step){
'            text += step.html_instructions + " " + step.duration.text + "★⇒★";
'          });
'          text = text.replace(route.legs[0].end_address, shop);
'          results.push([distance, duration, fare, text]);
'        } else {
'          results.push(["", "", ""]);
'        }
'      }
'      let resultsSort = results.sort((a, b) => {return Number.parseInt(a[2].replace("￥", "")) - Number.parseInt(b[2].replace("￥", "").replaceAll(",", ""))});
'      let resultText = "";
'      resultsSort.forEach(function(row){
'        resultText += row.toString() + "\n";
'      });
'      return resultText;
'    }
'
'    function getHolidays(startDate, endDate) {
'
'      startDate = new Date(startDate);
'      endDate = new Date(endDate);
'      const holidayCalendarId = 'ja.japanese#holiday@group.v.calendar.google.com';
'      const calendar = CalendarApp.getCalendarById(holidayCalendarId);
'      const events = calendar.getEvents(startDate, endDate);
'
'      let result = "";
'
'      for (const event of events) {
'        const holidayDate = Utilities.formatDate(event.getStartTime(), "JST", "yyyy/MM/dd");
'        const holidayTitle = event.getTitle();
'        result += `${holidayDate},${holidayTitle}\n`;
'      }
'      return result;
'    }
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 国土地理院API使用方法備忘録
' 住所文字列から「経度X」「緯度Y」情報を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetPointApi(ByVal strAddress As String) As Variant
            
        Dim strAddressEncode As String
       
        '住所文字列をURLエンコーディング
        strAddressEncode = Application.WorksheetFunction.EncodeURL(strAddress)
        
        Dim objHttpRequest As Object
        Set objHttpRequest = CreateObject("MSXML2.XMLHTTP")
        
        '国土地理院のAPIを使用
        With objHttpRequest
            .Open "GET", "https://msearch.gsi.go.jp/address-search/AddressSearch?q=" & strAddressEncode, False
            .Send
            
            Do While .readyState < 4
                DoEvents
            Loop
            
            'Json形式でレスポンスが返されます
            Dim objJson As Object
            Set objJson = ParseJson(.responseText)
        End With
        
        '「経度X」「緯度Y」の配列を返却
        GetPointApi = Array(objJson(1)("geometry")("coordinates")(2), objJson(1)("geometry")("coordinates")(1))
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 10進数を2進数に変換
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function ChangeDecimalToBinary(ByVal lngOriginNumber As Long, Optional ByVal intBaseNumber As Integer = 2) As Long
    
        Dim strDecimal As String
        Dim lngDividedNumber As Long
        Dim lngMod As Long
        lngMod = -1
        
        lngDividedNumber = lngOriginNumber
        lngMod = 0
        
        Do While lngDividedNumber <> 0
            
            lngMod = lngDividedNumber Mod intBaseNumber
            lngDividedNumber = Int(lngDividedNumber / intBaseNumber)
            strDecimal = lngMod & strDecimal
            
        Loop
        
        ChangeDecimalToBinary = Int(strDecimal)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ★標準Module★
' マスタの情報をすべて格納して管理するClassのテスト
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub MasterClassTest()
        
        Dim clsMasterData As ClassMasterData
        Set clsMasterData = New ClassMasterData
        
        clsMasterData.Add = ThisWorkbook.Worksheets("MST_1")
        clsMasterData.Add = ThisWorkbook.Worksheets("MST_2")
        
        Dim intIndex As Integer
        For intIndex = 1 To 20
            Debug.Print clsMasterData.GetValue("MST_1", intIndex, "氏名")
        Next
        
        For intIndex = 1001 To 1020
            Debug.Print clsMasterData.GetValue("MST_2", intIndex, "氏名")
        Next
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ★ClassModule★ClassMasterData
' マスタとして使用するシートの情報をクラス内に保存し
' シートにアクセスすることなく値を取得するクラス
' ※データ全てをDictionaryに格納したら重かったため、配列にて実装
' 　集計関数とか必要かなぁ・・・？
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*****************************************
    '{"SheetNameA": {"Columns" : {"Column1": 1, "Column2": 2, "Column3": 3, "Column4": 4},
    '                   "Keys" : {"Key1": 1, "Key2": 2, "Key3": 3, "Key4": 4},
    '                   "Values" : (( "Key1", "Value1", "Value2", "Value3"),
    '                               ( "Key2", "Value1", "Value2", "Value3"),
    '                               ( "Key3", "Value1", "Value2", "Value3"),
    '                               ( "Key4", "Value1", "Value2", "Value3")),
    ' "SheetNameB": {"Columns" : {"Column1": 1, "Column2": 2, "Column3": 3, "Column4": 4},
    '                   "Keys" : {"Key1": 1, "Key2": 2, "Key3": 3, "Key4": 4},
    '                   "Values" : (( "Key1", "Value1", "Value2", "Value3"),
    '                               ( "Key2", "Value1", "Value2", "Value3"),
    '                               ( "Key3", "Value1", "Value2", "Value3"),
    '                               ( "Key4", "Value1", "Value2", "Value3"))}
    '*****************************************
    
    Dim dctMasterDatas As Object
    Const strKey_ As String = "Keys"
    Const strColumns_ As String = "Columns"
    Const strValues_ As String = "Values"
    '*****************************************
    ' アンダースコアが見えるようにここにメモ。
    ' Key　　　⇒　ID　：配列の行番号
    ' Columns　⇒　列名：配列の列番号
    ' Values　 ⇒　全ての値を格納した配列
    '*****************************************
    
    
    '*****************************************
    ' Masterのデータを保持するDictionaryを生成
    '*****************************************
    Private Sub Class_Initialize()
        
        Set dctMasterDatas = CreateObject("Scripting.Dictionary")
        
    End Sub
    
    
    '*****************************************
    ' シートを指定するとMasterとしてデータを収集・保持する
    '【条件】
    ' ・1行目は必ずヘッダ
    ' ・1列目は必ずID
    '*****************************************
    
    Property Let Add(ByVal wsMasterSheet As Worksheet)
        
        'シート名をDictionaryのKeyに使用する
        Dim strWsMasterSheet As String
        strWsMasterSheet = wsMasterSheet.Name
        
        'Dictionaryに未登録のシートだったら
        If dctMasterDatas.Exists(strWsMasterSheet) = False Then
            
            'Dictionary内に「シート名Dictionary」を生成
            dctMasterDatas.Add strWsMasterSheet, CreateObject("Scripting.Dictionary")
            dctMasterDatas(strWsMasterSheet).Add strColumns_, CreateObject("Scripting.Dictionary")
            dctMasterDatas(strWsMasterSheet).Add strKey_, CreateObject("Scripting.Dictionary")
                        
            Dim lngRow As Long
            For lngRow = 2 To GetLastRow(wsMasterSheet, "A")
                
                '1列目をIDとする
                Dim strKey As String
                strKey = wsMasterSheet.Cells(lngRow, "A").Value
                
                'Key：行番号を保存（ヘッダは除外するので-1）
                If dctMasterDatas(strWsMasterSheet)(strKey_).Exists(strKey) = False Then
                    dctMasterDatas(strWsMasterSheet)(strKey_).Add strKey, lngRow - 1
                End If
            Next
            
            
            '「IDDictionary」内に「Key:Value」を格納
            '※Keyはヘッダの項目のため、ヘッダの重複厳禁！！
            Dim intColumn As Integer
            For intColumn = 1 To GetLastColumn(wsMasterSheet, 1)
                
                'ヘッダ名：列番号を保存
                Dim strColumn As String
                strColumn = wsMasterSheet.Cells(1, intColumn).Value
                If dctMasterDatas(strWsMasterSheet)(strColumns_).Exists(strColumn) = False Then
                    dctMasterDatas(strWsMasterSheet)(strColumns_).Add strColumn, intColumn
                End If
            Next
            
            Dim lngMasterLastRow As Long
            Dim intMasterLastColumn As Integer
            lngMasterLastRow = GetLastRow(wsMasterSheet, "A")
            intMasterLastColumn = GetLastColumn(wsMasterSheet, 1)
            
            'データを収集するための配列を宣言
            ReDim strTmpArray(1 To lngMasterLastRow, 1 To intMasterLastColumn) As String
            For lngRow = 2 To GetLastRow(wsMasterSheet, "A")
                For intColumn = 2 To GetLastColumn(wsMasterSheet, 1)
                    strTmpArray(lngRow - 1, intColumn) = wsMasterSheet.Cells(lngRow, intColumn).Value
                Next
            Next
            
            '配列に収集したデータをDictionaryに格納
            dctMasterDatas(strWsMasterSheet).Add strValues_, strTmpArray
            
        End If
        
    End Property
    
    
    '*****************************************
    ' Dictionaryの階層をたどって値を取得
    '*****************************************
    
    Property Get GetValue(ByVal strMasterName As String, ByVal strKey As String, ByVal strColumn As String) As String
        
        'Dictionaryに存在しない場合はアクセス不可
        If dctMasterDatas.Exists(strMasterName) = False Then
            GetValue = ""
            Exit Property
        ElseIf dctMasterDatas(strMasterName)(strKey_).Exists(strKey) = False Then
            GetValue = ""
            Exit Property
        ElseIf dctMasterDatas(strMasterName)(strColumns_).Exists(strColumn) = False Then
            GetValue = ""
            Exit Property
        End If
        
        'Key、Columnsから配列の位置を特定して値を返却
        Dim lngRow As Long
        Dim intColumn As Integer
        lngRow = dctMasterDatas(strMasterName)(strKey_)(strKey)
        intColumn = dctMasterDatas(strMasterName)(strColumns_)(strColumn)
        GetValue = dctMasterDatas(strMasterName)(strValues_)(lngRow, intColumn)
        
    End Property
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 最終行・列を取得
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Private Function GetLastRow(ByVal ws As Worksheet, Optional ByVal strColumn As String = "") As Long
                
        If strColumn = "" Then
            GetLastRow = ws.UsedRange.Cells(ws.UsedRange.Cells.Count).Row
        ElseIf IsNumeric(strColumn) Then
            GetLastRow = ws.Cells(ws.Rows.Count, strColumn * 1).End(xlUp).Row
        Else
            GetLastRow = ws.Cells(ws.Rows.Count, strColumn).End(xlUp).Row
        End If
        
    End Function
    
    Private Function GetLastColumn(ByVal ws As Worksheet, ByVal lngRow As Long) As Long
        
        GetLastColumn = ws.Cells(lngRow, ws.Columns.Count).End(xlToLeft).Column
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字の類似度を計算（コサイン類似度を使用）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function TextMatchRate(ByVal strA As String, ByVal strB As String, Optional ByVal intNgram As Integer = 1) As Double
        
        '文字列を整形
        strA = CleanFormat(strA)
        strB = CleanFormat(strB)
        
        '「全文字列」を連結
        '※A末尾・B先頭のNgramが出現するが・・・気にしない！
        Dim strAll As String
        strAll = strA & strB
        
        '「文字」にIDを付与
        Dim dctChars As Object
        Set dctChars = CreateNewDictionary
        
        'nグラム対応
        Dim intLength As Integer
        For intLength = 1 To intNgram
            
            Dim intIndex As Integer
            For intIndex = 1 To Len(strAll) - (intLength - 1)
                
                Dim strChar As String
                strChar = Mid(strAll, intIndex, intLength)
                
                If dctChars.Exists(strChar) = False Then
                    dctChars.Add strChar, dctChars.Count
                End If
                
            Next
            
        Next
        
        '文章内に存在する文字をカウントしVector化
        Dim intVectorA() As Integer
        Dim intVectorB() As Integer
        ReDim intVectorA(dctChars.Count - 1)
        ReDim intVectorB(dctChars.Count - 1)
        
        '文字列Aベクトル
        For intLength = 1 To intNgram
            For intIndex = 1 To Len(strA) - (intLength - 1)
                strChar = Mid(strA, intIndex, intLength)
                intVectorA(dctChars(strChar)) = intVectorA(dctChars(strChar)) + 1
            Next
        Next
        
        '文字列Bベクトル
        For intLength = 1 To intNgram
            For intIndex = 1 To Len(strB) - (intLength - 1)
                strChar = Mid(strB, intIndex, intLength)
                intVectorB(dctChars(strChar)) = intVectorB(dctChars(strChar)) + 1
            Next
        Next
        
        'ベクトルのコサイン類似度を計算
        With Application.WorksheetFunction
            
            Dim dblAB As Double
            dblAB = .SumProduct(intVectorA, intVectorB)
            
            Dim dblA As Double
            dblA = Sqr(.SumProduct(intVectorA, intVectorA))
            
            Dim dblB As Double
            dblB = Sqr(.SumProduct(intVectorB, intVectorB))
            
            TextMatchRate = dblAB / (dblA * dblB)
            
        End With
        
    End Function
    
    '***************************************
    ' 文字のベクトル変換前にフォーマットの統一
    '***************************************
    Function CleanFormat(ByVal strOrigin As String) As String
        
        Dim strClean As String
        strClean = strOrigin
        strClean = Replace(StrConv(StrConv(strClean, vbWide), vbUpperCase), "　", "")
        strClean = Replace(strClean, vbCrLf, "")
        strClean = Replace(strClean, vbCr, "")
        strClean = Replace(strClean, vbLf, "")
        strClean = Replace(strClean, vbTab, "")
        strClean = Trim(strClean)
        CleanFormat = strClean
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
' ****************************************************************
' TinySegmenter 0.1 Excel VBA Version
'  by arihagne
'
' Original JavaScript Version CopyRight Notice
'// TinySegmenter 0.1 -- Super compact Japanese tokenizer in Javascript
'// (c) 2008 Taku Kudo <taku@chasen.org>
'// TinySegmenter is freely distributable under the terms of a new BSD licence.
'// For details, see http://chasen.org/~taku/software/TinySegmenter/LICENCE.txt
' ****************************************************************

'*****************************************************************
' 下記より入手し、機能追記・不具合修正・機能解読中
' http://www16.plala.or.jp/arihagne/software/TinySegmenter.txt
'*****************************************************************

'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　Dictionary
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Private UC1__ As Object, UC2__ As Object, UC3__ As Object, UC4__ As Object, UC5__ As Object, UC6__ As Object
    Private UP1__ As Object, UP2__ As Object, UP3__ As Object
    Private UQ1__ As Object, UQ2__ As Object, UQ3__  As Object
    Private UW1__ As Object, UW2__ As Object, UW3__ As Object, UW4__ As Object, UW5__ As Object, UW6__  As Object
    
    Private BC1__ As Object, BC2__ As Object, BC3__ As Object
    Private BP1__ As Object, BP2__ As Object
    Private BQ1__ As Object, BQ2__ As Object, BQ3__ As Object, BQ4__ As Object
    Private BW1__ As Object, BW2__ As Object, BW3__ As Object
    
    Private TC1__ As Object, TC2__ As Object, TC3__ As Object, TC4__ As Object
    Private TQ1__ As Object, TQ2__ As Object, TQ3__ As Object, TQ4__ As Object
    Private TW1__ As Object, TW2__ As Object, TW3__ As Object, TW4__ As Object
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　名プロシージャ内でデータを複数回取得できるように
'　結果をクラス内広域変数に格納
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Dim aryResultWords As Variant
    Dim dctResultWords As Object
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　分かち書き機能
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*****************************************************************
    ' 分かち書き実行関数
    '*****************************************************************
    
    Function Segment(ByVal strOriginText As String, Optional ByVal arySkipCharacters As Variant = False, Optional ByVal blnSkipSingleKana As Boolean = False, _
                        Optional ByVal blnSkipAlphabet As Boolean = False, Optional ByVal blnSkipNumeric As Boolean = False) As Variant
        
        '改行文字等、無意味な文字を除外
        strOriginText = Replace(strOriginText, vbLf, "")
        strOriginText = Replace(strOriginText, vbCr, "")
        strOriginText = Replace(strOriginText, vbCrLf, "")
        strOriginText = Replace(strOriginText, vbTab, "")
        
        '「除外文字」を半角スペースに変換
        '※別の文字と連結して意味をなさないように半角スペースを挿入
        If IsArray(arySkipCharacters) Then
            Dim vntSkipWord As Variant
            For Each vntSkipWord In arySkipCharacters
                strOriginText = Replace(strOriginText, vntSkipWord, " ")
            Next
        End If
        
        '無駄を除外した結果、空文字だったら終了
        If Trim(strOriginText) = "" Then
            Segment = Array()
            Exit Function
        End If
        
        Dim lngScore As Long
        Dim strWord As String
        
        Dim p, p1, p2, p3
        Dim w1, w2, w3, w4, w5, w6
        Dim c1, c2, c3, c4, c5, c6
        
        Dim segArray()
        segArray = Array()
        Call ArrayPush(segArray, "B3")
        Call ArrayPush(segArray, "B2")
        Call ArrayPush(segArray, "B1")
        
        Dim ctypeArray()
        ctypeArray = Array()
        Call ArrayPush(ctypeArray, "O")
        Call ArrayPush(ctypeArray, "O")
        Call ArrayPush(ctypeArray, "O")
        
        '文章を「文字単位区切り」で配列に格納
        Dim aryOriginCharacter As Variant
        aryOriginCharacter = SplitByCharacter(strOriginText)
        
        Dim lngCharIndex As Long
        For lngCharIndex = LBound(aryOriginCharacter) To UBound(aryOriginCharacter)
            Call ArrayPush(segArray, aryOriginCharacter(lngCharIndex))
            Call ArrayPush(ctypeArray, ctype_(aryOriginCharacter(lngCharIndex)))
        Next lngCharIndex
            
        Call ArrayPush(segArray, "E1")
        Call ArrayPush(segArray, "E2")
        Call ArrayPush(segArray, "E3")
        
        Call ArrayPush(ctypeArray, "O")
        Call ArrayPush(ctypeArray, "O")
        Call ArrayPush(ctypeArray, "O")
        
        strWord = segArray(3)
        
        p1 = "U"
        p2 = "U"
        p3 = "U"
        
        '単語区切り配列を初期化
        aryResultWords = Array()
        Set dctResultWords = CreateObject("Scripting.Dictionary")
        
        Dim i As Long
        For i = 4 To UBound(segArray) - 3
            
            lngScore = BIAS__
            w1 = segArray(i - 3)
            w2 = segArray(i - 2)
            w3 = segArray(i - 1)
            w4 = segArray(i)
            w5 = segArray(i + 1)
            w6 = segArray(i + 2)
            c1 = ctypeArray(i - 3)
            c2 = ctypeArray(i - 2)
            c3 = ctypeArray(i - 1)
            c4 = ctypeArray(i)
            c5 = ctypeArray(i + 1)
            c6 = ctypeArray(i + 2)
            
            lngScore = lngScore + ts_(UP1__.Item(p1))
            lngScore = lngScore + ts_(UP2__.Item(p2))
            lngScore = lngScore + ts_(UP3__.Item(p3))
            lngScore = lngScore + ts_(BP1__.Item(p1 & p2))
            lngScore = lngScore + ts_(BP2__.Item(p2 & p3))
            lngScore = lngScore + ts_(UW1__.Item(w1))
            lngScore = lngScore + ts_(UW2__.Item(w2))
            lngScore = lngScore + ts_(UW3__.Item(w3))
            lngScore = lngScore + ts_(UW4__.Item(w4))
            lngScore = lngScore + ts_(UW5__.Item(w5))
            lngScore = lngScore + ts_(UW6__.Item(w6))
            lngScore = lngScore + ts_(BW1__.Item(w2 & w3))
            lngScore = lngScore + ts_(BW2__.Item(w3 & w4))
            lngScore = lngScore + ts_(BW3__.Item(w4 & w5))
            lngScore = lngScore + ts_(TW1__.Item(w1 & w2 & w3))
            lngScore = lngScore + ts_(TW2__.Item(w2 & w3 & w4))
            lngScore = lngScore + ts_(TW3__.Item(w3 & w4 & w5))
            lngScore = lngScore + ts_(TW4__.Item(w4 & w5 & w6))
            lngScore = lngScore + ts_(UC1__.Item(c1))
            lngScore = lngScore + ts_(UC2__.Item(c2))
            lngScore = lngScore + ts_(UC3__.Item(c3))
            lngScore = lngScore + ts_(UC4__.Item(c4))
            lngScore = lngScore + ts_(UC5__.Item(c5))
            lngScore = lngScore + ts_(UC6__.Item(c6))
            lngScore = lngScore + ts_(BC1__.Item(c2 & c3))
            lngScore = lngScore + ts_(BC2__.Item(c3 & c4))
            lngScore = lngScore + ts_(BC3__.Item(c4 & c5))
            lngScore = lngScore + ts_(TC1__.Item(c1 & c2 & c3))
            lngScore = lngScore + ts_(TC2__.Item(c2 & c3 & c4))
            lngScore = lngScore + ts_(TC3__.Item(c3 & c4 & c5))
            lngScore = lngScore + ts_(TC4__.Item(c4 & c5 & c6))
            'lngScore = lngScore + ts_(TC5__.Item( c4 & c5 & c6)
            lngScore = lngScore + ts_(UQ1__.Item(p1 & c1))
            lngScore = lngScore + ts_(UQ2__.Item(p2 & c2))
            lngScore = lngScore + ts_(UQ1__.Item(p3 & c3))
            lngScore = lngScore + ts_(BQ1__.Item(p2 & c2 & c3))
            lngScore = lngScore + ts_(BQ2__.Item(p2 & c3 & c4))
            lngScore = lngScore + ts_(BQ3__.Item(p3 & c2 & c3))
            lngScore = lngScore + ts_(BQ4__.Item(p3 & c3 & c4))
            lngScore = lngScore + ts_(TQ1__.Item(p2 & c1 & c2 & c3))
            lngScore = lngScore + ts_(TQ2__.Item(p2 & c2 & c3 & c4))
            lngScore = lngScore + ts_(TQ3__.Item(p3 & c1 & c2 & c3))
            lngScore = lngScore + ts_(TQ4__.Item(p3 & c2 & c3 & c4))
            
            p = "O"
            
            If lngScore > 0 Then
                
                strWord = Trim(strWord)
                
                '「かな1文字」を除外する場合
                If blnSkipSingleKana = True Then
                    If strWord Like "[あ-ん]" Then
                        strWord = ""
                    ElseIf strWord Like "[ア-ン]" Then
                        strWord = ""
                    End If
                End If
                
                '「アルファベットのみ」を除外する場合
                If blnSkipAlphabet = True Then
                    If Not strWord Like "*[!a-zA-Zａ-ｚＡ-Ｚ]*" Then
                        strWord = ""
                    End If
                End If
                
                '「数字のみ」を除外する場合
                If blnSkipNumeric = True Then
                    If Not strWord Like "*[!0-9０-９]*" Then
                        strWord = ""
                    End If
                End If
                                
                '「空文字」でなければ追加
                If strWord <> "" Then
                    
                    '新規発見単語だったら登録
                    If dctResultWords.Exists(strWord) = False Then
                        dctResultWords.Add strWord, 1
                    
                    '登録済み単語だったらカウントアップ
                    Else
                        dctResultWords(strWord) = dctResultWords(strWord) + 1
                    End If
                    
                    Call ArrayPush(aryResultWords, strWord)
                                        
                End If
                
                strWord = ""
                p = "B"
                
            End If
            
            p1 = p2
            p2 = p3
            p3 = p
            strWord = strWord & segArray(i)
            
        Next i
        
        Call ArrayPush(aryResultWords, strWord)
        
        '「単語＋単語出現数」を格納したDictionaryを返却
        Set Segment = dctResultWords
        
    End Function
    
    
    '*****************************************************************
    ' バイアス初期値の設定
    '*****************************************************************
    
    Function BIAS__() As Long
        
        BIAS__ = -332
        
    End Function
    
    
    '*****************************************************************
    ' 値が存在しない場合に「0」を返却するための安全関数？
    '*****************************************************************
    
    Private Function ts_(ByVal v As Long) As Long
        
        If IsEmpty(v) Then
            ts_ = 0
        Else
            ts_ = v
        End If
    
    End Function
    
    '*****************************************************************
    ' 文字の種類を判別
    '*****************************************************************
    
    Private Function ctype_(ByVal strWord As String) As String
        
        Dim strCharType As String
        strCharType = "O"
        
        Dim aryCharTypes As Variant
        aryCharTypes = Array( _
                        "[一二三四五六七八九十百千万億兆]:M", _
                        "[一-龠々〆ヵヶ]:H", _
                        "[ぁ-ん]:I", _
                        "[ァ-ヴーｱ-ﾝﾞｰ]:K", _
                        "[a-zA-Zａ-ｚＡ-Ｚ]:A", _
                        "[0-9０-９]:N")
        
        Dim intCharTypeIndex As Long
        For intCharTypeIndex = LBound(aryCharTypes) To UBound(aryCharTypes)
                
            If strWord Like Split(aryCharTypes(intCharTypeIndex), ":")(0) Then
                strCharType = Split(aryCharTypes(intCharTypeIndex), ":")(1)
                Exit For
            End If
        Next intCharTypeIndex
        
        ctype_ = strCharType
    
    End Function
    
    
    '*****************************************************************
    ' 配列末尾に文字列を追加
    '*****************************************************************
    
    Private Sub ArrayPush(ByRef vntArray As Variant, ByVal strWord As String)
        
        Dim lngResizeIndex As Long
        lngResizeIndex = UBound(vntArray) + 1
        ReDim Preserve vntArray(lngResizeIndex)
        vntArray(lngResizeIndex) = strWord
    
    End Sub
    
    
    '*****************************************************************
    ' 文章を「文字」単位に切り分け
    '*****************************************************************
    
    Private Function SplitByCharacter(ByVal strOriginText As String)
        
        Dim lngOriginTextLen As Long
        
        lngOriginTextLen = Len(strOriginText)
        ReDim tmpArray(lngOriginTextLen - 1)
        
        Dim lngCharacterIndex As Long
        For lngCharacterIndex = 1 To lngOriginTextLen
            tmpArray(lngCharacterIndex - 1) = Mid(strOriginText, lngCharacterIndex, 1)
        Next
        
        SplitByCharacter = tmpArray
    
    End Function
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　コンストラクタがDictionaryを初期化
'　※コードが膨大なため最下段に。本プロシージャ以下にコードはありません。
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Private Sub Class_Initialize()
        
        Set BC1__ = CreateObject("Scripting.Dictionary")
        BC1__.Add "HH", 6
        BC1__.Add "II", 2461
        BC1__.Add "KH", 406
        BC1__.Add "OH", -1378
        
        Set BC2__ = CreateObject("Scripting.Dictionary")
        BC2__.Add "AA", -3267
        BC2__.Add "AI", 2744
        BC2__.Add "AN", -878
        BC2__.Add "HH", -4070
        BC2__.Add "HM", -1711
        BC2__.Add "HN", 4012
        BC2__.Add "HO", 3761
        BC2__.Add "IA", 1327
        BC2__.Add "IH", -1184
        BC2__.Add "II", -1332
        BC2__.Add "IK", 1721
        BC2__.Add "IO", 5492
        BC2__.Add "KI", 3831
        BC2__.Add "KK", -8741
        BC2__.Add "MH", -3132
        BC2__.Add "MK", 3334
        BC2__.Add "OO", -2920
        
        Set BC3__ = CreateObject("Scripting.Dictionary")
        BC3__.Add "HH", 996
        BC3__.Add "HI", 626
        BC3__.Add "HK", -721
        BC3__.Add "HN", -1307
        BC3__.Add "HO", -836
        BC3__.Add "IH", -301
        BC3__.Add "KK", 2762
        BC3__.Add "MK", 1079
        BC3__.Add "MM", 4034
        BC3__.Add "OA", -1652
        BC3__.Add "OH", 266
        
        Set BP1__ = CreateObject("Scripting.Dictionary")
        BP1__.Add "BB", 295
        BP1__.Add "OB", 304
        BP1__.Add "OO", -125
        BP1__.Add "UB", 352
        
        Set BP2__ = CreateObject("Scripting.Dictionary")
        BP2__.Add "BO", 60
        BP2__.Add "OO", -1762
        
        Set BQ1__ = CreateObject("Scripting.Dictionary")
        BQ1__.Add "BHH", 1150
        BQ1__.Add "BHM", 1521
        BQ1__.Add "BII", -1158
        BQ1__.Add "BIM", 886
        BQ1__.Add "BMH", 1208
        BQ1__.Add "BNH", 449
        BQ1__.Add "BOH", -91
        BQ1__.Add "BOO", -2597
        BQ1__.Add "OHI", 451
        BQ1__.Add "OIH", -296
        BQ1__.Add "OKA", 1851
        BQ1__.Add "OKH", -1020
        BQ1__.Add "OKK", 904
        BQ1__.Add "OOO", 2965
        
        Set BQ2__ = CreateObject("Scripting.Dictionary")
        BQ2__.Add "BHH", 118
        BQ2__.Add "BHI", -1159
        BQ2__.Add "BHM", 466
        BQ2__.Add "BIH", -919
        BQ2__.Add "BKK", -1720
        BQ2__.Add "BKO", 864
        BQ2__.Add "OHH", -1139
        BQ2__.Add "OHM", -181
        BQ2__.Add "OIH", 153
        BQ2__.Add "UHI", -1146
        
        Set BQ3__ = CreateObject("Scripting.Dictionary")
        BQ3__.Add "BHH", -792
        BQ3__.Add "BHI", 2664
        BQ3__.Add "BII", -299
        BQ3__.Add "BKI", 419
        BQ3__.Add "BMH", 937
        BQ3__.Add "BMM", 8335
        BQ3__.Add "BNN", 998
        BQ3__.Add "BOH", 775
        BQ3__.Add "OHH", 2174
        BQ3__.Add "OHM", 439
        BQ3__.Add "OII", 280
        BQ3__.Add "OKH", 1798
        BQ3__.Add "OKI", -793
        BQ3__.Add "OKO", -2242
        BQ3__.Add "OMH", -2402
        BQ3__.Add "OOO", 11699
        
        Set BQ4__ = CreateObject("Scripting.Dictionary")
        BQ4__.Add "BHH", -3895
        BQ4__.Add "BIH", 3761
        BQ4__.Add "BII", -4654
        BQ4__.Add "BIK", 1348
        BQ4__.Add "BKK", -1806
        BQ4__.Add "BMI", -3385
        BQ4__.Add "BOO", -12396
        BQ4__.Add "OAH", 926
        BQ4__.Add "OHH", 266
        BQ4__.Add "OHK", -2036
        BQ4__.Add "ONN", -973
        
        Set BW1__ = CreateObject("Scripting.Dictionary")
        BW1__.Add ",と", 660
        BW1__.Add ",同", 727
        BW1__.Add "B1あ", 1404
        BW1__.Add "B1同", 542
        BW1__.Add "、と", 660
        BW1__.Add "、同", 727
        BW1__.Add "」と", 1682
        BW1__.Add "あっ", 1505
        BW1__.Add "いう", 1743
        BW1__.Add "いっ", -2055
        BW1__.Add "いる", 672
        BW1__.Add "うし", -4817
        BW1__.Add "うん", 665
        BW1__.Add "から", 3472
        BW1__.Add "がら", 600
        BW1__.Add "こう", -790
        BW1__.Add "こと", 2083
        BW1__.Add "こん", -1262
        BW1__.Add "さら", -4143
        BW1__.Add "さん", 4573
        BW1__.Add "した", 2641
        BW1__.Add "して", 1104
        BW1__.Add "すで", -3399
        BW1__.Add "そこ", 1977
        BW1__.Add "それ", -871
        BW1__.Add "たち", 1122
        BW1__.Add "ため", 601
        BW1__.Add "った", 3463
        BW1__.Add "つい", -802
        BW1__.Add "てい", 805
        BW1__.Add "てき", 1249
        BW1__.Add "でき", 1127
        BW1__.Add "です", 3445
        BW1__.Add "では", 844
        BW1__.Add "とい", -4915
        BW1__.Add "とみ", 1922
        BW1__.Add "どこ", 3887
        BW1__.Add "ない", 5713
        BW1__.Add "なっ", 3015
        BW1__.Add "など", 7379
        BW1__.Add "なん", -1113
        BW1__.Add "にし", 2468
        BW1__.Add "には", 1498
        BW1__.Add "にも", 1671
        BW1__.Add "に対", -912
        BW1__.Add "の一", -501
        BW1__.Add "の中", 741
        BW1__.Add "ませ", 2448
        BW1__.Add "まで", 1711
        BW1__.Add "まま", 2600
        BW1__.Add "まる", -2155
        BW1__.Add "やむ", -1947
        BW1__.Add "よっ", -2565
        BW1__.Add "れた", 2369
        BW1__.Add "れで", -913
        BW1__.Add "をし", 1860
        BW1__.Add "を見", 731
        BW1__.Add "亡く", -1886
        BW1__.Add "京都", 2558
        BW1__.Add "取り", -2784
        BW1__.Add "大き", -2604
        BW1__.Add "大阪", 1497
        BW1__.Add "平方", -2314
        BW1__.Add "引き", -1336
        BW1__.Add "日本", -195
        BW1__.Add "本当", -2423
        BW1__.Add "毎日", -2113
        BW1__.Add "目指", -724
        BW1__.Add "Ｂ１あ", 1404
        BW1__.Add "Ｂ１同", 542
        BW1__.Add "｣と", 1682
        
        Set BW2__ = CreateObject("Scripting.Dictionary")
        BW2__.Add "..", -11822
        BW2__.Add "11", -669
        BW2__.Add "――", -5730
        BW2__.Add "??", -13175
        BW2__.Add "いう", -1609
        BW2__.Add "うか", 2490
        BW2__.Add "かし", -1350
        BW2__.Add "かも", -602
        BW2__.Add "から", -7194
        BW2__.Add "かれ", 4612
        BW2__.Add "がい", 853
        BW2__.Add "がら", -3198
        BW2__.Add "きた", 1941
        BW2__.Add "くな", -1597
        BW2__.Add "こと", -8392
        BW2__.Add "この", -4193
        BW2__.Add "させ", 4533
        BW2__.Add "され", 13168
        BW2__.Add "さん", -3977
        BW2__.Add "しい", -1819
        BW2__.Add "しか", -545
        BW2__.Add "した", 5078
        BW2__.Add "して", 972
        BW2__.Add "しな", 939
        BW2__.Add "その", -3744
        BW2__.Add "たい", -1253
        BW2__.Add "たた", -662
        BW2__.Add "ただ", -3857
        BW2__.Add "たち", -786
        BW2__.Add "たと", 1224
        BW2__.Add "たは", -939
        BW2__.Add "った", 4589
        BW2__.Add "って", 1647
        BW2__.Add "っと", -2094
        BW2__.Add "てい", 6144
        BW2__.Add "てき", 3640
        BW2__.Add "てく", 2551
        BW2__.Add "ては", -3110
        BW2__.Add "ても", -3065
        BW2__.Add "でい", 2666
        BW2__.Add "でき", -1528
        BW2__.Add "でし", -3828
        BW2__.Add "です", -4761
        BW2__.Add "でも", -4203
        BW2__.Add "とい", 1890
        BW2__.Add "とこ", -1746
        BW2__.Add "とと", -2279
        BW2__.Add "との", 720
        BW2__.Add "とみ", 5168
        BW2__.Add "とも", -3941
        BW2__.Add "ない", -2488
        BW2__.Add "なが", -1313
        BW2__.Add "など", -6509
        BW2__.Add "なの", 2614
        BW2__.Add "なん", 3099
        BW2__.Add "にお", -1615
        BW2__.Add "にし", 2748
        BW2__.Add "にな", 2454
        BW2__.Add "によ", -7236
        BW2__.Add "に対", -14943
        BW2__.Add "に従", -4688
        BW2__.Add "に関", -11388
        BW2__.Add "のか", 2093
        BW2__.Add "ので", -7059
        BW2__.Add "のに", -6041
        BW2__.Add "のの", -6125
        BW2__.Add "はい", 1073
        BW2__.Add "はが", -1033
        BW2__.Add "はず", -2532
        BW2__.Add "ばれ", 1813
        BW2__.Add "まし", -1316
        BW2__.Add "まで", -6621
        BW2__.Add "まれ", 5409
        BW2__.Add "めて", -3153
        BW2__.Add "もい", 2230
        BW2__.Add "もの", -10713
        BW2__.Add "らか", -944
        BW2__.Add "らし", -1611
        BW2__.Add "らに", -1897
        BW2__.Add "りし", 651
        BW2__.Add "りま", 1620
        BW2__.Add "れた", 4270
        BW2__.Add "れて", 849
        BW2__.Add "れば", 4114
        BW2__.Add "ろう", 6067
        BW2__.Add "われ", 7901
        BW2__.Add "を通", -11877
        BW2__.Add "んだ", 728
        BW2__.Add "んな", -4115
        BW2__.Add "一人", 602
        BW2__.Add "一方", -1375
        BW2__.Add "一日", 970
        BW2__.Add "一部", -1051
        BW2__.Add "上が", -4479
        BW2__.Add "会社", -1116
        BW2__.Add "出て", 2163
        BW2__.Add "分の", -7758
        BW2__.Add "同党", 970
        BW2__.Add "同日", -913
        BW2__.Add "大阪", -2471
        BW2__.Add "委員", -1250
        BW2__.Add "少な", -1050
        BW2__.Add "年度", -8669
        BW2__.Add "年間", -1626
        BW2__.Add "府県", -2363
        BW2__.Add "手権", -1982
        BW2__.Add "新聞", -4066
        BW2__.Add "日新", -722
        BW2__.Add "日本", -7068
        BW2__.Add "日米", 3372
        BW2__.Add "曜日", -601
        BW2__.Add "朝鮮", -2355
        BW2__.Add "本人", -2697
        BW2__.Add "東京", -1543
        BW2__.Add "然と", -1384
        BW2__.Add "社会", -1276
        BW2__.Add "立て", -990
        BW2__.Add "第に", -1612
        BW2__.Add "米国", -4268
        BW2__.Add "１１", -669
        
        Set BW3__ = CreateObject("Scripting.Dictionary")
        BW3__.Add "あた", -2194
        BW3__.Add "あり", 719
        BW3__.Add "ある", 3846
        BW3__.Add "い.", -1185
        BW3__.Add "い。", -1185
        BW3__.Add "いい", 5308
        BW3__.Add "いえ", 2079
        BW3__.Add "いく", 3029
        BW3__.Add "いた", 2056
        BW3__.Add "いっ", 1883
        BW3__.Add "いる", 5600
        BW3__.Add "いわ", 1527
        BW3__.Add "うち", 1117
        BW3__.Add "うと", 4798
        BW3__.Add "えと", 1454
        BW3__.Add "か.", 2857
        BW3__.Add "か。", 2857
        BW3__.Add "かけ", -743
        BW3__.Add "かっ", -4098
        BW3__.Add "かに", -669
        BW3__.Add "から", 6520
        BW3__.Add "かり", -2670
        BW3__.Add "が,", 1816
        BW3__.Add "が、", 1816
        BW3__.Add "がき", -4855
        BW3__.Add "がけ", -1127
        BW3__.Add "がっ", -913
        BW3__.Add "がら", -4977
        BW3__.Add "がり", -2064
        BW3__.Add "きた", 1645
        BW3__.Add "けど", 1374
        BW3__.Add "こと", 7397
        BW3__.Add "この", 1542
        BW3__.Add "ころ", -2757
        BW3__.Add "さい", -714
        BW3__.Add "さを", 976
        BW3__.Add "し,", 1557
        BW3__.Add "し、", 1557
        BW3__.Add "しい", -3714
        BW3__.Add "した", 3562
        BW3__.Add "して", 1449
        BW3__.Add "しな", 2608
        BW3__.Add "しま", 1200
        BW3__.Add "す.", -1310
        BW3__.Add "す。", -1310
        BW3__.Add "する", 6521
        BW3__.Add "ず,", 3426
        BW3__.Add "ず、", 3426
        BW3__.Add "ずに", 841
        BW3__.Add "そう", 428
        BW3__.Add "た.", 8875
        BW3__.Add "た。", 8875
        BW3__.Add "たい", -594
        BW3__.Add "たの", 812
        BW3__.Add "たり", -1183
        BW3__.Add "たる", -853
        BW3__.Add "だ.", 4098
        BW3__.Add "だ。", 4098
        BW3__.Add "だっ", 1004
        BW3__.Add "った", -4748
        BW3__.Add "って", 300
        BW3__.Add "てい", 6240
        BW3__.Add "てお", 855
        BW3__.Add "ても", 302
        BW3__.Add "です", 1437
        BW3__.Add "でに", -1482
        BW3__.Add "では", 2295
        BW3__.Add "とう", -1387
        BW3__.Add "とし", 2266
        BW3__.Add "との", 541
        BW3__.Add "とも", -3543
        BW3__.Add "どう", 4664
        BW3__.Add "ない", 1796
        BW3__.Add "なく", -903
        BW3__.Add "など", 2135
        BW3__.Add "に,", -1021
        BW3__.Add "に、", -1021
        BW3__.Add "にし", 1771
        BW3__.Add "にな", 1906
        BW3__.Add "には", 2644
        BW3__.Add "の,", -724
        BW3__.Add "の、", -724
        BW3__.Add "の子", -1000
        BW3__.Add "は,", 1337
        BW3__.Add "は、", 1337
        BW3__.Add "べき", 2181
        BW3__.Add "まし", 1113
        BW3__.Add "ます", 6943
        BW3__.Add "まっ", -1549
        BW3__.Add "まで", 6154
        BW3__.Add "まれ", -793
        BW3__.Add "らし", 1479
        BW3__.Add "られ", 6820
        BW3__.Add "るる", 3818
        BW3__.Add "れ,", 854
        BW3__.Add "れ、", 854
        BW3__.Add "れた", 1850
        BW3__.Add "れて", 1375
        BW3__.Add "れば", -3246
        BW3__.Add "れる", 1091
        BW3__.Add "われ", -605
        BW3__.Add "んだ", 606
        BW3__.Add "んで", 798
        BW3__.Add "カ月", 990
        BW3__.Add "会議", 860
        BW3__.Add "入り", 1232
        BW3__.Add "大会", 2217
        BW3__.Add "始め", 1681
        BW3__.Add "市", 965
        BW3__.Add "新聞", -5055
        BW3__.Add "日,", 974
        BW3__.Add "日、", 974
        BW3__.Add "社会", 2024
        BW3__.Add "ｶ月", 990
        
        Set TC1__ = CreateObject("Scripting.Dictionary")
        TC1__.Add "AAA", 1093
        TC1__.Add "HHH", 1029
        TC1__.Add "HHM", 580
        TC1__.Add "HII", 998
        TC1__.Add "HOH", -390
        TC1__.Add "HOM", -331
        TC1__.Add "IHI", 1169
        TC1__.Add "IOH", -142
        TC1__.Add "IOI", -1015
        TC1__.Add "IOM", 467
        TC1__.Add "MMH", 187
        TC1__.Add "OOI", -1832
        
        Set TC2__ = CreateObject("Scripting.Dictionary")
        TC2__.Add "HHO", 2088
        TC2__.Add "HII", -1023
        TC2__.Add "HMM", -1154
        TC2__.Add "IHI", -1965
        TC2__.Add "KKH", 703
        TC2__.Add "OII", -2649
        
        Set TC3__ = CreateObject("Scripting.Dictionary")
        TC3__.Add "AAA", -294
        TC3__.Add "HHH", 346
        TC3__.Add "HHI", -341
        TC3__.Add "HII", -1088
        TC3__.Add "HIK", 731
        TC3__.Add "HOH", -1486
        TC3__.Add "IHH", 128
        TC3__.Add "IHI", -3041
        TC3__.Add "IHO", -1935
        TC3__.Add "IIH", -825
        TC3__.Add "IIM", -1035
        TC3__.Add "IOI", -542
        TC3__.Add "KHH", -1216
        TC3__.Add "KKA", 491
        TC3__.Add "KKH", -1217
        TC3__.Add "KOK", -1009
        TC3__.Add "MHH", -2694
        TC3__.Add "MHM", -457
        TC3__.Add "MHO", 123
        TC3__.Add "MMH", -471
        TC3__.Add "NNH", -1689
        TC3__.Add "NNO", 662
        TC3__.Add "OHO", -3393
        
        Set TC4__ = CreateObject("Scripting.Dictionary")
        TC4__.Add "HHH", -203
        TC4__.Add "HHI", 1344
        TC4__.Add "HHK", 365
        TC4__.Add "HHM", -122
        TC4__.Add "HHN", 182
        TC4__.Add "HHO", 669
        TC4__.Add "HIH", 804
        TC4__.Add "HII", 679
        TC4__.Add "HOH", 446
        TC4__.Add "IHH", 695
        TC4__.Add "IHO", -2324
        TC4__.Add "IIH", 321
        TC4__.Add "III", 1497
        TC4__.Add "IIO", 656
        TC4__.Add "IOO", 54
        TC4__.Add "KAK", 4845
        TC4__.Add "KKA", 3386
        TC4__.Add "KKK", 3065
        TC4__.Add "MHH", -405
        TC4__.Add "MHI", 201
        TC4__.Add "MMH", -241
        TC4__.Add "MMM", 661
        TC4__.Add "MOM", 841
        
        Set TQ1__ = CreateObject("Scripting.Dictionary")
        TQ1__.Add "BHHH", -227
        TQ1__.Add "BHHI", 316
        TQ1__.Add "BHIH", -132
        TQ1__.Add "BIHH", 60
        TQ1__.Add "BIII", 1595
        TQ1__.Add "BNHH", -744
        TQ1__.Add "BOHH", 225
        TQ1__.Add "BOOO", -908
        TQ1__.Add "OAKK", 482
        TQ1__.Add "OHHH", 281
        TQ1__.Add "OHIH", 249
        TQ1__.Add "OIHI", 200
        TQ1__.Add "OIIH", -68
        
        Set TQ2__ = CreateObject("Scripting.Dictionary")
        TQ2__.Add "BIHH", -1401
        TQ2__.Add "BIII", -1033
        TQ2__.Add "BKAK", -543
        TQ2__.Add "BOOO", -5591
        
        Set TQ3__ = CreateObject("Scripting.Dictionary")
        TQ3__.Add "BHHH", 478
        TQ3__.Add "BHHM", -1073
        TQ3__.Add "BHIH", 222
        TQ3__.Add "BHII", -504
        TQ3__.Add "BIIH", -116
        TQ3__.Add "BIII", -105
        TQ3__.Add "BMHI", -863
        TQ3__.Add "BMHM", -464
        TQ3__.Add "BOMH", 620
        TQ3__.Add "OHHH", 346
        TQ3__.Add "OHHI", 1729
        TQ3__.Add "OHII", 997
        TQ3__.Add "OHMH", 481
        TQ3__.Add "OIHH", 623
        TQ3__.Add "OIIH", 1344
        TQ3__.Add "OKAK", 2792
        TQ3__.Add "OKHH", 587
        TQ3__.Add "OKKA", 679
        TQ3__.Add "OOHH", 110
        TQ3__.Add "OOII", -685
        
        Set TQ4__ = CreateObject("Scripting.Dictionary")
        TQ4__.Add "BHHH", -721
        TQ4__.Add "BHHM", -3604
        TQ4__.Add "BHII", -966
        TQ4__.Add "BIIH", -607
        TQ4__.Add "BIII", -2181
        TQ4__.Add "OAAA", -2763
        TQ4__.Add "OAKK", 180
        TQ4__.Add "OHHH", -294
        TQ4__.Add "OHHI", 2446
        TQ4__.Add "OHHO", 480
        TQ4__.Add "OHIH", -1573
        TQ4__.Add "OIHH", 1935
        TQ4__.Add "OIHI", -493
        TQ4__.Add "OIIH", 626
        TQ4__.Add "OIII", -4007
        TQ4__.Add "OKAK", -8156
        
        Set TW1__ = CreateObject("Scripting.Dictionary")
        TW1__.Add "につい", -4681
        TW1__.Add "東京都", 2026
        
        Set TW2__ = CreateObject("Scripting.Dictionary")
        TW2__.Add "ある程", -2049
        TW2__.Add "いった", -1256
        TW2__.Add "ころが", -2434
        TW2__.Add "しょう", 3873
        TW2__.Add "その後", -4430
        TW2__.Add "だって", -1049
        TW2__.Add "ていた", 1833
        TW2__.Add "として", -4657
        TW2__.Add "ともに", -4517
        TW2__.Add "もので", 1882
        TW2__.Add "一気に", -792
        TW2__.Add "初めて", -1512
        TW2__.Add "同時に", -8097
        TW2__.Add "大きな", -1255
        TW2__.Add "対して", -2721
        TW2__.Add "社会党", -3216
        
        Set TW3__ = CreateObject("Scripting.Dictionary")
        TW3__.Add "いただ", -1734
        TW3__.Add "してい", 1314
        TW3__.Add "として", -4314
        TW3__.Add "につい", -5483
        TW3__.Add "にとっ", -5989
        TW3__.Add "に当た", -6247
        TW3__.Add "ので,", -727
        TW3__.Add "ので、", -727
        TW3__.Add "のもの", -600
        TW3__.Add "れから", -3752
        TW3__.Add "十二月", -2287
        
        Set TW4__ = CreateObject("Scripting.Dictionary")
        TW4__.Add "いう.", 8576
        TW4__.Add "いう。", 8576
        TW4__.Add "からな", -2348
        TW4__.Add "してい", 2958
        TW4__.Add "たが,", 1516
        TW4__.Add "たが、", 1516
        TW4__.Add "ている", 1538
        TW4__.Add "という", 1349
        TW4__.Add "ました", 5543
        TW4__.Add "ません", 1097
        TW4__.Add "ようと", -4258
        TW4__.Add "よると", 5865
        
        Set UC1__ = CreateObject("Scripting.Dictionary")
        UC1__.Add "A", 484
        UC1__.Add "K", 93
        UC1__.Add "M", 645
        UC1__.Add "O", -505
        
        Set UC2__ = CreateObject("Scripting.Dictionary")
        UC2__.Add "A", 819
        UC2__.Add "H", 1059
        UC2__.Add "I", 409
        UC2__.Add "M", 3987
        UC2__.Add "N", 5775
        UC2__.Add "O", 646
        
        Set UC3__ = CreateObject("Scripting.Dictionary")
        UC3__.Add "A", -1370
        UC3__.Add "I", 2311
        
        Set UC4__ = CreateObject("Scripting.Dictionary")
        UC4__.Add "A", -2643
        UC4__.Add "H", 1809
        UC4__.Add "I", -1032
        UC4__.Add "K", -3450
        UC4__.Add "M", 3565
        UC4__.Add "N", 3876
        UC4__.Add "O", 6646
        
        Set UC5__ = CreateObject("Scripting.Dictionary")
        UC5__.Add "H", 313
        UC5__.Add "I", -1238
        UC5__.Add "K", -799
        UC5__.Add "M", 539
        UC5__.Add "O", -831
        
        Set UC6__ = CreateObject("Scripting.Dictionary")
        UC6__.Add "H", -506
        UC6__.Add "I", -253
        UC6__.Add "K", 87
        UC6__.Add "M", 247
        UC6__.Add "O", -387
        
        Set UP1__ = CreateObject("Scripting.Dictionary")
        UP1__.Add "O", -214
        
        Set UP2__ = CreateObject("Scripting.Dictionary")
        UP2__.Add "B", 69
        UP2__.Add "O", 935
        
        Set UP3__ = CreateObject("Scripting.Dictionary")
        UP3__.Add "B", 189
        
        Set UQ1__ = CreateObject("Scripting.Dictionary")
        UQ1__.Add "BH", 21
        UQ1__.Add "BI", -12
        UQ1__.Add "BK", -99
        UQ1__.Add "BN", 142
        UQ1__.Add "BO", -56
        UQ1__.Add "OH", -95
        UQ1__.Add "OI", 477
        UQ1__.Add "OK", 410
        UQ1__.Add "OO", -2422
        
        Set UQ2__ = CreateObject("Scripting.Dictionary")
        UQ2__.Add "BH", 216
        UQ2__.Add "BI", 113
        UQ2__.Add "OK", 1759
        
        Set UQ3__ = CreateObject("Scripting.Dictionary")
        UQ3__.Add "BA", -479
        UQ3__.Add "BH", 42
        UQ3__.Add "BI", 1913
        UQ3__.Add "BK", -7198
        UQ3__.Add "BM", 3160
        UQ3__.Add "BN", 6427
        UQ3__.Add "BO", 14761
        UQ3__.Add "OI", -827
        UQ3__.Add "ON", -3212
        
        Set UW1__ = CreateObject("Scripting.Dictionary")
        UW1__.Add ",", 156
        UW1__.Add "、", 156
        UW1__.Add "「", -463
        UW1__.Add "あ", -941
        UW1__.Add "う", -127
        UW1__.Add "が", -553
        UW1__.Add "き", 121
        UW1__.Add "こ", 505
        UW1__.Add "で", -201
        UW1__.Add "と", -547
        UW1__.Add "ど", -123
        UW1__.Add "に", -789
        UW1__.Add "の", -185
        UW1__.Add "は", -847
        UW1__.Add "も", -466
        UW1__.Add "や", -470
        UW1__.Add "よ", 182
        UW1__.Add "ら", -292
        UW1__.Add "り", 208
        UW1__.Add "れ", 169
        UW1__.Add "を", -446
        UW1__.Add "ん", -137
        UW1__.Add "・", -135
        UW1__.Add "主", -402
        UW1__.Add "京", -268
        UW1__.Add "区", -912
        UW1__.Add "午", 871
        UW1__.Add "国", -460
        UW1__.Add "大", 561
        UW1__.Add "委", 729
        UW1__.Add "市", -411
        UW1__.Add "日", -141
        UW1__.Add "理", 361
        UW1__.Add "生", -408
        UW1__.Add "県", -386
        UW1__.Add "都", -718
        UW1__.Add "｢", -463
        UW1__.Add "･", -135
        
        Set UW2__ = CreateObject("Scripting.Dictionary")
        UW2__.Add ",", -829
        UW2__.Add "、", -829
        UW2__.Add "〇", 892
        UW2__.Add "「", -645
        UW2__.Add "」", 3145
        UW2__.Add "あ", -538
        UW2__.Add "い", 505
        UW2__.Add "う", 134
        UW2__.Add "お", -502
        UW2__.Add "か", 1454
        UW2__.Add "が", -856
        UW2__.Add "く", -412
        UW2__.Add "こ", 1141
        UW2__.Add "さ", 878
        UW2__.Add "ざ", 540
        UW2__.Add "し", 1529
        UW2__.Add "す", -675
        UW2__.Add "せ", 300
        UW2__.Add "そ", -1011
        UW2__.Add "た", 188
        UW2__.Add "だ", 1837
        UW2__.Add "つ", -949
        UW2__.Add "て", -291
        UW2__.Add "で", -268
        UW2__.Add "と", -981
        UW2__.Add "ど", 1273
        UW2__.Add "な", 1063
        UW2__.Add "に", -1764
        UW2__.Add "の", 130
        UW2__.Add "は", -409
        UW2__.Add "ひ", -1273
        UW2__.Add "べ", 1261
        UW2__.Add "ま", 600
        UW2__.Add "も", -1263
        UW2__.Add "や", -402
        UW2__.Add "よ", 1639
        UW2__.Add "り", -579
        UW2__.Add "る", -694
        UW2__.Add "れ", 571
        UW2__.Add "を", -2516
        UW2__.Add "ん", 2095
        UW2__.Add "ア", -587
        UW2__.Add "カ", 306
        UW2__.Add "キ", 568
        UW2__.Add "ッ", 831
        UW2__.Add "三", -758
        UW2__.Add "不", -2150
        UW2__.Add "世", -302
        UW2__.Add "中", -968
        UW2__.Add "主", -861
        UW2__.Add "事", 492
        UW2__.Add "人", -123
        UW2__.Add "会", 978
        UW2__.Add "保", 362
        UW2__.Add "入", 548
        UW2__.Add "初", -3025
        UW2__.Add "副", -1566
        UW2__.Add "北", -3414
        UW2__.Add "区", -422
        UW2__.Add "大", -1769
        UW2__.Add "天", -865
        UW2__.Add "太", -483
        UW2__.Add "子", -1519
        UW2__.Add "学", 760
        UW2__.Add "実", 1023
        UW2__.Add "小", -2009
        UW2__.Add "市", -813
        UW2__.Add "年", -1060
        UW2__.Add "強", 1067
        UW2__.Add "手", -1519
        UW2__.Add "揺", -1033
        UW2__.Add "政", 1522
        UW2__.Add "文", -1355
        UW2__.Add "新", -1682
        UW2__.Add "日", -1815
        UW2__.Add "明", -1462
        UW2__.Add "最", -630
        UW2__.Add "朝", -1843
        UW2__.Add "本", -1650
        UW2__.Add "東", -931
        UW2__.Add "果", -665
        UW2__.Add "次", -2378
        UW2__.Add "民", -180
        UW2__.Add "気", -1740
        UW2__.Add "理", 752
        UW2__.Add "発", 529
        UW2__.Add "目", -1584
        UW2__.Add "相", -242
        UW2__.Add "県", -1165
        UW2__.Add "立", -763
        UW2__.Add "第", 810
        UW2__.Add "米", 509
        UW2__.Add "自", -1353
        UW2__.Add "行", 838
        UW2__.Add "西", -744
        UW2__.Add "見", -3874
        UW2__.Add "調", 1010
        UW2__.Add "議", 1198
        UW2__.Add "込", 3041
        UW2__.Add "開", 1758
        UW2__.Add "間", -1257
        UW2__.Add "｢", -645
        UW2__.Add "｣", 3145
        UW2__.Add "ｯ", 831
        UW2__.Add "ｱ", -587
        UW2__.Add "ｶ", 306
        UW2__.Add "ｷ", 568
        
        Set UW3__ = CreateObject("Scripting.Dictionary")
        UW3__.Add ",", 4889
        UW3__.Add "1", -800
        UW3__.Add "?", -1723
        UW3__.Add "、", 4889
        UW3__.Add "々", -2311
        UW3__.Add "〇", 5827
        UW3__.Add "」", 2670
        UW3__.Add "〓", -3573
        UW3__.Add "あ", -2696
        UW3__.Add "い", 1006
        UW3__.Add "う", 2342
        UW3__.Add "え", 1983
        UW3__.Add "お", -4864
        UW3__.Add "か", -1163
        UW3__.Add "が", 3271
        UW3__.Add "く", 1004
        UW3__.Add "け", 388
        UW3__.Add "げ", 401
        UW3__.Add "こ", -3552
        UW3__.Add "ご", -3116
        UW3__.Add "さ", -1058
        UW3__.Add "し", -395
        UW3__.Add "す", 584
        UW3__.Add "せ", 3685
        UW3__.Add "そ", -5228
        UW3__.Add "た", 842
        UW3__.Add "ち", -521
        UW3__.Add "っ", -1444
        UW3__.Add "つ", -1081
        UW3__.Add "て", 6167
        UW3__.Add "で", 2318
        UW3__.Add "と", 1691
        UW3__.Add "ど", -899
        UW3__.Add "な", -2788
        UW3__.Add "に", 2745
        UW3__.Add "の", 4056
        UW3__.Add "は", 4555
        UW3__.Add "ひ", -2171
        UW3__.Add "ふ", -1798
        UW3__.Add "へ", 1199
        UW3__.Add "ほ", -5516
        UW3__.Add "ま", -4384
        UW3__.Add "み", -120
        UW3__.Add "め", 1205
        UW3__.Add "も", 2323
        UW3__.Add "や", -788
        UW3__.Add "よ", -202
        UW3__.Add "ら", 727
        UW3__.Add "り", 649
        UW3__.Add "る", 5905
        UW3__.Add "れ", 2773
        UW3__.Add "わ", -1207
        UW3__.Add "を", 6620
        UW3__.Add "ん", -518
        UW3__.Add "ア", 551
        UW3__.Add "グ", 1319
        UW3__.Add "ス", 874
        UW3__.Add "ッ", -1350
        UW3__.Add "ト", 521
        UW3__.Add "ム", 1109
        UW3__.Add "ル", 1591
        UW3__.Add "ロ", 2201
        UW3__.Add "ン", 278
        UW3__.Add "・", -3794
        UW3__.Add "一", -1619
        UW3__.Add "下", -1759
        UW3__.Add "世", -2087
        UW3__.Add "両", 3815
        UW3__.Add "中", 653
        UW3__.Add "主", -758
        UW3__.Add "予", -1193
        UW3__.Add "二", 974
        UW3__.Add "人", 2742
        UW3__.Add "今", 792
        UW3__.Add "他", 1889
        UW3__.Add "以", -1368
        UW3__.Add "低", 811
        UW3__.Add "何", 4265
        UW3__.Add "作", -361
        UW3__.Add "保", -2439
        UW3__.Add "元", 4858
        UW3__.Add "党", 3593
        UW3__.Add "全", 1574
        UW3__.Add "公", -3030
        UW3__.Add "六", 755
        UW3__.Add "共", -1880
        UW3__.Add "円", 5807
        UW3__.Add "再", 3095
        UW3__.Add "分", 457
        UW3__.Add "初", 2475
        UW3__.Add "別", 1129
        UW3__.Add "前", 2286
        UW3__.Add "副", 4437
        UW3__.Add "力", 365
        UW3__.Add "動", -949
        UW3__.Add "務", -1872
        UW3__.Add "化", 1327
        UW3__.Add "北", -1038
        UW3__.Add "区", 4646
        UW3__.Add "千", -2309
        UW3__.Add "午", -783
        UW3__.Add "協", -1006
        UW3__.Add "口", 483
        UW3__.Add "右", 1233
        UW3__.Add "各", 3588
        UW3__.Add "合", -241
        UW3__.Add "同", 3906
        UW3__.Add "和", -837
        UW3__.Add "員", 4513
        UW3__.Add "国", 642
        UW3__.Add "型", 1389
        UW3__.Add "場", 1219
        UW3__.Add "外", -241
        UW3__.Add "妻", 2016
        UW3__.Add "学", -1356
        UW3__.Add "安", -423
        UW3__.Add "実", -1008
        UW3__.Add "家", 1078
        UW3__.Add "小", -513
        UW3__.Add "少", -3102
        UW3__.Add "州", 1155
        UW3__.Add "市", 3197
        UW3__.Add "平", -1804
        UW3__.Add "年", 2416
        UW3__.Add "広", -1030
        UW3__.Add "府", 1605
        UW3__.Add "度", 1452
        UW3__.Add "建", -2352
        UW3__.Add "当", -3885
        UW3__.Add "得", 1905
        UW3__.Add "思", -1291
        UW3__.Add "性", 1822
        UW3__.Add "戸", -488
        UW3__.Add "指", -3973
        UW3__.Add "政", -2013
        UW3__.Add "教", -1479
        UW3__.Add "数", 3222
        UW3__.Add "文", -1489
        UW3__.Add "新", 1764
        UW3__.Add "日", 2099
        UW3__.Add "旧", 5792
        UW3__.Add "昨", -661
        UW3__.Add "時", -1248
        UW3__.Add "曜", -951
        UW3__.Add "最", -937
        UW3__.Add "月", 4125
        UW3__.Add "期", 360
        UW3__.Add "李", 3094
        UW3__.Add "村", 364
        UW3__.Add "東", -805
        UW3__.Add "核", 5156
        UW3__.Add "森", 2438
        UW3__.Add "業", 484
        UW3__.Add "氏", 2613
        UW3__.Add "民", -1694
        UW3__.Add "決", -1073
        UW3__.Add "法", 1868
        UW3__.Add "海", -495
        UW3__.Add "無", 979
        UW3__.Add "物", 461
        UW3__.Add "特", -3850
        UW3__.Add "生", -273
        UW3__.Add "用", 914
        UW3__.Add "町", 1215
        UW3__.Add "的", 7313
        UW3__.Add "直", -1835
        UW3__.Add "省", 792
        UW3__.Add "県", 6293
        UW3__.Add "知", -1528
        UW3__.Add "私", 4231
        UW3__.Add "税", 401
        UW3__.Add "立", -960
        UW3__.Add "第", 1201
        UW3__.Add "米", 7767
        UW3__.Add "系", 3066
        UW3__.Add "約", 3663
        UW3__.Add "級", 1384
        UW3__.Add "統", -4229
        UW3__.Add "総", 1163
        UW3__.Add "線", 1255
        UW3__.Add "者", 6457
        UW3__.Add "能", 725
        UW3__.Add "自", -2869
        UW3__.Add "英", 785
        UW3__.Add "見", 1044
        UW3__.Add "調", -562
        UW3__.Add "財", -733
        UW3__.Add "費", 1777
        UW3__.Add "車", 1835
        UW3__.Add "軍", 1375
        UW3__.Add "込", -1504
        UW3__.Add "通", -1136
        UW3__.Add "選", -681
        UW3__.Add "郎", 1026
        UW3__.Add "郡", 4404
        UW3__.Add "部", 1200
        UW3__.Add "金", 2163
        UW3__.Add "長", 421
        UW3__.Add "開", -1432
        UW3__.Add "間", 1302
        UW3__.Add "関", -1282
        UW3__.Add "雨", 2009
        UW3__.Add "電", -1045
        UW3__.Add "非", 2066
        UW3__.Add "駅", 1620
        UW3__.Add "１", -800
        UW3__.Add "｣", 2670
        UW3__.Add "･", -3794
        UW3__.Add "ｯ", -1350
        UW3__.Add "ｱ", 551
        UW3__.Add "ｸﾞ", 1319
        UW3__.Add "ｽ", 874
        UW3__.Add "ﾄ", 521
        UW3__.Add "ﾑ", 1109
        UW3__.Add "ﾙ", 1591
        UW3__.Add "ﾛ", 2201
        UW3__.Add "ﾝ", 278
        
        Set UW4__ = CreateObject("Scripting.Dictionary")
        UW4__.Add ",", 3930
        UW4__.Add ".", 3508
        UW4__.Add "―", -4841
        UW4__.Add "、", 3930
        UW4__.Add "。", 3508
        UW4__.Add "〇", 4999
        UW4__.Add "「", 1895
        UW4__.Add "」", 3798
        UW4__.Add "〓", -5156
        UW4__.Add "あ", 4752
        UW4__.Add "い", -3435
        UW4__.Add "う", -640
        UW4__.Add "え", -2514
        UW4__.Add "お", 2405
        UW4__.Add "か", 530
        UW4__.Add "が", 6006
        UW4__.Add "き", -4482
        UW4__.Add "ぎ", -3821
        UW4__.Add "く", -3788
        UW4__.Add "け", -4376
        UW4__.Add "げ", -4734
        UW4__.Add "こ", 2255
        UW4__.Add "ご", 1979
        UW4__.Add "さ", 2864
        UW4__.Add "し", -843
        UW4__.Add "じ", -2506
        UW4__.Add "す", -731
        UW4__.Add "ず", 1251
        UW4__.Add "せ", 181
        UW4__.Add "そ", 4091
        UW4__.Add "た", 5034
        UW4__.Add "だ", 5408
        UW4__.Add "ち", -3654
        UW4__.Add "っ", -5882
        UW4__.Add "つ", -1659
        UW4__.Add "て", 3994
        UW4__.Add "で", 7410
        UW4__.Add "と", 4547
        UW4__.Add "な", 5433
        UW4__.Add "に", 6499
        UW4__.Add "ぬ", 1853
        UW4__.Add "ね", 1413
        UW4__.Add "の", 7396
        UW4__.Add "は", 8578
        UW4__.Add "ば", 1940
        UW4__.Add "ひ", 4249
        UW4__.Add "び", -4134
        UW4__.Add "ふ", 1345
        UW4__.Add "へ", 6665
        UW4__.Add "べ", -744
        UW4__.Add "ほ", 1464
        UW4__.Add "ま", 1051
        UW4__.Add "み", -2082
        UW4__.Add "む", -882
        UW4__.Add "め", -5046
        UW4__.Add "も", 4169
        UW4__.Add "ゃ", -2666
        UW4__.Add "や", 2795
        UW4__.Add "ょ", -1544
        UW4__.Add "よ", 3351
        UW4__.Add "ら", -2922
        UW4__.Add "り", -9726
        UW4__.Add "る", -14896
        UW4__.Add "れ", -2613
        UW4__.Add "ろ", -4570
        UW4__.Add "わ", -1783
        UW4__.Add "を", 13150
        UW4__.Add "ん", -2352
        UW4__.Add "カ", 2145
        UW4__.Add "コ", 1789
        UW4__.Add "セ", 1287
        UW4__.Add "ッ", -724
        UW4__.Add "ト", -403
        UW4__.Add "メ", -1635
        UW4__.Add "ラ", -881
        UW4__.Add "リ", -541
        UW4__.Add "ル", -856
        UW4__.Add "ン", -3637
        UW4__.Add "・", -4371
        UW4__.Add "ー", -11870
        UW4__.Add "一", -2069
        UW4__.Add "中", 2210
        UW4__.Add "予", 782
        UW4__.Add "事", -190
        UW4__.Add "井", -1768
        UW4__.Add "人", 1036
        UW4__.Add "以", 544
        UW4__.Add "会", 950
        UW4__.Add "体", -1286
        UW4__.Add "作", 530
        UW4__.Add "側", 4292
        UW4__.Add "先", 601
        UW4__.Add "党", -2006
        UW4__.Add "共", -1212
        UW4__.Add "内", 584
        UW4__.Add "円", 788
        UW4__.Add "初", 1347
        UW4__.Add "前", 1623
        UW4__.Add "副", 3879
        UW4__.Add "力", -302
        UW4__.Add "動", -740
        UW4__.Add "務", -2715
        UW4__.Add "化", 776
        UW4__.Add "区", 4517
        UW4__.Add "協", 1013
        UW4__.Add "参", 1555
        UW4__.Add "合", -1834
        UW4__.Add "和", -681
        UW4__.Add "員", -910
        UW4__.Add "器", -851
        UW4__.Add "回", 1500
        UW4__.Add "国", -619
        UW4__.Add "園", -1200
        UW4__.Add "地", 866
        UW4__.Add "場", -1410
        UW4__.Add "塁", -2094
        UW4__.Add "士", -1413
        UW4__.Add "多", 1067
        UW4__.Add "大", 571
        UW4__.Add "子", -4802
        UW4__.Add "学", -1397
        UW4__.Add "定", -1057
        UW4__.Add "寺", -809
        UW4__.Add "小", 1910
        UW4__.Add "屋", -1328
        UW4__.Add "山", -1500
        UW4__.Add "島", -2056
        UW4__.Add "川", -2667
        UW4__.Add "市", 2771
        UW4__.Add "年", 374
        UW4__.Add "庁", -4556
        UW4__.Add "後", 456
        UW4__.Add "性", 553
        UW4__.Add "感", 916
        UW4__.Add "所", -1566
        UW4__.Add "支", 856
        UW4__.Add "改", 787
        UW4__.Add "政", 2182
        UW4__.Add "教", 704
        UW4__.Add "文", 522
        UW4__.Add "方", -856
        UW4__.Add "日", 1798
        UW4__.Add "時", 1829
        UW4__.Add "最", 845
        UW4__.Add "月", -9066
        UW4__.Add "木", -485
        UW4__.Add "来", -442
        UW4__.Add "校", -360
        UW4__.Add "業", -1043
        UW4__.Add "氏", 5388
        UW4__.Add "民", -2716
        UW4__.Add "気", -910
        UW4__.Add "沢", -939
        UW4__.Add "済", -543
        UW4__.Add "物", -735
        UW4__.Add "率", 672
        UW4__.Add "球", -1267
        UW4__.Add "生", -1286
        UW4__.Add "産", -1101
        UW4__.Add "田", -2900
        UW4__.Add "町", 1826
        UW4__.Add "的", 2586
        UW4__.Add "目", 922
        UW4__.Add "省", -3485
        UW4__.Add "県", 2997
        UW4__.Add "空", -867
        UW4__.Add "立", -2112
        UW4__.Add "第", 788
        UW4__.Add "米", 2937
        UW4__.Add "系", 786
        UW4__.Add "約", 2171
        UW4__.Add "経", 1146
        UW4__.Add "統", -1169
        UW4__.Add "総", 940
        UW4__.Add "線", -994
        UW4__.Add "署", 749
        UW4__.Add "者", 2145
        UW4__.Add "能", -730
        UW4__.Add "般", -852
        UW4__.Add "行", -792
        UW4__.Add "規", 792
        UW4__.Add "警", -1184
        UW4__.Add "議", -244
        UW4__.Add "谷", -1000
        UW4__.Add "賞", 730
        UW4__.Add "車", -1481
        UW4__.Add "軍", 1158
        UW4__.Add "輪", -1433
        UW4__.Add "込", -3370
        UW4__.Add "近", 929
        UW4__.Add "道", -1291
        UW4__.Add "選", 2596
        UW4__.Add "郎", -4866
        UW4__.Add "都", 1192
        UW4__.Add "野", -1100
        UW4__.Add "銀", -2213
        UW4__.Add "長", 357
        UW4__.Add "間", -2344
        UW4__.Add "院", -2297
        UW4__.Add "際", -2604
        UW4__.Add "電", -878
        UW4__.Add "領", -1659
        UW4__.Add "題", -792
        UW4__.Add "館", -1984
        UW4__.Add "首", 1749
        UW4__.Add "高", 2120
        UW4__.Add "｢", 1895
        UW4__.Add "｣", 3798
        UW4__.Add "･", -4371
        UW4__.Add "ｯ", -724
        UW4__.Add "ｰ", -11870
        UW4__.Add "ｶ", 2145
        UW4__.Add "ｺ", 1789
        UW4__.Add "ｾ", 1287
        UW4__.Add "ﾄ", -403
        UW4__.Add "ﾒ", -1635
        UW4__.Add "ﾗ", -881
        UW4__.Add "ﾘ", -541
        UW4__.Add "ﾙ", -856
        UW4__.Add "ﾝ", -3637
        
        Set UW5__ = CreateObject("Scripting.Dictionary")
        UW5__.Add ",", 465
        UW5__.Add ".", -299
        UW5__.Add "1", -514
        UW5__.Add "E2", -32768
        UW5__.Add "]", -2762
        UW5__.Add "、", 465
        UW5__.Add "。", -299
        UW5__.Add "「", 363
        UW5__.Add "あ", 1655
        UW5__.Add "い", 331
        UW5__.Add "う", -503
        UW5__.Add "え", 1199
        UW5__.Add "お", 527
        UW5__.Add "か", 647
        UW5__.Add "が", -421
        UW5__.Add "き", 1624
        UW5__.Add "ぎ", 1971
        UW5__.Add "く", 312
        UW5__.Add "げ", -983
        UW5__.Add "さ", -1537
        UW5__.Add "し", -1371
        UW5__.Add "す", -852
        UW5__.Add "だ", -1186
        UW5__.Add "ち", 1093
        UW5__.Add "っ", 52
        UW5__.Add "つ", 921
        UW5__.Add "て", -18
        UW5__.Add "で", -850
        UW5__.Add "と", -127
        UW5__.Add "ど", 1682
        UW5__.Add "な", -787
        UW5__.Add "に", -1224
        UW5__.Add "の", -635
        UW5__.Add "は", -578
        UW5__.Add "べ", 1001
        UW5__.Add "み", 502
        UW5__.Add "め", 865
        UW5__.Add "ゃ", 3350
        UW5__.Add "ょ", 854
        UW5__.Add "り", -208
        UW5__.Add "る", 429
        UW5__.Add "れ", 504
        UW5__.Add "わ", 419
        UW5__.Add "を", -1264
        UW5__.Add "ん", 327
        UW5__.Add "イ", 241
        UW5__.Add "ル", 451
        UW5__.Add "ン", -343
        UW5__.Add "中", -871
        UW5__.Add "京", 722
        UW5__.Add "会", -1153
        UW5__.Add "党", -654
        UW5__.Add "務", 3519
        UW5__.Add "区", -901
        UW5__.Add "告", 848
        UW5__.Add "員", 2104
        UW5__.Add "大", -1296
        UW5__.Add "学", -548
        UW5__.Add "定", 1785
        UW5__.Add "嵐", -1304
        UW5__.Add "市", -2991
        UW5__.Add "席", 921
        UW5__.Add "年", 1763
        UW5__.Add "思", 872
        UW5__.Add "所", -814
        UW5__.Add "挙", 1618
        UW5__.Add "新", -1682
        UW5__.Add "日", 218
        UW5__.Add "月", -4353
        UW5__.Add "査", 932
        UW5__.Add "格", 1356
        UW5__.Add "機", -1508
        UW5__.Add "氏", -1347
        UW5__.Add "田", 240
        UW5__.Add "町", -3912
        UW5__.Add "的", -3149
        UW5__.Add "相", 1319
        UW5__.Add "省", -1052
        UW5__.Add "県", -4003
        UW5__.Add "研", -997
        UW5__.Add "社", -278
        UW5__.Add "空", -813
        UW5__.Add "統", 1955
        UW5__.Add "者", -2233
        UW5__.Add "表", 663
        UW5__.Add "語", -1073
        UW5__.Add "議", 1219
        UW5__.Add "選", -1018
        UW5__.Add "郎", -368
        UW5__.Add "長", 786
        UW5__.Add "間", 1191
        UW5__.Add "題", 2368
        UW5__.Add "館", -689
        UW5__.Add "１", -514
        UW5__.Add "Ｅ２", -32768
        UW5__.Add "｢", 363
        UW5__.Add "ｲ", 241
        UW5__.Add "ﾙ", 451
        UW5__.Add "ﾝ", -343
        
        Set UW6__ = CreateObject("Scripting.Dictionary")
        UW6__.Add ",", 227
        UW6__.Add ".", 808
        UW6__.Add "1", -270
        UW6__.Add "E1", 306
        UW6__.Add "、", 227
        UW6__.Add "。", 808
        UW6__.Add "あ", -307
        UW6__.Add "う", 189
        UW6__.Add "か", 241
        UW6__.Add "が", -73
        UW6__.Add "く", -121
        UW6__.Add "こ", -200
        UW6__.Add "じ", 1782
        UW6__.Add "す", 383
        UW6__.Add "た", -428
        UW6__.Add "っ", 573
        UW6__.Add "て", -1014
        UW6__.Add "で", 101
        UW6__.Add "と", -105
        UW6__.Add "な", -253
        UW6__.Add "に", -149
        UW6__.Add "の", -417
        UW6__.Add "は", -236
        UW6__.Add "も", -206
        UW6__.Add "り", 187
        UW6__.Add "る", -135
        UW6__.Add "を", 195
        UW6__.Add "ル", -673
        UW6__.Add "ン", -496
        UW6__.Add "一", -277
        UW6__.Add "中", 201
        UW6__.Add "件", -800
        UW6__.Add "会", 624
        UW6__.Add "前", 302
        UW6__.Add "区", 1792
        UW6__.Add "員", -1212
        UW6__.Add "委", 798
        UW6__.Add "学", -960
        UW6__.Add "市", 887
        UW6__.Add "広", -695
        UW6__.Add "後", 535
        UW6__.Add "業", -697
        UW6__.Add "相", 753
        UW6__.Add "社", -507
        UW6__.Add "福", 974
        UW6__.Add "空", -822
        UW6__.Add "者", 1811
        UW6__.Add "連", 463
        UW6__.Add "郎", 1082
        UW6__.Add "１", -270
        UW6__.Add "Ｅ１", 306
        UW6__.Add "ﾙ", -673
        UW6__.Add "ﾝ", -496
    
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ★ClassModule★
' CountVectorizerクラス
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Dim dctTexts As Object
    Dim dctCharToIndex As Object
    Dim dctAnswers As Object
    
    Const intNGram As Integer = 2
    Const strTEXT_VECTOR As String = "TEXT_VECTOR"
    Const strTEXT_ANSWER As String = "TEXT_ANSWER"
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス初期化時各種変数を設定
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Private Sub Class_Initialize()
        
        Set dctTexts = CreateNewDictionary
        Set dctCharToIndex = CreateNewDictionary
        Set dctAnswers = CreateNewDictionary
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列を追記
' ※最大文字数が不明なためこの段階ではベクトル化しない！！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub AddText(ByVal strTextOrigin As String, ByVal strTextAnswer As String)
        
        Dim strText As String
        strText = FormatText(strTextOrigin)
        
        If dctTexts.Exists(strText) = False Then
            dctTexts.Add strText, CreateNewDictionary
            dctTexts(strText).Add strTEXT_ANSWER, strTextAnswer
            dctTexts(strText).Add strTEXT_VECTOR, ""
        End If
        
        If dctAnswers.Exists(strTextAnswer) = False Then
            dctAnswers.Add strTextAnswer, strTextOrigin
        End If
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 存在する文字全ての収集が完了したら
' 「文字：ID対応表生成」⇒「ベクトル化」
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Vectorize()
        
        Call MakeCharToIndex
        Call MakeVectors
        
    End Sub
    
    '******************************************
    ' 文字⇒IDの対応表を生成
    '******************************************
    Sub MakeCharToIndex()
        
        '文字が蓄積されていない状態では実行不可能
        If dctTexts.Count = 0 Then
            Exit Sub
        End If
        
        '「1文字として扱う長さ」を変化させながら対応表を生成
        '【UniGram】{ A:0, B:1 }
        '【BiGram 】{ A:0, B:1, AA:2, AB:3, BA:4, BB:5 }
        Dim intCharCount As Integer
        For intCharCount = 1 To intNGram
            
            Dim vntText As Variant
            For Each vntText In dctTexts.Keys()
                
                Dim intCharIndex As Integer
                For intCharIndex = 1 To Len(vntText) - intCharCount + 1
                    
                    '文字列中の指定文字数を抽出
                    Dim strChar As String
                    strChar = Mid(vntText, intCharIndex, intCharCount)
                    
                    '「文字:ID」の対応表を生成
                    If dctCharToIndex.Exists(strChar) = False Then
                        dctCharToIndex.Add strChar, dctCharToIndex.Count
                    End If
                    
                Next
                
            Next
            
        Next
        
    End Sub
    
    '******************************************
    ' 検索対象となる文字列をVectorize
    '******************************************
    Sub MakeVectors()
        
        Dim vntText As Variant
        For Each vntText In dctTexts.Keys()
            dctTexts(vntText)(strTEXT_VECTOR) = ConvertVector(vntText)
        Next
        
    End Sub
    
    '******************************************
    ' 文字列をVectorize
    '******************************************
    Function ConvertVector(ByVal strText As String) As Integer()
        
        '文字列のフォーマットを統一
        strText = FormatText(strText)
        
        '存在する文字数と同一のVectorを生成
        Dim intVector() As Integer
        ReDim intVector(dctCharToIndex.Count - 1)
        
        '抽出する「文字数」を変化させる
        Dim intCharCount As Integer
        For intCharCount = 1 To intNGram
            
            '文字列中の「抽出開始位置」を変化させる
            Dim intCharIndex As Integer
            For intCharIndex = 1 To Len(strText) - intCharCount + 1
                
                '文字列中の指定位置の文字を抽出
                Dim strChar As String
                strChar = Mid(strText, intCharIndex, intCharCount)
                
                'Vector内の対象文字Indexをカウントアップ
                If dctCharToIndex.Exists(strChar) = True Then
                    intVector(dctCharToIndex(strChar)) = intVector(dctCharToIndex(strChar)) + 1
                End If
                
            Next
            
        Next
        
        'Vectorを返却
        ConvertVector = intVector
        
    End Function
    
    '******************************************
    ' 文字列のフォーマットを統一
    '******************************************
    Function FormatText(ByVal strText As String)
        
        FormatText = StrConv(StrConv(strText, vbWide), vbUpperCase)
        
    End Function
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 最も似ている文字列ベスト10を返却
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetSimilarTexts(ByVal strText As String) As String()
        
        '検索対象文字列をベクトル化
        Dim intVector() As Integer
        intVector = ConvertVector(strText)
        
        '「距離配列」「回答配列」を生成
        Dim lngDistances() As Long
        Dim strAnswers() As String
        ReDim lngDistances(dctTexts.Count - 1)
        ReDim strAnswers(dctTexts.Count - 1)
        
        Dim objFunction As WorksheetFunction
        Set objFunction = Application.WorksheetFunction
        
        Dim vntText As Variant
        For Each vntText In dctTexts.Keys()
            
            '「距離」「回答」を配列上の同じ位置に格納
            Dim intIndex As Integer
            lngDistances(intIndex) = objFunction.SumXMY2(intVector, dctTexts(vntText)(strTEXT_VECTOR)) - objFunction.SumProduct(intVector, dctTexts(vntText)(strTEXT_VECTOR))
            strAnswers(intIndex) = dctTexts(vntText)(strTEXT_ANSWER)
            intIndex = intIndex + 1
            
        Next
        
        '「回答」を重複返却しないようDictionaryでユニーク管理
        Dim dctResults As Object
        Set dctResults = CreateNewDictionary
        
        '最も似ているベスト10を収集
        Dim strResults(9) As String
        
        Dim intAnswerCount As Integer
        Do While intAnswerCount < 10
            
            Dim lngMinDistance As Integer
            Dim lngMinIndex As Integer
            
            '配列内の「最短距離」の場所を特定
            lngMinDistance = objFunction.Min(lngDistances)
            lngMinIndex = objFunction.Match(lngMinDistance, lngDistances, False) - 1
            
            '「最短距離」と同じ場所にある「回答」文字列を特定
            Dim strResult As String
            strResult = strAnswers(lngMinIndex)
            
            '「回答」がユニークならベスト10に追加
            If dctResults.Exists(strResult) = False Then
                
                strResults(intAnswerCount) = strResult
                dctResults.Add strResult, ""
                intAnswerCount = intAnswerCount + 1
                
            End If
            
            '収集済みの「回答」を遠くに追いやる
            lngDistances(lngMinIndex) = 100000
            
        Loop
        
        '似ているベスト10を返却
        GetSimilarTexts = strResults
        
    End Function
        
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 「答え」から「元のテキスト」を返却
'　※「答え」は重複するためID管理できない
'　　例：ITエンジニア⇒IT関係
'　　　　プログラマー⇒IT関係　変換結果は重複する！！
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetOriginText(ByVal strAnswer As String) As String
        
        If dctAnswers.Exists(strAnswer) = True Then
            
            GetOriginText = dctAnswers(strAnswer)
            
        End If
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 文字列をベクトル化してあいまい検索（未完成）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '******************************************************
    ' あいまい検索使用方法のサンプル
    '******************************************************
    Sub FuzzySearchSample()
        
        Dim wsStaffMst As Worksheet
        Set wsStaffMst = ThisWorkbook.Worksheets("社員名簿")
        
        Dim lngLastRow As Long
        Dim vntReturn As Variant
        
        '検索対象となる表（重複の無いセル範囲）から
        '文字列をベクトル変換するためのDictionaryを生成
        With wsStaffMst
            lngLastRow = .Cells(.Rows.Count, "A").End(xlUp).Row
            vntReturn = MakeWordVecDict(.Range(.Cells(2, "B"), .Cells(lngLastRow, "B")))
        End With
        
        Dim dctStaffName As Object  '検索対象となる「文字列&ベクトル」
        Dim dctWordToVec As Object  '文字をベクトルに変換するための読替表
        Dim dctVecToWord As Object  'ベクトルを文字に変換するための読替表
        
        '配列で返却されるため用途に応じて切り分ける
        Set dctStaffName = vntReturn(0)
        Set dctWordToVec = vntReturn(1)
        Set dctVecToWord = vntReturn(2)
        
        'あいまい検索でArray("検索結果文字列", index)が返却される
        MsgBox FuzzySearch("山田 花子（旧姓：佐藤）", dctStaffName, dctWordToVec)(0)
        
    End Sub
    
    
    '******************************************************
    ' セル範囲から文字列を収集しベクトルを生成し
    ' 下記3個のDictionaryを返却
    '******************************************************
    '　■dctWords
    '　　「文字列」「ベクトル」ペアのDictionary
    '　　{"文章" : (1, 1, 0), "文学": (1, 0, 1)}
    '******************************************************
    '　■dctWordToVec
    '　　「文字」「インデックス」ペアのDictionary
    '　　{"文" : 0, "章": 1, "学" : 2}
    '******************************************************
    '　■dctVecToWord
    '　　「インデックス」「文字」ペアのDictionary
    '　　{0 : "文", 1 : "章", 2 : "学"}
    '******************************************************
    '　文章ベクトルのイメージ
    '　--------------------------
    '　　　｜あ｜い｜う｜え｜お｜
    '　--------------------------
    '　あい｜１｜１｜０｜０｜０｜
    '　あお｜１｜０｜０｜０｜１｜
    '　うい｜０｜１｜１｜０｜０｜
    '　--------------------------
    '******************************************************
    Function MakeWordVecDict(ByVal rngWords As Range) As Variant
            
        Dim rngCell As Range
        Dim dctWords As Object
        Set dctWords = CreateObject("Scripting.Dictionary")
        
        
        '*************************************
        ' セル範囲のユニークな文字列を収集
        '*************************************
        For Each rngCell In rngWords
            If dctWords.Exists(rngCell.Value) = False Then
                '「無変換」「全角変換」で格納
                dctWords.Add rngCell.Value, Replace(StrConv(rngCell.Value, vbWide), "　", "")
            End If
        Next
        
        'Dictionaryを準備
        Dim dctWordToVec As Object
        Dim dctVecToWord As Object
        Set dctWordToVec = CreateObject("Scripting.Dictionary")
        Set dctVecToWord = CreateObject("Scripting.Dictionary")
        
        Dim lngIndex As Long
        Dim lngChar As Long
        Dim strWords As String
        Dim strChar As String
        
        
        '*************************************
        ' 全ての文字にインデックス番号を付与
        '*************************************
        For lngIndex = 0 To dctWords.Count - 1
            
            '全角変換した文字列をもとにベクトル作成
            strWords = dctWords(dctWords.Keys()(lngIndex))
            
            For lngChar = 1 To Len(strWords)
                
                '一文字ずつ取り出す
                strChar = Mid(strWords, lngChar, 1)
                
                'Dictionaryに未格納の文字だったら・・・
                If dctWordToVec.Exists(strChar) = False Then
                    
                    '「文字：インデックス」
                    dctWordToVec.Add strChar, dctWordToVec.Count
                    
                    '「インデックス：文字」
                    dctVecToWord.Add dctVecToWord.Count, strChar
                    
                End If
            Next
        Next
        
        
        '*************************************
        ' 文字列をベクトル化
        '*************************************
        For lngIndex = 0 To dctWords.Count - 1
            
            '※必ず全角変換後文字列を使用する
            strWords = dctWords(dctWords.Keys()(lngIndex))
            
            '「存在する文字数の長さ」の配列になる
            ReDim aryTmp(dctWordToVec.Count - 1) As Variant
            
            '配列をいったん0で初期化
            For lngChar = 0 To UBound(aryTmp)
                aryTmp(lngChar) = 0
            Next
            
            '文字列を一文字ずつ処理
            For lngChar = 1 To Len(strWords)
                
                '対象の一文字
                strChar = Mid(strWords, lngChar, 1)
                
                '「文字；インデックス」変換
                If dctWordToVec.Exists(strChar) Then
                    
                    '配列内の「インデックス位置」に1を設定
                    '※複数同一文字があっても1
                    aryTmp(dctWordToVec(strChar)) = 1
                End If
            Next
            
            '「文字列：ベクトル」Dictionaryに格納
            dctWords(dctWords.Keys()(lngIndex)) = aryTmp
        Next
        
        '3個のDictionaryを返却
        MakeWordVecDict = Array(dctWords, dctWordToVec, dctVecToWord)
        
    End Function
    
    '******************************************************
    ' 文字の一致数・不一致数から「似ている」文字列を検索する
    ' 下記2つのDictionaryが必要
    '******************************************************
    '　■dctWords
    '　　「文字列」「ベクトル」ペアのDictionary
    '　　{"文章" : (1, 1, 0), "文学": (1, 0, 1)}
    '******************************************************
    '　■dctWordToVec
    '　　「文字」「インデックス」ペアのDictionary
    '　　{"文" : 0, "章": 1, "学" : 2}
    '******************************************************
    Function FuzzySearch(ByVal strKeyword As String, ByVal dctWords As Object, ByVal dctWordToVec As Object) As Variant
                
        '検索キーワード用ベクトル
        ReDim aryKeywordVec(dctWordToVec.Count - 1) As Variant
        
        Dim strKeywordWide As String
        Dim lngChar As Long
        Dim strChar As String
        
        '検索キーワードは必ず全角変換
        strKeywordWide = Replace(StrConv(strKeyword, vbWide), "　", "")
        
        '検索キーワード用ベクトルを0で初期化
        For lngChar = 0 To UBound(aryKeywordVec)
            aryKeywordVec(lngChar) = aryKeywordVec(lngChar) + 0
        Next
        
        '検索キーワードをベクトル変換
        '※この際作成済みDictionaryに存在しない文字は無視されます
        '　道の文字に対する対応は検討の余地あり
        For lngChar = 1 To Len(strKeywordWide)
            strChar = Mid(strKeywordWide, lngChar, 1)
            
            '検索キーワード内の文字が既知の文字だったら・・・
            If dctWordToVec.Exists(strChar) Then
                
                'ベクトルの対象インデクス位置をカウントアップ
                '複数同一文字があったらカウントアップ
                aryKeywordVec(dctWordToVec(strChar)) = aryKeywordVec(dctWordToVec(strChar)) + 1
            End If
        Next
            
        Dim lngIndex As Long
        Dim dblDistance As Double
        Dim dblDistanceTmp As Double
        Dim intDiff As Integer
        Dim intSame As Integer
        
        Dim strResultWord As String
        Dim lngResultIndex As Long
        
        '********************************
        ' 「一致」「不一致」計算の定数
        '********************************
        Const dblDiffPenalty As Double = 2  '完全不一致のペナルティ（乗数）
        Const dblSameReward As Double = 0.5 '部分完全一致の報酬（倍）
    
        
        For lngIndex = 0 To dctWords.Count - 1
            
            '偏差の2乗の総和で「不一致」を測定
            intDiff = Application.WorksheetFunction.SumXMY2(aryKeywordVec, dctWords(dctWords.Keys()(lngIndex)))
            
            '一致数をカウント
            intSame = Application.WorksheetFunction.SumProduct(aryKeywordVec, dctWords(dctWords.Keys()(lngIndex)))
            
            '一致数・不一致数から距離を計算する
            '※下記計算のパラメータは検討の余地あり
            If intSame = 0 Then
            
                '完全不一致はペナルティ2乗
                dblDistanceTmp = intDiff ^ dblDiffPenalty
                
            ElseIf InStr(StrConv(dctWords.Keys()(lngIndex), vbWide), strKeywordWide) > 0 Then
                
                '部分完全一致は不一致半分
                dblDistanceTmp = intDiff * dblSameReward / (intSame * 2) ^ 2
            
            Else
                
                '個別文字一致
                dblDistanceTmp = intDiff / (intSame * 2) ^ 2
            
            End If
            
            '最小距離の文字列とインデックスを格納
            If dblDistance = 0 Or dblDistance > dblDistanceTmp Then
                dblDistance = dblDistanceTmp
                strResultWord = dctWords.Keys()(lngIndex)
                lngResultIndex = lngIndex
            End If
        Next
        
        '最小距離の文字列とDictionary内の位置を返却
        FuzzySearch = Array(strResultWord, lngResultIndex)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 重回帰分析のWeightを計算(biasはx=1の項目を設ける事により算出）
' ※セル範囲の配列化、ワークシート関数の返り値は「1開始配列」になるので注意
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function GetLinearRegressionWeights(ByVal rngX As Range, ByVal rngY As Range) As Variant
        
        'セル範囲を配列化
        Dim aryX As Variant
        Dim aryY As Variant
        aryX = rngX.Value
        aryY = rngY.Value
        
        With Application.WorksheetFunction
            
            Dim aryTrX As Variant
            aryTrX = .Transpose(aryX)
            
            '**************************************
            ' ★ムーア-ペンローズの疑似逆行列★
            ' W = inv( tr(X) * X ) * tr(X) * Y
            '**************************************
            Dim aryW As Variant
            aryW = .MMult(.MMult(.MInverse(.MMult(aryTrX, aryX)), aryTrX), aryY)
            
        End With
        
        '配列を返却
        GetLinearRegressionWeights = aryW
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　数列を生成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Function MakePermutation(ByVal intNumberCount As Integer, ByVal intPickupCount As Integer, Optional ByVal aryReplaceNumbers As Variant) As Variant
        
        Dim lngPatternCount As Long
        Dim intCountDown As Integer
        
        lngPatternCount = 1
        For intCountDown = intNumberCount To (intNumberCount - intPickupCount + 1) Step -1
            lngPatternCount = lngPatternCount * intCountDown
        Next
        
        Dim aryNumbers() As Integer
        ReDim aryNumbers(1 To lngPatternCount, 1 To intPickupCount)
        Dim intIndex As Integer
        
        For intIndex = 1 To intPickupCount
            aryNumbers(1, intIndex) = intIndex
        Next
        
        Dim intTargetNumberLow As Integer
        Dim intTargetNumberHigh As Integer
        Dim lngCompleteRowsCount As Long
        Dim lngNowMakigRow As Long
        
        Dim lngRow As Long
        Dim lngColumn As Long
        Dim blnChanged As Boolean
        
        lngCompleteRowsCount = 1
        lngNowMakigRow = 1
        
        For intTargetNumberLow = intNumberCount - 1 To 1 Step -1
            For intTargetNumberHigh = intTargetNumberLow + 1 To intNumberCount
                For lngRow = 1 To lngCompleteRowsCount
                    lngNowMakigRow = lngNowMakigRow + 1
                    blnChanged = False
                    
                    For lngColumn = 1 To intPickupCount
                        
                        If aryNumbers(lngRow, lngColumn) = intTargetNumberLow Then
                            aryNumbers(lngNowMakigRow, lngColumn) = intTargetNumberHigh
                            blnChanged = True
                        ElseIf aryNumbers(lngRow, lngColumn) = intTargetNumberHigh Then
                            aryNumbers(lngNowMakigRow, lngColumn) = intTargetNumberLow
                            blnChanged = True
                        Else
                            aryNumbers(lngNowMakigRow, lngColumn) = aryNumbers(lngRow, lngColumn)
                        End If
                                        
                    Next
                    
                    If blnChanged = False Then
                        lngNowMakigRow = lngNowMakigRow - 1
                    End If
                Next
            Next
            lngCompleteRowsCount = lngNowMakigRow
        Next
        
        If IsMissing(aryReplaceNumbers) = False Then
            Dim dctChangeNumbers As Object
            Set dctChangeNumbers = CreateObject("Scripting.Dictionary")
            
            lngRow = 1
            For intIndex = LBound(aryReplaceNumbers) To UBound(aryReplaceNumbers)
                dctChangeNumbers.Add lngRow, aryReplaceNumbers(intIndex)
                lngRow = lngRow + 1
            Next
            
            For lngRow = LBound(aryNumbers, 1) To UBound(aryNumbers, 1)
                For lngColumn = LBound(aryNumbers, 2) To UBound(aryNumbers, 2)
                    aryNumbers(lngRow, lngColumn) = dctChangeNumbers(aryNumbers(lngRow, lngColumn))
                Next
            Next
        End If
        
        MakePermutation = aryNumbers
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 「共分散行列（セル範囲）」から主成分分析用の固有ベクトル・固有値を算出
'
' 元データから共分散行列の計算⇒固有ベクトル算出⇒主成分出力と
' 一気通貫のほうが良いかなぁ・・・
'
' ※1データでしかテストしていません
' ※固有ベクトル2つしか返却しません
' ※「EXCELマーケティングリサーチ&データ分析」を参考に作成
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'セルから受け取る配列を使用するため配列の最小インデックスは「1」
    Const intStartIndex As Integer = 1
    
    'ワークシート関数を想定して「セル範囲」を受け取る
    Function GetEigenVectors(ByVal rngVectorOrigin As Range) As Variant
        
        'セル範囲で受けとった引数を「値」にして配列に格納
        Dim aryVectorOld As Variant
        Dim aryVectorNew As Variant
        aryVectorOld = rngVectorOrigin.Value
        
        '引数から配列サイズを特定
        Dim intInputRowSize As Integer
        Dim intInputColumnSize As Integer
        intInputRowSize = UBound(aryVectorOld, 1)
        intInputColumnSize = UBound(aryVectorOld, 2)
        
        '関数の出力は+2行
        '⇒「固有ベクトル : 空欄 : 固有値」
        Dim intOutputRowSize As Integer
        Dim intOutputColumnSize As Integer
        intOutputRowSize = intInputRowSize + 2
        intOutputColumnSize = 2
        
        '2つ固有ベクトルを返却するための配列
        Dim aryResultVectors As Variant
        ReDim aryResultVectors(intStartIndex To intOutputRowSize, intStartIndex To intOutputColumnSize)
        
        '2つの固有ベクトルを返却
        Dim intLoopCount As Integer
        For intLoopCount = intStartIndex To intOutputColumnSize
            
            Dim vntResults As Variant
            Dim aryVectorPrincipal As Variant
            Dim dblEigenValue As Double
            
            '「固有ベクトル ＋ 固有値」を同時に受け取ってから分割
            vntResults = CalcEigenVectors(aryVectorOld)
            aryVectorPrincipal = vntResults(0)
            dblEigenValue = vntResults(1)
            
            '確定した「固有ベクトル ＋ 固有値」を返却用配列に格納
            Dim intRowIndex As Integer
            For intRowIndex = intStartIndex To intInputRowSize
                aryResultVectors(intRowIndex, intLoopCount) = aryVectorPrincipal(intRowIndex, 1)
            Next
            
            '返却用配列に「固有値」を追加
            '※「固有ベクトル : 空欄 : 固有値」
            aryResultVectors(intOutputRowSize, intLoopCount) = dblEigenValue
            
            '固有値・固有ベクトルが2つ求まれば終了
            If intLoopCount = intOutputColumnSize Then
                Exit For
            End If
                        
            '固有ベクトル * t固有ベクトル
            aryVectorNew = Application.WorksheetFunction.MMult(aryVectorPrincipal, Application.WorksheetFunction.Transpose(aryVectorPrincipal))
            
            '確定した固有ベクトルを使用して「元となる配列」を調整
            Dim intColumnIndex As Integer
            For intColumnIndex = LBound(aryVectorNew, 2) To UBound(aryVectorNew, 2)
                For intRowIndex = LBound(aryVectorNew, 1) To UBound(aryVectorNew, 1)
                    
                    '元の配列 - 固有ベクトル * t固有ベクトル * 固有値
                    aryVectorNew(intRowIndex, intColumnIndex) = aryVectorOld(intRowIndex, intColumnIndex) - (dblEigenValue * aryVectorNew(intRowIndex, intColumnIndex))
                Next
            Next
            
            '値を調整した配列から再度固有ベクトル・固有値を取得
            aryVectorOld = aryVectorNew
        Next
        
        GetEigenVectors = aryResultVectors
        
    End Function
    
    '*****************************************
    '固有ベクトル・固有値を求める単純機能
    '*****************************************
    
    Private Function CalcEigenVectors(ByVal aryVectorOrigin As Variant) As Variant
        
        '引数から配列サイズを特定
        Dim intInputRowSize As Integer
        Dim intInputColumnSize As Integer
        intInputRowSize = UBound(aryVectorOrigin, 1)
        intInputColumnSize = UBound(aryVectorOrigin, 2)
        
        
        '固有ベクトルを求めるための初期値
        Dim aryVectorOne() As Variant
        Dim aryLambda() As Variant
        ReDim aryVectorOne(intStartIndex To intInputRowSize, intStartIndex To intStartIndex)
        ReDim aryLambda(intStartIndex To intInputRowSize, intStartIndex To intStartIndex)
        
        Dim intRowIndex As Integer
        For intRowIndex = intStartIndex To intInputRowSize
            aryVectorOne(intRowIndex, 1) = 1
        Next
                
        Dim aryVectorNew As Variant
        Dim aryVectorOld As Variant
        aryVectorOld = aryVectorOne
        
        Do While True
            
            '固有値計算の反復回数カウント
            '※誤差が指定値以下にならなかったら「回数」管理で終了
            Dim intLoopCount As Integer
            intLoopCount = intLoopCount + 1
            
            '「元となるベクトル」「現在の固有ベクトル候補」から新たなベクトルを計算
            aryVectorNew = Application.WorksheetFunction.MMult(aryVectorOrigin, aryVectorOld)
            
            '新旧「固有ベクトル候補」から「λ」を計算
            For intRowIndex = LBound(aryVectorOrigin, 1) To UBound(aryVectorOrigin, 1)
                aryLambda(intRowIndex, 1) = aryVectorNew(intRowIndex, 1) / aryVectorOld(intRowIndex, 1)
            Next
            
            '全ての「λ」の誤差を計算
            '※極小小数の誤差を無視するためRound使用
            Dim dblDiffrence As Double
            dblDiffrence = 0
            For intRowIndex = LBound(aryVectorOrigin, 1) To UBound(aryVectorOrigin, 1) - 1
                dblDiffrence = dblDiffrence + Abs(Round(aryLambda(intRowIndex, 1), 10) - Round(aryLambda(intRowIndex + 1, 1), 10))
            Next
            
            '「λ」の誤差がない or 指定回数を超えたら 計算終了
            If dblDiffrence = 0 Then
                Exit Do
            ElseIf intLoopCount = 100 Then
                Exit Do
            End If
            
            '更新されたベクトルを「現在の固有ベクトル候補」にして再度計算
            aryVectorOld = aryVectorNew
            
        Loop
        
        '固有値
        Dim dblEigenValue As Double
        dblEigenValue = aryLambda(1, 1)
        
        '「固有ベクトル候補」の2乗和
        '※固有ベクトル調整用の数値
        Dim dblSumSquareRoot As Double
        dblSumSquareRoot = Sqr(Application.WorksheetFunction.SumSq(aryVectorNew))
        
        '固有ベクトルを調整
        For intRowIndex = LBound(aryVectorOrigin, 1) To UBound(aryVectorOrigin, 1)
            aryVectorNew(intRowIndex, 1) = aryVectorNew(intRowIndex, 1) / dblSumSquareRoot
        Next
        
        '「固有ベクトル」「固有値」を返却
        CalcEigenVectors = Array(aryVectorNew, dblEigenValue)
        
    End Function    
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　クラスタリング（K-Means）練習備忘録
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '汎用性はないので要改造！
    Sub Clustering()
        
        Dim aryVectors As Variant
        Dim aryBeforeClustering As Variant
        Dim aryNewClustering As Variant
        Dim aryDistances As Variant
        Dim aryClusterCenterPoints As Variant
        
        aryVectors = Range("B20:C119").Value
        aryBeforeClustering = Range("D20:D119").Value
        aryNewClustering = Range("D20:D119").Value
        aryDistances = Range("E20:H119").Value
        aryClusterCenterPoints = Range("D9:E12").Value
        
        Dim lngRow As Long
        Dim intClusterIndex As Integer
                
        'ラベルをランダムに振り分ける
        For lngRow = LBound(aryBeforeClustering) To UBound(aryBeforeClustering)
            Randomize
            aryBeforeClustering(lngRow, 1) = Application.WorksheetFunction.RandBetween(1, 4)
        Next
                        
        Dim dblDistanceMin As Double
        Dim intChangeCount As Integer
        Dim intMemberCount(1 To 4) As Integer
        Dim intLoopCount As Integer
                
        Do While True
            
            For lngRow = LBound(aryVectors, 1) To UBound(aryVectors, 1)
                dblDistanceMin = Abs(aryVectors(lngRow, 1)) + Abs(aryVectors(lngRow, 2))
                For intClusterIndex = 1 To 4
                    aryDistances(lngRow, intClusterIndex) = GetDistance( _
                                                        Array(aryVectors(lngRow, 1), aryVectors(lngRow, 2)), _
                                                        Array(aryClusterCenterPoints(intClusterIndex, 1), aryClusterCenterPoints(intClusterIndex, 2)))
                    
                    If dblDistanceMin > aryDistances(lngRow, intClusterIndex) Then
                        dblDistanceMin = aryDistances(lngRow, intClusterIndex)
                        aryNewClustering(lngRow, 1) = intClusterIndex
                    End If
                    
                Next
            Next
            
            For intClusterIndex = LBound(aryClusterCenterPoints, 1) To UBound(aryClusterCenterPoints, 1)
                aryClusterCenterPoints(intClusterIndex, 1) = 0
                aryClusterCenterPoints(intClusterIndex, 2) = 0
                intMemberCount(intClusterIndex) = 1
            Next
            
            For lngRow = LBound(aryVectors, 1) To UBound(aryVectors, 1)
                intClusterIndex = aryNewClustering(lngRow, 1)
                aryClusterCenterPoints(intClusterIndex, 1) = aryClusterCenterPoints(intClusterIndex, 1) + aryVectors(lngRow, 1)
                aryClusterCenterPoints(intClusterIndex, 2) = aryClusterCenterPoints(intClusterIndex, 2) + aryVectors(lngRow, 2)
                intMemberCount(intClusterIndex) = intMemberCount(intClusterIndex) + 1
            Next
            
            For intClusterIndex = LBound(aryClusterCenterPoints, 1) To UBound(aryClusterCenterPoints, 1)
                On Error Resume Next
                aryClusterCenterPoints(intClusterIndex, 1) = aryClusterCenterPoints(intClusterIndex, 1) / intMemberCount(intClusterIndex)
                aryClusterCenterPoints(intClusterIndex, 2) = aryClusterCenterPoints(intClusterIndex, 2) / intMemberCount(intClusterIndex)
                On Error GoTo 0
            Next
            
            For lngRow = LBound(aryVectors, 1) To UBound(aryVectors, 1)
                If aryBeforeClustering(lngRow, 1) <> aryNewClustering(lngRow, 1) Then
                    intChangeCount = intChangeCount + 1
                    aryBeforeClustering(lngRow, 1) = aryNewClustering(lngRow, 1)
                End If
            Next
            
            intLoopCount = intLoopCount + 1
            
            If intLoopCount = 1000 Or intChangeCount = 0 Then
                Debug.Print intLoopCount, intChangeCount
                Exit Do
            End If
            
            intChangeCount = 0
        Loop
        
        Range("D20:D119").Value = aryNewClustering
        Range("E20:H119").Value = aryDistances
        Range("D9:E12").Value = aryClusterCenterPoints
        
        MsgBox "FINISHED!"
        
    End Sub
    
    
    'ユークリッド距離
    Function GetDistance(ByVal aryData As Variant, ByVal aryCluster As Variant) As Double
        
        Dim dblAnswer As Double
        Dim intIndex As Integer
        
        dblAnswer = 0
        
        For intIndex = LBound(aryData) To UBound(aryData)
            
            dblAnswer = dblAnswer + (aryData(intIndex) - aryCluster(intIndex)) ^ 2
            
        Next
        
        GetDistance = Sqr(dblAnswer)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　マクロ高速化クラス（画面描画・再計算・警告表示停止・復旧）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '*************************************************
    ' インスタンス作成時点で画面処理等を停止する
    '*************************************************
    Private Sub Class_Initialize()
        
        With Application
            .ScreenUpdating = False
            .Calculation = xlManual
            .DisplayAlerts = False
            .EnableEvents = True
        End With
        
    End Sub
    
    '*************************************************
    ' インスタンスが破棄されたら自動でデフォルトに復旧
    '*************************************************
    Private Sub Class_Terminate()
        
        With Application
            .ScreenUpdating = True
            .Calculation = xlAutomatic
            .DisplayAlerts = True
            .EnableEvents = True
            .StatusBar = False
        End With
    
    End Sub
    
    '*************************************************
    ' 設定を個別に指定できる
    '*************************************************
    Sub Setting(Optional ByVal intUpdating As Integer = False, Optional ByVal intCalc As Integer = xlManual, _
            Optional ByVal intAlert As Integer = False, Optional ByVal intEvent As Integer = True)
        
        Application.ScreenUpdating = intUpdating
        Application.Calculation = intCalc
        Application.DisplayAlerts = intAlert
        Application.EnableEvents = intEvent
        
    End Sub
    
    '*************************************************
    ' ステータスバーへの進捗・メッセージ表示
    '*************************************************
    Sub StatusBar(Optional ByVal strStatusBar As String = "False")
        
        If strStatusBar <> "False" Then
            Application.StatusBar = strStatusBar
        Else
            Application.StatusBar = False
        End If
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' 標準Module
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
' 
' NeuralNetworkクラス使用例（多値分類未対応）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'Dataシートイメージ
    'ID |  x1  |  x2  | tflag | pred |
    ' 1 |  0.1 |  0.5 |   1   |  0.6 |
    ' 2 |  0.9 |  0.3 |   0   |  0.3 |
    
    Sub NeuralNetworkTest()
        
        '実行時間計測
        Dim dteStart As Date
        dteStart = Now
        
        'NueralNetworkクラス
        Dim clsNN As ClassNeuralNetwork
        Set clsNN = New ClassNeuralNetwork
        
        'NueralNetwork設計
        '入力   　：x1 x2（2値の縦ベクトル）
        '出力   　：1 　 （2種類分類）
        'Layer数　：4層　（出力層含む）
        'Units  　：層のユニット数（最終層は出力数に依存）
        '学習率 　：
        Call clsNN.Init(2, 1, 4, 10, 0.001)
        
        'NueralNetworkに渡すx（縦ベクトル）
        Dim x(1 To 2, 1 To 1) As Double
        
        '教師データの成否
        Dim intTeacher As Integer
        
        Dim wsData as Worksheet
        set wsData = Thisworkbook.Worksheets("data")
        Dim intLoopCount As Integer
        Dim lngRow As Long
        
        
        '********************************************
        ' 学習ループ
        '********************************************
        For intLoopCount = 1 To 10  'エポック回数
            For lngRow = 2 To 101   '教師データ数
                
                'x1, x2 を縦ベクトル格納（Transeposeでも良いかも？）
                x(1, 1) = wsData.Cells(lngRow, "B").Value
                x(2, 1) = wsData.Cells(lngRow, "C").Value
                
                '成否（教師データ）
                '※多値分類未対応
                intTeacher = wsData.Cells(lngRow, "D").Value
                
                '学習
                Call clsNN.Train(x, intTeacher)
            Next
        Next
        
        '********************************************
        ' 予測
        '********************************************
        For lngRow = 2 To 201
            
            'x1, x2 を縦ベクトル格納（Transeposeでも良いかも？）
            x(1, 1) = wsData.Cells(lngRow, "B").Value
            x(2, 1) = wsData.Cells(lngRow, "C").Value
            
            '予測
            wsData.Cells(lngRow, "E").Value = clsNN.Predict(x)
        Next
        
        MsgBox "実行時間：" & Format(Now - dteStart, "hh:mm:ss")
        
    End Sub
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassNeuralNetwork（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
    
Option Explicit
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'クラス内ので管理するLayerの設定等
    Dim intInputCount As Integer
    Dim intOutputCount As Integer
    Dim intLayerCount As Integer
    Dim intUnitCount As Integer
    Dim dblLR As Double
    
    'クラス内でLayer・学習・予測を管理する
    Dim aryNetworks() As Variant
    Dim intT As Integer
    Dim dblE As Double
    Dim dblZ() As Double
    Dim dblZ_B() As Double
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラスの初期設定・Layerの管理を代行
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Sub Init(ByVal intInput As Integer, ByVal intOutput As Integer, ByVal intLayer As Integer, ByVal intUnits As Integer, ByVal dblLearningRate As Double)
        
        
        ReDim dblZ(1 To intOutput, 1 To 1) As Double
        ReDim dblZ_B(1 To intOutput, 1 To 1) As Double
        
        intInputCount = intInput
        intOutputCount = intOutput
        intLayerCount = intLayer
        intUnitCount = intUnits
        dblLR = dblLearningRate
        
        ReDim aryNetworks(1 To intLayerCount)
        
        Dim intLayerIndex As Integer
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            
            Set aryNetworks(intLayerIndex) = New ClassLayer
            
            If intLayerIndex = LBound(aryNetworks) Then
                Call aryNetworks(intLayerIndex).Init(intInputCount, intUnitCount, "ReLU", dblLearningRate, intLayerIndex)
            ElseIf intLayerIndex <> UBound(aryNetworks) Then
                Call aryNetworks(intLayerIndex).Init(intUnitCount, intUnitCount, "ReLU", dblLearningRate, intLayerIndex)
            Else
                Call aryNetworks(intLayerIndex).Init(intUnitCount, intOutputCount, "Sigmoid", dblLearningRate, intLayerIndex)
            End If
            
        Next
        
    End Sub
    
    '********************************************
    ' 「wx+b=y」の計算を実行
    '********************************************
    
    Public Sub Train(ByVal vntX As Variant, ByVal intTeach As Integer)
        
        Dim intLayerIndex As Integer
        Dim vntZ As Variant
        
        intT = intTeach
        vntZ = vntX
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            Call aryNetworks(intLayerIndex).Foward(vntZ, vntZ)
        Next
        
        dblZ(1, 1) = vntZ(1, 1)
        
        If dblZ(1, 1) <> 0 And dblZ(1, 1) <> 1 Then
            
            Call CrossEntropyLoss
            Call CrossEntropyLossBack
            
            Dim vntZ_B As Variant
            vntZ_B = dblZ_B
            
            For intLayerIndex = UBound(aryNetworks) To LBound(aryNetworks) Step -1
                Call aryNetworks(intLayerIndex).Backward(vntZ_B, vntZ_B)
            Next
        Else
            Debug.Print "error"
        End If
        
    End Sub
    
    
    Private Sub CrossEntropyLoss()
        If intT = 1 Then
            dblE = (-intT) * Log(dblZ(1, 1))
        Else
            dblE = -(1 - intT) * Log(1 - dblZ(1, 1))
        End If
    End Sub
    
    Private Sub CrossEntropyLossBack()
        On Error Resume Next
        dblZ_B(1, 1) = (-intT / dblZ(1, 1)) + ((1 - intT) / (1 - dblZ(1, 1)))
        If Err.Number <> 0 Then
            dblZ_B(1, 1) = 0
        End If
        On Error GoTo 0
    End Sub
    
    Public Function Predict(ByVal vntX As Variant) As Double
        
        Dim intLayerIndex As Integer
        Dim vntZ As Variant
        
        vntZ = vntX
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            Call aryNetworks(intLayerIndex).Foward(vntZ, vntZ)
        Next
        
        Predict = vntZ(1, 1)
        
    End Function
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassLayer（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
    
Option Explicit
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'Layer設計のプロパティ
    '内部で保持する配列のサイズなどをダイナミックに作成
    Dim intXRowsCount As Integer
    Dim intXColumnsCount As Integer
    Dim intWRowsCount As Integer
    Dim intWColumnsCount As Integer
    
    'アクティベート関数の選択
    Dim blnReLU As Boolean
    Dim blnSigmoid As Boolean
    
    '学習・予想の計算時に使用するパラメータ
    Dim dblX() As Double
    Dim dblW() As Double
    Dim dblB() As Double
    Dim dblY() As Double
    Dim dblZ() As Double
    
    '誤差逆伝播計算に使用
    '計算完了後「_Bなし」の変数を更新する
    '※逆伝播は値の保存必要ないかも？
    Dim dblX_B() As Double
    Dim dblW_B() As Double
    Dim dblB_B() As Double
    Dim dblY_B() As Double
    Dim dblZ_B() As Double
    
    '学習率を保持
    Dim dblLR As Double
    
    'パラメータを出力できるようにするなど、
    '拡張性のためLayerに名前を保持する
    Dim strLayerName As String
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Layerの初期設定
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Sub Init(ByVal intInput As Integer, ByVal intOutput As Integer, ByVal strActivateFucntion As String, ByVal dblLearningRate As Double, ByVal intLayerNumber As Integer)
        
        '入力データの体裁
        intXRowsCount = intInput
        intXColumnsCount = 1
        
        'Wパラメータの体裁
        intWRowsCount = intOutput
        intWColumnsCount = intInput
        
        'アクティベート関数の選択
        If strActivateFucntion = "ReLU" Then
            blnReLU = True
        ElseIf strActivateFucntion = "Sigmoid" Then
            blnSigmoid = True
        End If
        
        '学習率の保持
        dblLR = dblLearningRate
        
        strLayerName = "Layer" & intLayerNumber
        
        '入出力の体裁によって、配列のサイズを決定
        ReDim dblX(1 To intXRowsCount, 1 To intXColumnsCount) As Double
        ReDim dblW(1 To intWRowsCount, 1 To intWColumnsCount) As Double
        ReDim dblB(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblY(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblZ(1 To intWRowsCount, 1 To 1) As Double
        
        '誤差逆伝播計算用配列は「_Bなし」と同じサイズ
        ReDim dblX_B(1 To intXRowsCount, 1 To intXColumnsCount) As Double
        ReDim dblW_B(1 To intWRowsCount, 1 To intWColumnsCount) As Double
        ReDim dblB_B(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblY_B(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblZ_B(1 To intWRowsCount, 1 To 1) As Double
        
        Dim lngRow As Long
        Dim lngColum As Long
        
        'Wをランダム（正規分布）な数値で埋める
        For lngRow = LBound(dblW, 1) To UBound(dblW, 1)
            For lngColum = LBound(dblW, 2) To UBound(dblW, 2)
                Randomize
                dblW(lngRow, lngColum) = Application.WorksheetFunction.Norm_Inv(Rnd(), 0, 1)
            Next
        Next
        
        'Bをランダム（正規分布）な数値で埋める
        For lngRow = LBound(dblB, 1) To UBound(dblB, 1)
            For lngColum = LBound(dblB, 2) To UBound(dblB, 2)
                Randomize
                dblB(lngRow, lngColum) = Application.WorksheetFunction.Norm_Inv(Rnd(), 0, 1)
            Next
        Next
        
    End Sub
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 学習の前進計算 ＆ 予測時に使用する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Foward(ByVal vntX As Variant, ByRef vntZ As Variant) As Double()
        Call CopyArray(vntX, dblX)
        Call CalcWXB
        Call ActivateFunction
        Call CopyArray(dblZ, vntZ)
        Foward = dblZ
    End Function
    
    '********************************************
    ' 「wx+b=y」の計算を実行
    '********************************************
    Private Sub CalcWXB()
        
        Dim vntWX As Variant
        vntWX = Application.WorksheetFunction.MMult(dblW, dblX)
        
        Dim lngRow As Long
        For lngRow = 1 To UBound(vntWX, 1)
            On Error Resume Next
            dblY(lngRow, 1) = vntWX(lngRow, 1) + dblB(lngRow, 1)
            If Err.Number <> 0 Then
                dblY(lngRow, 1) = vntWX(lngRow) + dblB(lngRow, 1)
            End If
            On Error GoTo 0
        Next
                
    End Sub
    
    '********************************************
    ' 「activate(y)=z」の計算を実行
    '********************************************
    Private Sub ActivateFunction()
        
        Dim lngRow As Long
        
        'ReLU関数によるActivate
        If blnReLU = True Then
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = Application.WorksheetFunction.Max(0, dblY(lngRow, 1))
            Next
        
        'Sigmoid関数によるActivate
        ElseIf blnSigmoid = True Then
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = 1 / (1 + Exp(-dblY(lngRow, 1)))
            Next
        End If
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 誤差逆伝播計算によるパラーメータの更新
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Backward(ByVal vntZ As Variant, ByRef vntX As Variant) As Double()
        Call CopyArray(vntZ, dblZ_B)
        Call ActivateFunctionBack
        Call CalcWXB_XBack
        Call CalcWXB_WBack
        Call CalcWXB_BBack
        Call CopyArray(dblX_B, vntX)
        Call UpdateParams
        Backward = dblX_B
    End Function
    
    '********************************************
    ' 「activate(y)」の微分計算を実行
    '********************************************
    Sub ActivateFunctionBack()
        
        Dim lngRow As Long
        
        'ReLU関数の逆伝播
        If blnReLU = True Then
            For lngRow = 1 To UBound(dblY, 1)
                If dblY(lngRow, 1) >= 0 Then
                    dblY_B(lngRow, 1) = dblZ_B(lngRow, 1)
                Else
                    dblY_B(lngRow, 1) = 0
                End If
            Next
        
        'Sigmoid関数の逆伝播
        ElseIf blnSigmoid = True Then
            For lngRow = 1 To UBound(dblY_B, 1)
                dblY_B(lngRow, 1) = dblZ_B(lngRow, 1) * (dblZ(lngRow, 1) * (1 - dblZ(lngRow, 1)))
            Next
        End If
    End Sub
    
    '********************************************
    ' 「wx+b⇒xの微分⇒w」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_XBack()
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '「w ＆ 逆伝播の積和（加算の反復）」を計算するため一度過去データを消去
        For lngRow = LBound(dblX_B, 1) To UBound(dblX_B, 1)
            dblX_B(lngRow, 1) = 0
        Next
        
        '「w ＆ 逆伝播」の積和（加算の反復）
        For lngRow = LBound(dblW, 1) To UBound(dblW, 1)
            For lngColumn = LBound(dblW, 2) To UBound(dblW, 2)
                dblX_B(lngColumn, 1) = dblX_B(lngColumn, 1) + dblW(lngRow, lngColumn) * dblY_B(lngRow, 1)
            Next
        Next
    End Sub
    
    '********************************************
    ' 「wx+b⇒wの微分⇒x」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_WBack()
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '「x ＆ 逆伝播」の積和
        For lngRow = LBound(dblW_B, 1) To UBound(dblW_B, 1)
            For lngColumn = LBound(dblW_B, 2) To UBound(dblW_B, 2)
                dblW_B(lngRow, lngColumn) = dblX(lngColumn, 1) * dblY_B(lngRow, 1)
            Next
        Next
    End Sub
    
    '********************************************
    ' 「wx+b⇒bの微分⇒1」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_BBack()
        Call CopyArray(dblY_B, dblB_B)
    End Sub
    
    '********************************************
    ' パラメータの更新
    ' 「新パラメータ = 旧パラメータ - 学習率 * 各パラメータの逆伝播値」
    '********************************************
    Private Sub UpdateParams()
        Dim lngRow As Long
        Dim lngColumn As Long
        
        'w = w - LearningRate * w_b
        For lngRow = LBound(dblW_B, 1) To UBound(dblW_B, 1)
            For lngColumn = LBound(dblW_B, 2) To UBound(dblW_B, 2)
                dblW(lngRow, lngColumn) = dblW(lngRow, lngColumn) - dblW_B(lngRow, lngColumn) * dblLR
            Next
        Next
        
        'b = b - LearningRate * b_b
        For lngRow = LBound(dblB_B, 1) To UBound(dblB_B, 1)
            For lngColumn = LBound(dblB_B, 2) To UBound(dblB_B, 2)
                dblB(lngRow, lngColumn) = dblB(lngRow, lngColumn) - dblB_B(lngRow, lngColumn) * dblLR
            Next
        Next
            
    End Sub
    
    '********************************************
    ' 配列のコピー関数※２元配列限定
    '********************************************
    Private Sub CopyArray(ByVal vntFrom As Variant, ByRef vntTo As Variant)
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '配列の形を一致させる
        ReDim vntTo(LBound(vntFrom, 1) To UBound(vntFrom, 1), LBound(vntFrom, 2) To UBound(vntFrom, 2))
        
        '値をコピー
        For lngRow = 1 To UBound(vntFrom, 1)
            For lngColumn = 1 To UBound(vntFrom, 2)
                vntTo(lngRow, lngColumn) = vntFrom(lngRow, lngColumn)
            Next
        Next
        
    End Sub
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' 標準モジュール
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' ConvolutionNeuralNetwork（予測に失敗・・・勉強中。）
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
        
    Sub CNN_TEST()
        
        Dim wsTrain As Worksheet
        Set wsTrain = ThisWorkbook.Worksheets("data_train")
        
        Dim intTeacher() As Integer
        Dim dblImage() As Double
        
        
        '********************************************
        ' CNN　学習率0.0001
        ' Convolution intpu:1 output:4
        ' Maxpooling
        ' Convolution intpu:4 output:4
        ' Maxpooling
        ' Flatten
        ' Dense（ReLU）param:100
        ' Dense（ReLU）param:100
        ' Dense（SoftMax）output:10
        '********************************************
        Dim clsCNN As ClassCNN
        Set clsCNN = New ClassCNN
        Call clsCNN.Init(1, 2, 3, 4, 100, 10, 3, 0.0001)
        
        Dim lngRow As Long
        Dim lngEpoch As Long
        
        '学習
        For lngEpoch = 1 To 2
            For lngRow = 2 To 1001
                
                'エクセルシート上の行に変換した画像データを行列化
                ReDim intTeacher(1 To 10, 1 To 1)
                intTeacher(wsTrain.Range("B" & lngRow).Value + 1, 1) = 1
                Call FlatToSquare(wsTrain.Range("C" & lngRow & ":GP" & lngRow), dblImage)
                
                '学習
                Call clsCNN.Train(dblImage, intTeacher)
            Next
        Next
        
        Dim intGood As Integer
        Dim intBad As Integer
        
        For lngRow = 1002 To 2002
                        
            '予測と正解を表示
            Call FlatToSquare(wsTrain.Range("C" & lngRow & ":GP" & lngRow), dblImage)
            Debug.Print clsCNN.Predict(dblImage), wsTrain.Range("B" & lngRow).Value
            
            '成否を数える
            If clsCNN.Predict(dblImage) = wsTrain.Range("B" & lngRow).Value Then
                intGood = intGood + 1
            Else
                intBad = intBad + 1
            End If
        Next
        
        '成否の結果（最大15％程度・・・）
        Debug.Print intGood, intBad
        
        End Sub
    
        
    '********************************************
    ' 行に変換した画像を行列に復元※正方形限定
    '********************************************
        Function FlatToSquare(ByVal rngRow As Range, ByRef dblImage() As Double) As Double()
        
        Dim lngArrayRow As Long
        Dim lngArrayColumn As Long
        
        ReDim dblImage(1 To 1, 1 To Sqr(rngRow.Columns.Count), 1 To Sqr(rngRow.Columns.Count))
        
        Dim lngIndex As Long
        
        For lngArrayRow = 1 To Sqr(rngRow.Columns.Count)
            For lngArrayColumn = 1 To Sqr(rngRow.Columns.Count)
                lngIndex = lngIndex + 1
                dblImage(1, lngArrayRow, lngArrayColumn) = rngRow.Cells(1, lngIndex) / 255
            Next
        Next
        
        End Function
    
    '********************************************
    ' 配列のコピー関数（Double限定）
    '********************************************
    Sub CopyArray(ByRef dblFrom() As Double, ByRef dblTo() As Double)
        
        Dim intDummy As Integer
        Dim intDimensionCheck As Integer
        
        On Error Resume Next
        Do While True
            intDimensionCheck = intDimensionCheck + 1
            intDummy = UBound(dblFrom(), intDimensionCheck)
            If Err.Number <> 0 Then
                Exit Do
            End If
        Loop
        On Error GoTo 0
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        Dim intLayerDimension
        Dim intRowDimension
        Dim intColumnDimension
        
        '1次元配列（行配列）
        If intDimensionCheck = 2 Then
        
            '配列の形を一致させる
            intColumnDimension = 1
            ReDim dblTo(LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension))
            
            '値をコピー
            For intColumn = LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension)
                dblTo(intColumn) = dblFrom(intColumn)
            Next
            
        '2次元配列（行列配列）
        ElseIf intDimensionCheck = 3 Then
        
            '配列の形を一致させる
            intRowDimension = 1
            intColumnDimension = 2
            ReDim dblTo(LBound(dblFrom, intRowDimension) To UBound(dblFrom, intRowDimension), _
                        LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension))
            
            '値をコピー
            For intRow = LBound(dblFrom, intRowDimension) To UBound(dblFrom, intRowDimension)
                For intColumn = LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension)
                    dblTo(intRow, intColumn) = dblFrom(intRow, intColumn)
                Next
            Next
        
        '3次元配列（層行列配列）
        ElseIf intDimensionCheck = 4 Then
                        
            '配列の形を一致させる
            intLayerDimension = 1
            intRowDimension = 2
            intColumnDimension = 3
            ReDim dblTo(LBound(dblFrom, intLayerDimension) To UBound(dblFrom, intLayerDimension), _
                        LBound(dblFrom, intRowDimension) To UBound(dblFrom, intRowDimension), _
                        LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension))
            
            '値をコピー
            For intLayer = LBound(dblFrom, intLayerDimension) To UBound(dblFrom, intLayerDimension)
                For intRow = LBound(dblFrom, intRowDimension) To UBound(dblFrom, intRowDimension)
                    For intColumn = LBound(dblFrom, intColumnDimension) To UBound(dblFrom, intColumnDimension)
                        dblTo(intLayer, intRow, intColumn) = dblFrom(intLayer, intRow, intColumn)
                    Next
                Next
            Next
        End If
        
    End Sub

    '********************************************
    ' 行列積（Double限定）
    '********************************************
    Function Dot(ByRef dblW() As Double, ByRef dblX() As Double) As Variant
        
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
        
        Dim dblWX() As Double
        ReDim dblWX(1 To UBound(dblW, 1), 1 To 1)
        
        For intArrayRow = LBound(dblW, 1) To UBound(dblW, 1)
            For intArrayColumn = LBound(dblW, 2) To UBound(dblW, 2)
                
                dblWX(intArrayRow, 1) = dblWX(intArrayRow, 1) + _
                    dblW(intArrayRow, intArrayColumn) * dblX(intArrayColumn, 1)
                
            Next
        Next
        
        Dot = dblWX
        
    End Function
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassCNN（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'クラス内ので管理するLayerの設定等
    Dim intInputCount As Integer
    Dim intOutputCount As Integer
    Dim intLayerCount As Integer
    Dim intUnitCount As Integer
    Dim dblLR As Double
    
    'クラス内でLayer・学習・予測を管理する
    Dim aryNetworks() As Variant
    Dim intT() As Integer
    Dim dblE As Double
    Dim dblZ() As Double
    Dim dblZ_B() As Double
    Dim dblP() As Double
    
    Dim clsConvolution() As ClassConvolution
    Dim clsFlatten As ClassFlatten
    Dim clsDense() As ClassLayer
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラスの初期設定・Layerの管理を代行
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Init(ByVal intInputLayerCount As Integer, ByVal intConvolutionLayerCount As Integer, ByVal intDenseLayerCount As Integer, _
                ByVal intConvolutionOutputCount As Integer, intDenseParamCount As Integer, ByVal intOutputCount As Integer, _
                ByVal intKernelSize As Integer, ByVal dblLearningRate As Double)
        
        ReDim clsConvolution(1 To intConvolutionLayerCount)
        ReDim clsDense(1 To intDenseLayerCount)
        
        Dim intIndex As Integer
        
        For intIndex = 1 To intConvolutionLayerCount
            Set clsConvolution(intIndex) = New ClassConvolution
            
            If intIndex = 1 Then
                Call clsConvolution(intIndex).Init(intInputLayerCount, intConvolutionOutputCount, intKernelSize, dblLearningRate)
            Else
                Call clsConvolution(intIndex).Init(intConvolutionOutputCount, intConvolutionOutputCount, intKernelSize, dblLearningRate)
            End If
        Next
        
        Set clsFlatten = New ClassFlatten
        
        For intIndex = 1 To intDenseLayerCount
            Set clsDense(intIndex) = New ClassLayer
            
            If intIndex = 1 Then
                Call clsDense(intIndex).Init(16, intDenseParamCount, "ReLU", dblLearningRate, intIndex)
            ElseIf intIndex = intDenseLayerCount Then
                Call clsDense(intIndex).Init(intDenseParamCount, intOutputCount, "SoftMax", dblLearningRate, intIndex)
            Else
                Call clsDense(intIndex).Init(intDenseParamCount, intDenseParamCount, "ReLU", dblLearningRate, intIndex)
            End If
        Next
        
        ReDim intT(1 To intOutputCount, 1 To 1)
        
    End Sub

'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 学習・予測に使用する陣伝播計算
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Train(ByRef dblX() As Double, ByRef intTeacher() As Integer)
        
        Call CopyArray(dblX, dblZ)
        Dim intIndex As Integer
        
        '教師データをコピー
        For intIndex = LBound(intTeacher) To UBound(intTeacher)
            intT(intIndex, 1) = intTeacher(intIndex, 1)
        Next
        
        'Convolution層の順伝播
        For intIndex = 1 To UBound(clsConvolution)
            Call clsConvolution(intIndex).Forward(dblZ, dblZ)
        Next
        
        '平面化（縦ベクトル）
        Call clsFlatten.Flatten(dblZ, dblZ)
        
        '全結合層の順伝播
        For intIndex = 1 To UBound(clsDense)
            Call clsDense(intIndex).Forward(dblZ, dblZ)
        Next
        
        '目的関数
        Call CalcError
        
        '全結合層の逆伝播
        For intIndex = UBound(clsDense) To 1 Step -1
            Call clsDense(intIndex).Backward(dblZ_B, dblZ_B)
        Next
        
        '平面の行列化（正方形）
        Call clsFlatten.FlattenBack(dblZ_B, dblZ_B)
        
        'Convolution層の逆伝播
        For intIndex = UBound(clsConvolution) To 1 Step -1
            Call clsConvolution(intIndex).Backward(dblZ_B, dblZ_B)
        Next
        
    End Sub
    
    '目的関数＆逆伝播初期数値生成
    Private Function CalcError() As Double
        
        ReDim dblZ_B(LBound(dblZ) To UBound(dblZ), 1 To 1)
        
        Dim dblError As Double
        Dim intArrayRow As Integer
        
        For intArrayRow = LBound(dblZ) To UBound(dblZ)
            
            dblError = dblError - intT(intArrayRow, 1) * Log(dblZ(intArrayRow, 1))
            dblZ_B(intArrayRow, 1) = dblZ(intArrayRow, 1) - intT(intArrayRow, 1)
            
        Next
        
        '誤差表示
        DoEvents
        Debug.Print dblError
        DoEvents
        
        CalcError = dblError
        
    End Function
    
    '予想
    Function Predict(ByRef dblX() As Double) As Integer
        
        Call CopyArray(dblX, dblP)
        
        Dim intIndex As Integer
        
        'Convolution層の順伝播
        For intIndex = 1 To UBound(clsConvolution)
            Call clsConvolution(intIndex).Forward(dblP, dblP)
        Next
        
        '平面化（縦ベクトル）
        Call clsFlatten.Flatten(dblP, dblP)
        
        '全結合層の順伝播
        For intIndex = 1 To UBound(clsDense)
            Call clsDense(intIndex).Forward(dblP, dblP)
        Next
        
        '出力された配列の最大値のインデックスが予測値
        Predict = Application.WorksheetFunction.Match(Application.WorksheetFunction.Max(dblP), dblP, False) - 1
        
    End Function
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassConvolution（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '1色画像処理のため3次元配列
    Const intLayerDimension As Integer = 1
    Const intRowDimension As Integer = 2
    Const intColumnDimension As Integer = 3
    
    'カーネルは別Layerのデータを受け取るため、4次元配列
    Const intKernelLayerDimension As Integer = 1    '自分自身の層番号
    Const intKernelGroupDimension As Integer = 2    'データを受け取る相手の層番号
    Const intKernelRowDimension As Integer = 3
    Const intKernelColumnDimension As Integer = 4
    
    '逆伝播カーネルは上下左右反転させる
    Dim dblKernel() As Double
    Dim dblkernelReverse() As Double
    
    '順伝播情報を保持する
    Dim dblInput() As Double
    Dim dblConvolution() As Double
    Dim dblActivate() As Double
    Dim dblOutput() As Double
    Dim dblW() As Double
    
    '逆伝播情報を保持する
    Dim dblInput_B() As Double
    Dim dblConvolution_B() As Double
    Dim dblConvolution_B_Margin() As Double
    Dim dblActivate_B() As Double
    Dim dblOutput_B() As Double
    Dim dblKernel_B() As Double
    Dim dblW_B() As Double
    
    'ユニットの設定
    Dim intInputSize As Integer
    Dim intOutputSize As Integer
    Dim intKernelSize As Integer
    Dim intMarginSize As Integer
    
    '学習率を保持
    Dim dblLR As Double
        
    'パラメータを出力できるようにするなど、
    '拡張性のためLayerに名前を保持する
    Dim strLayerName As String
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Layerの初期設定
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Init(ByVal intInputLayerSize As Integer, ByVal intOutputLayerSize As Integer, ByVal intMakeKernelSize As Integer, ByVal dblLearningRate As Double)
        intInputSize = intInputLayerSize
        intOutputSize = intOutputLayerSize
        intKernelSize = intMakeKernelSize
        intMarginSize = intKernelSize - 1
        dblLR = dblLearningRate
        Call MakeWeight
        Call MakeKernel
    End Sub
    
    '********************************************
    ' ウェイトの生成
    '********************************************
    Private Sub MakeWeight()
        
        ReDim dblW(1 To intOutputSize, 1 To 1)
        Dim lngArrayRow As Long
        For lngArrayRow = 1 To intOutputSize
            Randomize
            dblW(lngArrayRow, 1) = Application.WorksheetFunction.NormInv(Rnd(), 0, 1)
        Next
    End Sub
    
        
    '********************************************
    ' カーネルの生成
    '********************************************
    Private Sub MakeKernel()
        
        ReDim dblKernel(1 To intOutputSize, 1 To intInputSize, 1 To intKernelSize, 1 To intKernelSize)
        ReDim dblkernelReverse(1 To intOutputSize, 1 To intInputSize, 1 To intKernelSize, 1 To intKernelSize)
        
        Dim intKernelCount As Integer
        Dim intArrayLayer As Integer
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
        Dim dblRandom As Double
                
        '出力数と同数必要
        For intArrayLayer = 1 To intOutputSize
            
            '入力数と同数必要
            For intKernelCount = 1 To intInputSize
                
                'カーネル正方形のサイズ
                For intArrayRow = 1 To intKernelSize
                    For intArrayColumn = 1 To intKernelSize
                        
                        '上下左右反転カーネルも生成
                        Randomize
                        dblRandom = Application.WorksheetFunction.NormInv(Rnd(), 0, 1)
                        dblKernel(intArrayLayer, intKernelCount, intArrayRow, intArrayColumn) = dblRandom
                        dblkernelReverse(intArrayLayer, intKernelCount, intKernelSize - intArrayRow + 1, intKernelSize - intArrayColumn + 1) = dblRandom
                    Next
                Next
            Next
        Next
        
    End Sub
    

    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 学習の前進計算 ＆ 予測時に使用する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Forward(ByRef dblInputArray() As Double, ByRef dblOutputArray() As Double)
        
        Call CopyArray(dblInputArray, dblInput)
        Call Convolution
        Call ActivateFunction
        Call MaxPooling
        Call CopyArray(dblOutput, dblOutputArray)
        
    End Sub
    
    '********************************************
    ' コンボリューション
    '********************************************
    Private Sub Convolution()
        
        ReDim dblConvolution( _
            1 To intOutputSize, _
            LBound(dblInput, intRowDimension) To UBound(dblInput, intRowDimension) - intKernelSize + 1, _
            LBound(dblInput, intColumnDimension) To UBound(dblInput, intColumnDimension) - intKernelSize + 1)
        
        Dim intOutputLayer As Integer
        Dim intOutputRow As Integer
        Dim intOutputColumn As Integer
        
        Dim intInputLayer As Integer
        
        Dim intKernelLayer As Integer
        Dim intKernelGroup As Integer
        Dim intKernelRow As Integer
        Dim intKernelColumn As Integer
        
        Dim intAddRow As Integer
        Dim intAddColumn As Integer
        
        '計算結果を集約する配列の「層行列」
        For intOutputLayer = LBound(dblConvolution, intLayerDimension) To UBound(dblConvolution, intLayerDimension)
            For intOutputRow = LBound(dblConvolution, intRowDimension) To UBound(dblConvolution, intRowDimension)
                For intOutputColumn = LBound(dblConvolution, intColumnDimension) To UBound(dblConvolution, intColumnDimension)
                    
                    'ウェイトは単純加算
                    dblConvolution(intOutputLayer, intOutputRow, intOutputColumn) = dblW(intOutputLayer, 1)
                    
                    '別レイヤーのインプットを受け取り集計
                    For intInputLayer = LBound(dblInput, intLayerDimension) To UBound(dblInput, intLayerDimension)
                        
                        'カーネルを使用し各レイヤーデータをスキャン＋集計
                        For intKernelRow = LBound(dblKernel, intKernelRowDimension) To UBound(dblKernel, intKernelRowDimension)
                            For intKernelColumn = LBound(dblKernel, intKernelColumnDimension) To UBound(dblKernel, intKernelColumnDimension)
                                
                                intAddRow = intKernelRow - 1
                                intAddColumn = intKernelColumn - 1
                                
                                dblConvolution(intOutputLayer, intOutputRow, intOutputColumn) = dblConvolution(intOutputLayer, intOutputRow, intOutputColumn) + _
                                    dblKernel(intOutputLayer, intInputLayer, intKernelRow, intKernelColumn) * dblInput(intInputLayer, intOutputRow + intAddRow, intOutputColumn + intAddColumn)
                                
                            Next
                        Next
                    Next
                Next
            Next
        Next
                
    End Sub
    
    
    '********************************************
    ' ReLUによるアクティベート
    '********************************************
    Private Sub ActivateFunction()
        
        ReDim dblActivate( _
            LBound(dblConvolution, intLayerDimension) To UBound(dblConvolution, intLayerDimension), _
            LBound(dblConvolution, intRowDimension) To UBound(dblConvolution, intRowDimension), _
            LBound(dblConvolution, intColumnDimension) To UBound(dblConvolution, intColumnDimension))
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        For intLayer = LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension)
            For intRow = LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension)
                For intColumn = LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension)
                    dblActivate(intLayer, intRow, intColumn) = Application.WorksheetFunction.Max(0, dblConvolution(intLayer, intRow, intColumn))
                Next
            Next
        Next
                
    End Sub
    
    '********************************************
    ' 2×2のマックスプーリング
    '********************************************
    Private Sub MaxPooling()
        
        ReDim dblOutput( _
            LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension), _
            LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension) / 2, _
            LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension) / 2)
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        Dim intOutputRow As Integer
        Dim intOutputColumn As Integer
        
        For intLayer = LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension)
            For intRow = LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension)
                For intColumn = LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension)
                    
                    '出力結果は半分サイズ
                    intOutputRow = Application.WorksheetFunction.RoundUp(intRow / 2, 0)
                    intOutputColumn = Application.WorksheetFunction.RoundUp(intColumn / 2, 0)
                    
                    If dblOutput(intLayer, intOutputRow, intOutputColumn) < dblActivate(intLayer, intRow, intColumn) Then
                        dblOutput(intLayer, intOutputRow, intOutputColumn) = dblActivate(intLayer, intRow, intColumn)
                    End If
                    
                Next
            Next
        Next
        
    End Sub
    
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 誤差逆伝播計算によるパラーメータの更新
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Backward(ByRef dblInputArray_B() As Double, ByRef dblOutputArray_B() As Double) As Double()
        
        Call CopyArray(dblInputArray_B, dblOutput_B)
        Call MaxPoolingBack
        Call ActivateFunctionBack
        Call ConvolutionBack
        Call UpdateParams
        Call CopyArray(dblInput_B, dblOutputArray_B)
        
    End Function

    '********************************************
    ' MaxPoolingの逆伝播
    '********************************************
    Private Sub MaxPoolingBack()
        
        ReDim dblActivate_B( _
            LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension), _
            LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension), _
            LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension))
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        Dim intOutputRow As Integer
        Dim intOutputColumn As Integer
        
        For intLayer = LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension)
            For intRow = LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension)
                For intColumn = LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension)
                    
                    intOutputRow = Application.WorksheetFunction.RoundUp(intRow / 2, 0)
                    intOutputColumn = Application.WorksheetFunction.RoundUp(intColumn / 2, 0)
                    If dblActivate(intLayer, intRow, intColumn) = dblOutput(intLayer, intOutputRow, intOutputColumn) Then
                        dblActivate_B(intLayer, intRow, intColumn) = dblOutput_B(intLayer, intOutputRow, intOutputColumn)
                    End If
                    
                Next
            Next
        Next
        
    End Sub
    
    '********************************************
    ' ReLUによるアクティベートの逆伝播
    '********************************************
    Private Sub ActivateFunctionBack()
        
        ReDim dblConvolution_B( _
            LBound(dblConvolution, intLayerDimension) To UBound(dblConvolution, intLayerDimension), _
            LBound(dblConvolution, intRowDimension) To UBound(dblConvolution, intRowDimension), _
            LBound(dblConvolution, intColumnDimension) To UBound(dblConvolution, intColumnDimension))
        
        Dim intLayer As Integer
        Dim intRow As Integer
        Dim intColumn As Integer
        
        For intLayer = LBound(dblActivate, intLayerDimension) To UBound(dblActivate, intLayerDimension)
            For intRow = LBound(dblActivate, intRowDimension) To UBound(dblActivate, intRowDimension)
                For intColumn = LBound(dblActivate, intColumnDimension) To UBound(dblActivate, intColumnDimension)
                    
                    If dblConvolution(intLayer, intRow, intColumn) >= 0 Then
                        dblConvolution_B(intLayer, intRow, intColumn) = dblActivate_B(intLayer, intRow, intColumn)
                    End If
                Next
            Next
        Next
        
    End Sub
    
    '********************************************
    ' Convolutionの逆伝播
    '********************************************
    Private Sub ConvolutionBack()
        
        ReDim dblInput_B( _
            LBound(dblInput, intLayerDimension) To UBound(dblInput, intLayerDimension), _
            LBound(dblInput, intRowDimension) To UBound(dblInput, intRowDimension), _
            LBound(dblInput, intColumnDimension) To UBound(dblInput, intColumnDimension))
        
        '反転Kernel計算用の「余白付き」逆伝播信号
        Call MakeConvolutionBackMargin
        
        Dim intInputLayer As Integer
        Dim intInputRow As Integer
        Dim intInputColumn As Integer
        
        Dim intConvolutionLayer As Integer
        
        Dim intKernelRow As Integer
        Dim intKernelColumn As Integer
        
        Dim intAddRow As Integer
        Dim intAddColumn As Integer
        
        '********************************************
        ' Convolutionからインプットへの逆伝播
        '********************************************
        
        '計算結果を集約する配列の「層行列」
        For intInputLayer = LBound(dblInput_B, intLayerDimension) To UBound(dblInput_B, intLayerDimension)
            For intInputRow = LBound(dblInput_B, intRowDimension) To UBound(dblInput_B, intRowDimension)
                For intInputColumn = LBound(dblInput_B, intColumnDimension) To UBound(dblInput_B, intColumnDimension)
                    
                    '別レイヤーの逆伝播を受け取り集計
                    For intConvolutionLayer = LBound(dblConvolution_B_Margin, intLayerDimension) To UBound(dblConvolution_B_Margin, intLayerDimension)
                        
                        '反転カーネルを使用し各レイヤーデータをスキャン＋逆伝播集計
                        For intKernelRow = LBound(dblkernelReverse, intKernelRowDimension) To UBound(dblkernelReverse, intKernelRowDimension)
                            For intKernelColumn = LBound(dblkernelReverse, intKernelColumnDimension) To UBound(dblkernelReverse, intKernelColumnDimension)
                                
                                intAddRow = intKernelRow - 1
                                intAddColumn = intKernelColumn - 1
                                
                                dblInput_B(intInputLayer, intInputRow, intInputColumn) = dblInput_B(intInputLayer, intInputRow, intInputColumn) + _
                                    dblkernelReverse(intConvolutionLayer, intInputLayer, intKernelRow, intKernelColumn) * dblConvolution_B_Margin(intConvolutionLayer, intInputRow + intAddRow, intInputColumn + intAddColumn)
                                
                            Next
                        Next
                    Next
                Next
            Next
        Next
        
        
        Dim intKernelLayer As Integer
        Dim intKernelGroup As Integer
        Dim intConvolutionRow As Integer
        Dim intConvolutionColumn As Integer
        
        ReDim dblKernel_B( _
                LBound(dblKernel, intKernelLayerDimension) To UBound(dblKernel, intKernelLayerDimension), _
                LBound(dblKernel, intKernelGroupDimension) To UBound(dblKernel, intKernelGroupDimension), _
                LBound(dblKernel, intKernelRowDimension) To UBound(dblKernel, intKernelRowDimension), _
                LBound(dblKernel, intKernelColumnDimension) To UBound(dblKernel, intKernelColumnDimension))
        
        '********************************************
        ' カーネルの逆伝播
        '********************************************
        
        For intKernelLayer = LBound(dblKernel_B, intKernelLayerDimension) To UBound(dblKernel_B, intKernelLayerDimension)
            For intKernelGroup = LBound(dblKernel_B, intKernelGroupDimension) To UBound(dblKernel_B, intKernelGroupDimension)
                For intKernelRow = LBound(dblKernel_B, intKernelRowDimension) To UBound(dblKernel_B, intKernelRowDimension)
                    For intKernelColumn = LBound(dblKernel_B, intKernelColumnDimension) To UBound(dblKernel_B, intKernelColumnDimension)
                        
                        For intConvolutionRow = LBound(dblConvolution_B, intRowDimension) To UBound(dblConvolution_B, intRowDimension)
                            For intConvolutionColumn = LBound(dblConvolution_B, intColumnDimension) To UBound(dblConvolution_B, intColumnDimension)
                                
                                intAddRow = intKernelRow - 1
                                intAddColumn = intKernelColumn - 1
                                
                                dblKernel_B(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn) = _
                                    dblKernel_B(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn) + _
                                    dblConvolution_B(intKernelLayer, intConvolutionRow, intConvolutionColumn) * _
                                    dblInput(intKernelGroup, intConvolutionRow + intAddRow, intConvolutionColumn + intAddColumn)
                            Next
                        Next
                    Next
                Next
            Next
        Next
        
    End Sub
    
    '********************************************
    ' 余白付き逆伝播信号
    ' ※反転Kernelを使用した計算に使用
    '********************************************
    Private Sub MakeConvolutionBackMargin()
        
        ReDim dblConvolution_B_Margin( _
            LBound(dblConvolution_B, intLayerDimension) To UBound(dblConvolution_B, intLayerDimension), _
            LBound(dblConvolution_B, intRowDimension) To UBound(dblConvolution_B, intRowDimension) + (intMarginSize) * 2, _
            LBound(dblConvolution_B, intColumnDimension) To UBound(dblConvolution_B, intColumnDimension) + (intMarginSize) * 2)

        ReDim dblW_B( _
            LBound(dblW, intLayerDimension) To UBound(dblW, intLayerDimension), _
            LBound(dblW, intRowDimension) To UBound(dblW, intRowDimension))
    
        Dim intArrayLayer As Integer
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
                
        For intArrayLayer = LBound(dblConvolution_B, intLayerDimension) To UBound(dblConvolution_B, intLayerDimension)
            For intArrayRow = LBound(dblConvolution_B, intRowDimension) To UBound(dblConvolution_B, intRowDimension)
                For intArrayColumn = LBound(dblConvolution_B, intColumnDimension) To UBound(dblConvolution_B, intColumnDimension)
                    dblConvolution_B_Margin(intArrayLayer, intArrayRow + intMarginSize, intArrayColumn + intMarginSize) = _
                        dblConvolution_B(intArrayLayer, intArrayRow, intArrayColumn)
                
                    'ついでにウェイト（バイアス）の逆伝播信号集計
                    dblW_B(intArrayLayer, 1) = dblW_B(intArrayLayer, 1) + dblConvolution_B(intArrayLayer, intArrayRow, intArrayColumn)
                Next
            Next
        Next
    End Sub
    
    '********************************************
    ' パラメータの更新
    '********************************************
    Private Sub UpdateParams()
        
        Dim intKernelLayer As Integer
        Dim intKernelGroup As Integer
        Dim intKernelRow As Integer
        Dim intKernelColumn As Integer
        
        'カーネル・反転カーネルともに更新
        For intKernelLayer = LBound(dblKernel_B, intKernelLayerDimension) To UBound(dblKernel_B, intKernelLayerDimension)
            For intKernelGroup = LBound(dblKernel_B, intKernelGroupDimension) To UBound(dblKernel_B, intKernelGroupDimension)
                For intKernelRow = LBound(dblKernel_B, intKernelRowDimension) To UBound(dblKernel_B, intKernelRowDimension)
                    For intKernelColumn = LBound(dblKernel_B, intKernelColumnDimension) To UBound(dblKernel_B, intKernelColumnDimension)
                        
                        dblKernel(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn) = _
                            dblKernel(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn) - _
                            dblLR * dblKernel_B(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn)
                        
                        dblkernelReverse(intKernelLayer, intKernelGroup, intKernelSize - intKernelRow + 1, intKernelSize - intKernelColumn + 1) = _
                            dblKernel(intKernelLayer, intKernelGroup, intKernelRow, intKernelColumn)
    
                    Next
                Next
            Next
        Next
        
        'ウェイト（バイアス）の更新
        Dim intWeightRow As Integer
        For intWeightRow = LBound(dblW, intLayerDimension) To UBound(dblW, intLayerDimension)
            dblW(intWeightRow, 1) = dblW(intWeightRow, 1) - dblLR * dblW_B(intWeightRow, 1)
        Next
    
    End Sub
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassFlatten（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    '配列の1次元化・復元を行うために、元の次元を保存
    Const intLayerDimension As Integer = 1
    Const intRowDimension As Integer = 2
    Const intColumnDimension As Integer = 3
        
    Dim intLayerCount As Integer
    Dim intRowCount As Integer
    Dim intColumnCount As Integer
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 配列の1次元化
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub Flatten(ByRef dblInputArray() As Double, ByRef dblOutputArray() As Double)
        
        '元の次元を保存
        intLayerCount = UBound(dblInputArray, intLayerDimension)
        intRowCount = UBound(dblInputArray, intRowDimension)
        intColumnCount = UBound(dblInputArray, intColumnDimension)
        
        Dim intArrayLayer As Integer
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
        Dim intIndex As Integer
        
        Dim dblOutput() As Double
        ReDim dblOutput(1 To intLayerCount * intRowCount * intColumnCount, 1 To 1)
        
        For intArrayLayer = 1 To intLayerCount
            For intArrayRow = 1 To intRowCount
                For intArrayColumn = 1 To intColumnCount
                    intIndex = intIndex + 1
                    dblOutput(intIndex, 1) = dblInputArray(intArrayLayer, intArrayRow, intArrayColumn)
                Next
            Next
        Next
            
        Call CopyArray(dblOutput, dblOutputArray)
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 配列を3次元化に復元する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Sub FlattenBack(ByRef dblInputArray() As Double, ByRef dblOutputArray() As Double)
        
        Dim intArrayLayer As Integer
        Dim intArrayRow As Integer
        Dim intArrayColumn As Integer
        Dim intIndex As Integer
        
        Dim dblOutput() As Double
        ReDim dblOutput(1 To intLayerCount, 1 To intRowCount, 1 To intColumnCount)
        
        For intArrayLayer = 1 To intLayerCount
            For intArrayRow = 1 To intRowCount
                For intArrayColumn = 1 To intColumnCount
                    intIndex = intIndex + 1
                    dblOutput(intArrayLayer, intArrayRow, intArrayColumn) = dblInputArray(intIndex, 1)
                Next
            Next
        Next
            
        Call CopyArray(dblOutput, dblOutputArray)
        
    End Sub
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassLayer（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'Layer設計のプロパティ
    '内部で保持する配列のサイズなどをダイナミックに作成
    Dim intXRowsCount As Integer
    Dim intXColumnsCount As Integer
    Dim intWRowsCount As Integer
    Dim intWColumnsCount As Integer
    
    'アクティベート関数の選択
    Dim blnReLU As Boolean
    Dim blnSigmoid As Boolean
    Dim blnSoftMax As Boolean
    
    '学習・予想の計算時に使用するパラメータ
    Dim dblX() As Double
    Dim dblW() As Double
    Dim dblB() As Double
    Dim dblY() As Double
    Dim dblZ() As Double
    
    '誤差逆伝播計算に使用
    '計算完了後「_Bなし」の変数を更新する
    '※逆伝播は値の保存必要ないかも？
    Dim dblX_B() As Double
    Dim dblW_B() As Double
    Dim dblB_B() As Double
    Dim dblY_B() As Double
    Dim dblZ_B() As Double
    
    '学習率を保持
    Dim dblLR As Double
    
    'パラメータを出力できるようにするなど、
    '拡張性のためLayerに名前を保持する
    Dim strLayerName As String

'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' Layerの初期設定
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Sub Init(ByVal intInput As Integer, ByVal intOutput As Integer, ByVal strActivateFucntion As String, ByVal dblLearningRate As Double, ByVal intLayerNumber As Integer)
        
        '入力データの体裁
        intXRowsCount = intInput
        intXColumnsCount = 1
        
        'Wパラメータの体裁
        intWRowsCount = intOutput
        intWColumnsCount = intInput
        
        'アクティベート関数の選択
        If strActivateFucntion = "ReLU" Then
            blnReLU = True
        ElseIf strActivateFucntion = "Sigmoid" Then
            blnSigmoid = True
        ElseIf strActivateFucntion = "SoftMax" Then
            blnSoftMax = True
        End If
        
        '学習率の保持
        dblLR = dblLearningRate
        
        strLayerName = "Layer" & intLayerNumber
        
        '入出力の体裁によって、配列のサイズを決定
        ReDim dblX(1 To intXRowsCount, 1 To intXColumnsCount) As Double
        ReDim dblW(1 To intWRowsCount, 1 To intWColumnsCount) As Double
        ReDim dblB(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblY(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblZ(1 To intWRowsCount, 1 To 1) As Double
        
        '誤差逆伝播計算用配列は「_Bなし」と同じサイズ
        ReDim dblX_B(1 To intXRowsCount, 1 To intXColumnsCount) As Double
        ReDim dblW_B(1 To intWRowsCount, 1 To intWColumnsCount) As Double
        ReDim dblB_B(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblY_B(1 To intWRowsCount, 1 To 1) As Double
        ReDim dblZ_B(1 To intWRowsCount, 1 To 1) As Double
        
        Dim lngRow As Long
        Dim lngColum As Long
        
        'Wをランダム（正規分布）な数値で埋める
        For lngRow = LBound(dblW, 1) To UBound(dblW, 1)
            For lngColum = LBound(dblW, 2) To UBound(dblW, 2)
                Randomize
                dblW(lngRow, lngColum) = Application.WorksheetFunction.Norm_Inv(Rnd(), 0, 1)
            Next
        Next
        
        'Bをランダム（正規分布）な数値で埋める
        For lngRow = LBound(dblB, 1) To UBound(dblB, 1)
            For lngColum = LBound(dblB, 2) To UBound(dblB, 2)
                Randomize
                dblB(lngRow, lngColum) = Application.WorksheetFunction.Norm_Inv(Rnd(), 0, 1)
            Next
        Next
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 学習の前進計算 ＆ 予測時に使用する
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Forward(ByRef dblArrayX() As Double, ByRef dblArrayZ() As Double) As Double()
        Call CopyArray(dblArrayX, dblX)
        Call CalcWXB
        Call ActivateFunction
        Call CopyArray(dblZ, dblArrayZ)
        Forward = dblZ
    End Function
    
    '********************************************
    ' 「wx+b=y」の計算を実行
    '********************************************
    Private Sub CalcWXB()
        
        Dim vntWX As Variant
        vntWX = Dot(dblW, dblX)
        
        Dim lngRow As Long
        For lngRow = 1 To UBound(vntWX, 1)
            On Error Resume Next
            dblY(lngRow, 1) = vntWX(lngRow, 1) + dblB(lngRow, 1)
            If Err.Number <> 0 Then
                dblY(lngRow, 1) = vntWX(lngRow) + dblB(lngRow, 1)
            End If
            On Error GoTo 0
        Next
                
    End Sub

    '********************************************
    ' 「activate(y)=z」の計算を実行
    '********************************************
    Private Sub ActivateFunction()
        
        Dim lngRow As Long
        
        'ReLU関数によるActivate
        If blnReLU = True Then
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = Application.WorksheetFunction.Max(0, dblY(lngRow, 1))
            Next
        
        'Sigmoid関数によるActivate
        ElseIf blnSigmoid = True Then
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = 1 / (1 + Exp(-dblY(lngRow, 1)))
            Next
            
        ElseIf blnSoftMax = True Then
            
            Dim dblMax As Double
            Dim dblTotal As Double
            
            dblMax = Application.WorksheetFunction.Max(dblY)
            
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = Exp(dblY(lngRow, 1) - dblMax) + (1 / 10 ^ 6)
                dblTotal = dblTotal + dblZ(lngRow, 1)
            Next
            
            For lngRow = 1 To UBound(dblY, 1)
                dblZ(lngRow, 1) = dblZ(lngRow, 1) / dblTotal
            Next
            
        End If
        
    End Sub
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 誤差逆伝播計算によるパラーメータの更新
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Function Backward(ByRef dblZ() As Double, ByRef dblX() As Double) As Double()
        Call CopyArray(dblZ, dblZ_B)
        Call ActivateFunctionBack
        Call CalcWXB_XBack
        Call CalcWXB_WBack
        Call CalcWXB_BBack
        Call CopyArray(dblX_B, dblX)
        Call UpdateParams
        Backward = dblX_B
    End Function
    
    '********************************************
    ' 「activate(y)」の微分計算を実行
    '********************************************
    Sub ActivateFunctionBack()
        
        Dim lngRow As Long
        
        'ReLU関数の逆伝播
        If blnReLU = True Then
            For lngRow = 1 To UBound(dblY, 1)
                If dblY(lngRow, 1) >= 0 Then
                    dblY_B(lngRow, 1) = dblZ_B(lngRow, 1)
                Else
                    dblY_B(lngRow, 1) = 0
                End If
            Next
        
        'Sigmoid関数の逆伝播
        ElseIf blnSigmoid = True Then
            For lngRow = 1 To UBound(dblY_B, 1)
                dblY_B(lngRow, 1) = dblZ_B(lngRow, 1) * (dblZ(lngRow, 1) * (1 - dblZ(lngRow, 1)))
            Next
            
        'SoftMaxの逆伝播
        ElseIf blnSoftMax = True Then
            Call CopyArray(dblZ_B, dblY_B)
        End If
    End Sub
    
    '********************************************
    ' 「wx+b⇒xの微分⇒w」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_XBack()
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '「w ＆ 逆伝播の積和（加算の反復）」を計算するため一度過去データを消去
        For lngRow = LBound(dblX_B, 1) To UBound(dblX_B, 1)
            dblX_B(lngRow, 1) = 0
        Next
        
        '「w ＆ 逆伝播」の積和（加算の反復）
        For lngRow = LBound(dblW, 1) To UBound(dblW, 1)
            For lngColumn = LBound(dblW, 2) To UBound(dblW, 2)
                dblX_B(lngColumn, 1) = dblX_B(lngColumn, 1) + dblW(lngRow, lngColumn) * dblY_B(lngRow, 1)
            Next
        Next
    End Sub
    
    '********************************************
    ' 「wx+b⇒wの微分⇒x」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_WBack()
        
        Dim lngRow As Long
        Dim lngColumn As Long
        
        '「x ＆ 逆伝播」の積和
        For lngRow = LBound(dblW_B, 1) To UBound(dblW_B, 1)
            For lngColumn = LBound(dblW_B, 2) To UBound(dblW_B, 2)
                dblW_B(lngRow, lngColumn) = dblX(lngColumn, 1) * dblY_B(lngRow, 1)
            Next
        Next
    End Sub
    
    '********************************************
    ' 「wx+b⇒bの微分⇒1」の微分計算を実行
    '********************************************
    Private Sub CalcWXB_BBack()
        Call CopyArray(dblZ_B, dblB_B)
    End Sub
    
    '********************************************
    ' パラメータの更新
    ' 「新パラメータ = 旧パラメータ - 学習率 * 各パラメータの逆伝播値」
    '********************************************
    Private Sub UpdateParams()
        Dim lngRow As Long
        Dim lngColumn As Long
        
        'w = w - LearningRate * w_b
        For lngRow = LBound(dblW_B, 1) To UBound(dblW_B, 1)
            For lngColumn = LBound(dblW_B, 2) To UBound(dblW_B, 2)
                dblW(lngRow, lngColumn) = dblW(lngRow, lngColumn) - dblW_B(lngRow, lngColumn) * dblLR
            Next
        Next
        
        'b = b - LearningRate * b_b
        For lngRow = LBound(dblB_B, 1) To UBound(dblB_B, 1)
            For lngColumn = LBound(dblB_B, 2) To UBound(dblB_B, 2)
                dblB(lngRow, lngColumn) = dblB(lngRow, lngColumn) - dblB_B(lngRow, lngColumn) * dblLR
            Next
        Next
        
    End Sub
    
'★★★★★★★★★★★★★★★★★★★★★★★★
' ClassNeuralNetwork（ClassModule）
'★★★★★★★★★★★★★★★★★★★★★★★★
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラス内プロパティ
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    'クラス内ので管理するLayerの設定等
    Dim intInputCount As Integer
    Dim intOutputCount As Integer
    Dim intLayerCount As Integer
    Dim intUnitCount As Integer
    Dim dblLR As Double
    
    'クラス内でLayer・学習・予測を管理する
    Dim aryNetworks() As Variant
    Dim intT As Integer
    Dim dblE As Double
    Dim dblZ() As Double
    Dim dblZ_B() As Double
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' クラスの初期設定・Layerの管理を代行
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Public Sub Init(ByVal intInput As Integer, ByVal intOutput As Integer, ByVal intLayer As Integer, ByVal intUnits As Integer, ByVal dblLearningRate As Double)
        
        
        ReDim dblZ(1 To intOutput, 1 To 1) As Double
        ReDim dblZ_B(1 To intOutput, 1 To 1) As Double
        
        intInputCount = intInput
        intOutputCount = intOutput
        intLayerCount = intLayer
        intUnitCount = intUnits
        dblLR = dblLearningRate
        
        ReDim aryNetworks(1 To intLayerCount)
        
        Dim intLayerIndex As Integer
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            
            Set aryNetworks(intLayerIndex) = New ClassLayer
            
            If intLayerIndex = LBound(aryNetworks) Then
                Call aryNetworks(intLayerIndex).Init(intInputCount, intUnitCount, "ReLU", dblLearningRate, intLayerIndex)
            ElseIf intLayerIndex <> UBound(aryNetworks) Then
                Call aryNetworks(intLayerIndex).Init(intUnitCount, intUnitCount, "ReLU", dblLearningRate, intLayerIndex)
            Else
                Call aryNetworks(intLayerIndex).Init(intUnitCount, intOutputCount, "Sigmoid", dblLearningRate, intLayerIndex)
            End If
            
        Next
        
    End Sub
    
    '********************************************
    ' 学習
    '********************************************
    Public Sub Train(ByVal vntX As Variant, ByVal intTeach As Integer)
        
        Dim intLayerIndex As Integer
        Dim vntZ As Variant
        
        intT = intTeach
        vntZ = vntX
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            Call aryNetworks(intLayerIndex).Forward(vntZ, vntZ)
        Next
        
        dblZ(1, 1) = vntZ(1, 1)
        
        If dblZ(1, 1) <> 0 And dblZ(1, 1) <> 1 Then
            
            Call CrossEntropyLoss
            Call CrossEntropyLossBack
            
            Dim vntZ_B As Variant
            vntZ_B = dblZ_B
            
            For intLayerIndex = UBound(aryNetworks) To LBound(aryNetworks) Step -1
                Call aryNetworks(intLayerIndex).Backward(vntZ_B, vntZ_B)
            Next
        Else
            Debug.Print "error"
        End If
        
    End Sub
    
    '********************************************
    ' 目的関数・誤差計算
    '********************************************
    Private Sub CrossEntropyLoss()
        If intT = 1 Then
            dblE = (-intT) * Log(dblZ(1, 1))
        Else
            dblE = -(1 - intT) * Log(1 - dblZ(1, 1))
        End If
    End Sub
    
    '********************************************
    ' 目的関数・誤差計算逆伝播
    '********************************************
    Private Sub CrossEntropyLossBack()
        On Error Resume Next
        dblZ_B(1, 1) = (-intT / dblZ(1, 1)) + ((1 - intT) / (1 - dblZ(1, 1)))
        If Err.Number <> 0 Then
            dblZ_B(1, 1) = 0
        End If
        On Error GoTo 0
    End Sub
    
    '********************************************
    ' 予測
    '********************************************
    Public Function Predict(ByVal vntX As Variant) As Double
        
        Dim intLayerIndex As Integer
        Dim vntZ As Variant
        
        vntZ = vntX
        
        For intLayerIndex = LBound(aryNetworks) To UBound(aryNetworks)
            Call aryNetworks(intLayerIndex).Forward(vntZ, vntZ)
        Next
        
        Predict = vntZ(1, 1)
        
    End Function
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
'　JsonConverterの環境依存を解消
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    Option Explicit

    ''
    ' VBA-JSON v2.3.1
    ' (c) Tim Hall - https://github.com/VBA-tools/VBA-JSON
    '
    ' JSON Converter for VBA
    '
    ' Errors:
    ' 10001 - JSON parse error
    '
    ' @class JsonConverter
    ' @author tim.hall.engr@gmail.com
    ' @license MIT (http://www.opensource.org/licenses/mit-license.php)
    '' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
    '
    ' Based originally on vba-json (with extensive changes)
    ' BSD license included below
    '
    ' JSONLib, http://code.google.com/p/vba-json/
    '
    ' Copyright (c) 2013, Ryo Yokoyama
    ' All rights reserved.
    '
    ' Redistribution and use in source and binary forms, with or without
    ' modification, are permitted provided that the following conditions are met:
    '     * Redistributions of source code must retain the above copyright
    '       notice, this list of conditions and the following disclaimer.
    '     * Redistributions in binary form must reproduce the above copyright
    '       notice, this list of conditions and the following disclaimer in the
    '       documentation and/or other materials provided with the distribution.
    '     * Neither the name of the <organization> nor the
    '       names of its contributors may be used to endorse or promote products
    '       derived from this software without specific prior written permission.
    '
    ' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    ' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    ' DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    ' DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    ' (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    ' LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ' ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    ' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    ' SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    ' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
    
    ' === VBA-UTC Headers
    #If Mac Then
    
    #If VBA7 Then
    
    ' 64-bit Mac (2016)
    Private Declare PtrSafe Function utc_popen Lib "/usr/lib/libc.dylib" Alias "popen" _
        (ByVal utc_Command As String, ByVal utc_Mode As String) As LongPtr
    Private Declare PtrSafe Function utc_pclose Lib "/usr/lib/libc.dylib" Alias "pclose" _
        (ByVal utc_File As LongPtr) As LongPtr
    Private Declare PtrSafe Function utc_fread Lib "/usr/lib/libc.dylib" Alias "fread" _
        (ByVal utc_Buffer As String, ByVal utc_Size As LongPtr, ByVal utc_Number As LongPtr, ByVal utc_File As LongPtr) As LongPtr
    Private Declare PtrSafe Function utc_feof Lib "/usr/lib/libc.dylib" Alias "feof" _
        (ByVal utc_File As LongPtr) As LongPtr
    
    #Else
    
    ' 32-bit Mac
    Private Declare Function utc_popen Lib "libc.dylib" Alias "popen" _
        (ByVal utc_Command As String, ByVal utc_Mode As String) As Long
    Private Declare Function utc_pclose Lib "libc.dylib" Alias "pclose" _
        (ByVal utc_File As Long) As Long
    Private Declare Function utc_fread Lib "libc.dylib" Alias "fread" _
        (ByVal utc_Buffer As String, ByVal utc_Size As Long, ByVal utc_Number As Long, ByVal utc_File As Long) As Long
    Private Declare Function utc_feof Lib "libc.dylib" Alias "feof" _
        (ByVal utc_File As Long) As Long
    
    #End If
    
    #ElseIf VBA7 Then
    
    ' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724421.aspx
    ' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724949.aspx
    ' http://msdn.microsoft.com/en-us/library/windows/desktop/ms725485.aspx
    Private Declare PtrSafe Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
    Private Declare PtrSafe Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
    Private Declare PtrSafe Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long
    
    #Else
    
    Private Declare Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
    Private Declare Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
    Private Declare Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
        (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long
    
    #End If
    
    #If Mac Then
    
    #If VBA7 Then
    Private Type utc_ShellResult
        utc_Output As String
        utc_ExitCode As LongPtr
    End Type
    
    #Else
    
    Private Type utc_ShellResult
        utc_Output As String
        utc_ExitCode As Long
    End Type
    
    #End If
    
    #Else
    
    Private Type utc_SYSTEMTIME
        utc_wYear As Integer
        utc_wMonth As Integer
        utc_wDayOfWeek As Integer
        utc_wDay As Integer
        utc_wHour As Integer
        utc_wMinute As Integer
        utc_wSecond As Integer
        utc_wMilliseconds As Integer
    End Type
    
    Private Type utc_TIME_ZONE_INFORMATION
        utc_Bias As Long
        utc_StandardName(0 To 31) As Integer
        utc_StandardDate As utc_SYSTEMTIME
        utc_StandardBias As Long
        utc_DaylightName(0 To 31) As Integer
        utc_DaylightDate As utc_SYSTEMTIME
        utc_DaylightBias As Long
    End Type
    
    #End If
    ' === End VBA-UTC
    
    Private Type json_Options
        ' VBA only stores 15 significant digits, so any numbers larger than that are truncated
        ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
        ' See: http://support.microsoft.com/kb/269370
        '
        ' By default, VBA-JSON will use String for numbers longer than 15 characters that contain only digits
        ' to override set `JsonConverter.JsonOptions.UseDoubleForLargeNumbers = True`
        UseDoubleForLargeNumbers As Boolean
    
        ' The JSON standard requires object keys to be quoted (" or '), use this option to allow unquoted keys
        AllowUnquotedKeys As Boolean
    
        ' The solidus (/) is not required to be escaped, use this option to escape them as \/ in ConvertToJson
        EscapeSolidus As Boolean
    End Type
    Public JsonOptions As json_Options
    
    ' ============================================= '
    ' Public Methods
    ' ============================================= '
    
    ''
    ' Convert JSON string to object (Dictionary/Collection)
    '
    ' @method ParseJson
    ' @param {String} json_String
    ' @return {Object} (Dictionary or Collection)
    ' @throws 10001 - JSON parse error
    ''
    Public Function ParseJson(ByVal JsonString As String) As Object
        Dim json_Index As Long
        json_Index = 1
    
        ' Remove vbCr, vbLf, and vbTab from json_String
        JsonString = VBA.Replace(VBA.Replace(VBA.Replace(JsonString, VBA.vbCr, ""), VBA.vbLf, ""), VBA.vbTab, "")
    
        json_SkipSpaces JsonString, json_Index
        Select Case VBA.Mid$(JsonString, json_Index, 1)
        Case "{"
            Set ParseJson = json_ParseObject(JsonString, json_Index)
        Case "["
            Set ParseJson = json_ParseArray(JsonString, json_Index)
        Case Else
            ' Error: Invalid JSON string
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(JsonString, json_Index, "Expecting '{' or '['")
        End Select
    End Function
    
    ''
    ' Convert object (Dictionary/Collection/Array) to JSON
    '
    ' @method ConvertToJson
    ' @param {Variant} JsonValue (Dictionary, Collection, or Array)
    ' @param {Integer|String} Whitespace "Pretty" print json with given number of spaces per indentation (Integer) or given string
    ' @return {String}
    ''
    Public Function ConvertToJson(ByVal JsonValue As Variant, Optional ByVal Whitespace As Variant, Optional ByVal json_CurrentIndentation As Long = 0) As String
        Dim json_Buffer As String
        Dim json_BufferPosition As Long
        Dim json_BufferLength As Long
        Dim json_Index As Long
        Dim json_LBound As Long
        Dim json_UBound As Long
        Dim json_IsFirstItem As Boolean
        Dim json_Index2D As Long
        Dim json_LBound2D As Long
        Dim json_UBound2D As Long
        Dim json_IsFirstItem2D As Boolean
        Dim json_Key As Variant
        Dim json_Value As Variant
        Dim json_DateStr As String
        Dim json_Converted As String
        Dim json_SkipItem As Boolean
        Dim json_PrettyPrint As Boolean
        Dim json_Indentation As String
        Dim json_InnerIndentation As String
    
        json_LBound = -1
        json_UBound = -1
        json_IsFirstItem = True
        json_LBound2D = -1
        json_UBound2D = -1
        json_IsFirstItem2D = True
        json_PrettyPrint = Not IsMissing(Whitespace)
    
        Select Case VBA.VarType(JsonValue)
        Case VBA.vbNull
            ConvertToJson = "null"
        Case VBA.vbDate
            ' Date
            json_DateStr = ConvertToIso(VBA.CDate(JsonValue))
    
            ConvertToJson = """" & json_DateStr & """"
        Case VBA.vbString
            ' String (or large number encoded as string)
            If Not JsonOptions.UseDoubleForLargeNumbers And json_StringIsLargeNumber(JsonValue) Then
                ConvertToJson = JsonValue
            Else
                ConvertToJson = """" & json_Encode(JsonValue) & """"
            End If
        Case VBA.vbBoolean
            If JsonValue Then
                ConvertToJson = "true"
            Else
                ConvertToJson = "false"
            End If
        Case VBA.vbArray To VBA.vbArray + VBA.vbByte
            If json_PrettyPrint Then
                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
                    json_InnerIndentation = VBA.String$(json_CurrentIndentation + 2, Whitespace)
                Else
                    json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
                    json_InnerIndentation = VBA.Space$((json_CurrentIndentation + 2) * Whitespace)
                End If
            End If
    
            ' Array
            json_BufferAppend json_Buffer, "[", json_BufferPosition, json_BufferLength
    
            On Error Resume Next
    
            json_LBound = LBound(JsonValue, 1)
            json_UBound = UBound(JsonValue, 1)
            json_LBound2D = LBound(JsonValue, 2)
            json_UBound2D = UBound(JsonValue, 2)
    
            If json_LBound >= 0 And json_UBound >= 0 Then
                For json_Index = json_LBound To json_UBound
                    If json_IsFirstItem Then
                        json_IsFirstItem = False
                    Else
                        ' Append comma to previous line
                        json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                    End If
    
                    If json_LBound2D >= 0 And json_UBound2D >= 0 Then
                        ' 2D Array
                        If json_PrettyPrint Then
                            json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
                        End If
                        json_BufferAppend json_Buffer, json_Indentation & "[", json_BufferPosition, json_BufferLength
    
                        For json_Index2D = json_LBound2D To json_UBound2D
                            If json_IsFirstItem2D Then
                                json_IsFirstItem2D = False
                            Else
                                json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                            End If
    
                            json_Converted = ConvertToJson(JsonValue(json_Index, json_Index2D), Whitespace, json_CurrentIndentation + 2)
    
                            ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                            If json_Converted = "" Then
                                ' (nest to only check if converted = "")
                                If json_IsUndefined(JsonValue(json_Index, json_Index2D)) Then
                                    json_Converted = "null"
                                End If
                            End If
    
                            If json_PrettyPrint Then
                                json_Converted = vbNewLine & json_InnerIndentation & json_Converted
                            End If
    
                            json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                        Next json_Index2D
    
                        If json_PrettyPrint Then
                            json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
                        End If
    
                        json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
                        json_IsFirstItem2D = True
                    Else
                        ' 1D Array
                        json_Converted = ConvertToJson(JsonValue(json_Index), Whitespace, json_CurrentIndentation + 1)
    
                        ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                        If json_Converted = "" Then
                            ' (nest to only check if converted = "")
                            If json_IsUndefined(JsonValue(json_Index)) Then
                                json_Converted = "null"
                            End If
                        End If
    
                        If json_PrettyPrint Then
                            json_Converted = vbNewLine & json_Indentation & json_Converted
                        End If
    
                        json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                    End If
                Next json_Index
            End If
    
            On Error GoTo 0
    
            If json_PrettyPrint Then
                json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
    
                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                Else
                    json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                End If
            End If
    
            json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
    
            ConvertToJson = json_BufferToString(json_Buffer, json_BufferPosition)
    
        ' Dictionary or Collection
        Case VBA.vbObject
            If json_PrettyPrint Then
                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
                Else
                    json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
                End If
            End If
    
            ' Dictionary
            If VBA.TypeName(JsonValue) = "Dictionary" Then
                json_BufferAppend json_Buffer, "{", json_BufferPosition, json_BufferLength
                For Each json_Key In JsonValue.Keys
                    ' For Objects, undefined (Empty/Nothing) is not added to object
                    json_Converted = ConvertToJson(JsonValue(json_Key), Whitespace, json_CurrentIndentation + 1)
                    If json_Converted = "" Then
                        json_SkipItem = json_IsUndefined(JsonValue(json_Key))
                    Else
                        json_SkipItem = False
                    End If
    
                    If Not json_SkipItem Then
                        If json_IsFirstItem Then
                            json_IsFirstItem = False
                        Else
                            json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                        End If
    
                        If json_PrettyPrint Then
                            json_Converted = vbNewLine & json_Indentation & """" & json_Key & """: " & json_Converted
                        Else
                            json_Converted = """" & json_Key & """:" & json_Converted
                        End If
    
                        json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                    End If
                Next json_Key
    
                If json_PrettyPrint Then
                    json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
    
                    If VBA.VarType(Whitespace) = VBA.vbString Then
                        json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                    Else
                        json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                    End If
                End If
    
                json_BufferAppend json_Buffer, json_Indentation & "}", json_BufferPosition, json_BufferLength
    
            ' Collection
            ElseIf VBA.TypeName(JsonValue) = "Collection" Then
                json_BufferAppend json_Buffer, "[", json_BufferPosition, json_BufferLength
                For Each json_Value In JsonValue
                    If json_IsFirstItem Then
                        json_IsFirstItem = False
                    Else
                        json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                    End If
    
                    json_Converted = ConvertToJson(json_Value, Whitespace, json_CurrentIndentation + 1)
    
                    ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                    If json_Converted = "" Then
                        ' (nest to only check if converted = "")
                        If json_IsUndefined(json_Value) Then
                            json_Converted = "null"
                        End If
                    End If
    
                    If json_PrettyPrint Then
                        json_Converted = vbNewLine & json_Indentation & json_Converted
                    End If
    
                    json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                Next json_Value
    
                If json_PrettyPrint Then
                    json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
    
                    If VBA.VarType(Whitespace) = VBA.vbString Then
                        json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                    Else
                        json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                    End If
                End If
    
                json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
            End If
    
            ConvertToJson = json_BufferToString(json_Buffer, json_BufferPosition)
        Case VBA.vbInteger, VBA.vbLong, VBA.vbSingle, VBA.vbDouble, VBA.vbCurrency, VBA.vbDecimal
            ' Number (use decimals for numbers)
            ConvertToJson = VBA.Replace(JsonValue, ",", ".")
        Case Else
            ' vbEmpty, vbError, vbDataObject, vbByte, vbUserDefinedType
            ' Use VBA's built-in to-string
            On Error Resume Next
            ConvertToJson = JsonValue
            On Error GoTo 0
        End Select
    End Function
    
    ' ============================================= '
    ' Private Functions
    ' ============================================= '
    
    Private Function json_ParseObject(json_String As String, ByRef json_Index As Long) As Object
        Dim json_Key As String
        Dim json_NextChar As String
    
        Set json_ParseObject = CreateObject("Scripting.Dictionary")
        json_SkipSpaces json_String, json_Index
        If VBA.Mid$(json_String, json_Index, 1) <> "{" Then
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '{'")
        Else
            json_Index = json_Index + 1
    
            Do
                json_SkipSpaces json_String, json_Index
                If VBA.Mid$(json_String, json_Index, 1) = "}" Then
                    json_Index = json_Index + 1
                    Exit Function
                ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                    json_Index = json_Index + 1
                    json_SkipSpaces json_String, json_Index
                End If
    
                json_Key = json_ParseKey(json_String, json_Index)
                json_NextChar = json_Peek(json_String, json_Index)
                If json_NextChar = "[" Or json_NextChar = "{" Then
                    Set json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
                Else
                    json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
                End If
            Loop
        End If
    End Function
    
    Private Function json_ParseArray(json_String As String, ByRef json_Index As Long) As Collection
        Set json_ParseArray = New Collection
    
        json_SkipSpaces json_String, json_Index
        If VBA.Mid$(json_String, json_Index, 1) <> "[" Then
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '['")
        Else
            json_Index = json_Index + 1
    
            Do
                json_SkipSpaces json_String, json_Index
                If VBA.Mid$(json_String, json_Index, 1) = "]" Then
                    json_Index = json_Index + 1
                    Exit Function
                ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                    json_Index = json_Index + 1
                    json_SkipSpaces json_String, json_Index
                End If
    
                json_ParseArray.Add json_ParseValue(json_String, json_Index)
            Loop
        End If
    End Function
    
    Private Function json_ParseValue(json_String As String, ByRef json_Index As Long) As Variant
        json_SkipSpaces json_String, json_Index
        Select Case VBA.Mid$(json_String, json_Index, 1)
        Case "{"
            Set json_ParseValue = json_ParseObject(json_String, json_Index)
        Case "["
            Set json_ParseValue = json_ParseArray(json_String, json_Index)
        Case """", "'"
            json_ParseValue = json_ParseString(json_String, json_Index)
        Case Else
            If VBA.Mid$(json_String, json_Index, 4) = "true" Then
                json_ParseValue = True
                json_Index = json_Index + 4
            ElseIf VBA.Mid$(json_String, json_Index, 5) = "false" Then
                json_ParseValue = False
                json_Index = json_Index + 5
            ElseIf VBA.Mid$(json_String, json_Index, 4) = "null" Then
                json_ParseValue = Null
                json_Index = json_Index + 4
            ElseIf VBA.InStr("+-0123456789", VBA.Mid$(json_String, json_Index, 1)) Then
                json_ParseValue = json_ParseNumber(json_String, json_Index)
            Else
                Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['")
            End If
        End Select
    End Function
    
    Private Function json_ParseString(json_String As String, ByRef json_Index As Long) As String
        Dim json_Quote As String
        Dim json_Char As String
        Dim json_Code As String
        Dim json_Buffer As String
        Dim json_BufferPosition As Long
        Dim json_BufferLength As Long
    
        json_SkipSpaces json_String, json_Index
    
        ' Store opening quote to look for matching closing quote
        json_Quote = VBA.Mid$(json_String, json_Index, 1)
        json_Index = json_Index + 1
    
        Do While json_Index > 0 And json_Index <= Len(json_String)
            json_Char = VBA.Mid$(json_String, json_Index, 1)
    
            Select Case json_Char
            Case "\"
                ' Escaped string, \\, or \/
                json_Index = json_Index + 1
                json_Char = VBA.Mid$(json_String, json_Index, 1)
    
                Select Case json_Char
                Case """", "\", "/", "'"
                    json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "b"
                    json_BufferAppend json_Buffer, vbBack, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "f"
                    json_BufferAppend json_Buffer, vbFormFeed, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "n"
                    json_BufferAppend json_Buffer, vbCrLf, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "r"
                    json_BufferAppend json_Buffer, vbCr, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "t"
                    json_BufferAppend json_Buffer, vbTab, json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 1
                Case "u"
                    ' Unicode character escape (e.g. \u00a9 = Copyright)
                    json_Index = json_Index + 1
                    json_Code = VBA.Mid$(json_String, json_Index, 4)
                    json_BufferAppend json_Buffer, VBA.ChrW(VBA.Val("&h" + json_Code)), json_BufferPosition, json_BufferLength
                    json_Index = json_Index + 4
                End Select
            Case json_Quote
                json_ParseString = json_BufferToString(json_Buffer, json_BufferPosition)
                json_Index = json_Index + 1
                Exit Function
            Case Else
                json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            End Select
        Loop
    End Function
    
    Private Function json_ParseNumber(json_String As String, ByRef json_Index As Long) As Variant
        Dim json_Char As String
        Dim json_Value As String
        Dim json_IsLargeNumber As Boolean
    
        json_SkipSpaces json_String, json_Index
    
        Do While json_Index > 0 And json_Index <= Len(json_String)
            json_Char = VBA.Mid$(json_String, json_Index, 1)
    
            If VBA.InStr("+-0123456789.eE", json_Char) Then
                ' Unlikely to have massive number, so use simple append rather than buffer here
                json_Value = json_Value & json_Char
                json_Index = json_Index + 1
            Else
                ' Excel only stores 15 significant digits, so any numbers larger than that are truncated
                ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
                ' See: http://support.microsoft.com/kb/269370
                '
                ' Fix: Parse -> String, Convert -> String longer than 15/16 characters containing only numbers and decimal points -> Number
                ' (decimal doesn't factor into significant digit count, so if present check for 15 digits + decimal = 16)
                json_IsLargeNumber = IIf(InStr(json_Value, "."), Len(json_Value) >= 17, Len(json_Value) >= 16)
                If Not JsonOptions.UseDoubleForLargeNumbers And json_IsLargeNumber Then
                    json_ParseNumber = json_Value
                Else
                    ' VBA.Val does not use regional settings, so guard for comma is not needed
                    json_ParseNumber = VBA.Val(json_Value)
                End If
                Exit Function
            End If
        Loop
    End Function
    
    Private Function json_ParseKey(json_String As String, ByRef json_Index As Long) As String
        ' Parse key with single or double quotes
        If VBA.Mid$(json_String, json_Index, 1) = """" Or VBA.Mid$(json_String, json_Index, 1) = "'" Then
            json_ParseKey = json_ParseString(json_String, json_Index)
        ElseIf JsonOptions.AllowUnquotedKeys Then
            Dim json_Char As String
            Do While json_Index > 0 And json_Index <= Len(json_String)
                json_Char = VBA.Mid$(json_String, json_Index, 1)
                If (json_Char <> " ") And (json_Char <> ":") Then
                    json_ParseKey = json_ParseKey & json_Char
                    json_Index = json_Index + 1
                Else
                    Exit Do
                End If
            Loop
        Else
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '""' or '''")
        End If
    
        ' Check for colon and skip if present or throw if not present
        json_SkipSpaces json_String, json_Index
        If VBA.Mid$(json_String, json_Index, 1) <> ":" Then
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting ':'")
        Else
            json_Index = json_Index + 1
        End If
    End Function
    
    Private Function json_IsUndefined(ByVal json_Value As Variant) As Boolean
        ' Empty / Nothing -> undefined
        Select Case VBA.VarType(json_Value)
        Case VBA.vbEmpty
            json_IsUndefined = True
        Case VBA.vbObject
            Select Case VBA.TypeName(json_Value)
            Case "Empty", "Nothing"
                json_IsUndefined = True
            End Select
        End Select
    End Function
    
    Private Function json_Encode(ByVal json_Text As Variant) As String
        ' Reference: http://www.ietf.org/rfc/rfc4627.txt
        ' Escape: ", \, /, backspace, form feed, line feed, carriage return, tab
        Dim json_Index As Long
        Dim json_Char As String
        Dim json_AscCode As Long
        Dim json_Buffer As String
        Dim json_BufferPosition As Long
        Dim json_BufferLength As Long
    
        For json_Index = 1 To VBA.Len(json_Text)
            json_Char = VBA.Mid$(json_Text, json_Index, 1)
            json_AscCode = VBA.AscW(json_Char)
    
            ' When AscW returns a negative number, it returns the twos complement form of that number.
            ' To convert the twos complement notation into normal binary notation, add 0xFFF to the return result.
            ' https://support.microsoft.com/en-us/kb/272138
            If json_AscCode < 0 Then
                json_AscCode = json_AscCode + 65536
            End If
    
            ' From spec, ", \, and control characters must be escaped (solidus is optional)
    
            Select Case json_AscCode
            Case 34
                ' " -> 34 -> \"
                json_Char = "\"""
            Case 92
                ' \ -> 92 -> \\
                json_Char = "\\"
            Case 47
                ' / -> 47 -> \/ (optional)
                If JsonOptions.EscapeSolidus Then
                    json_Char = "\/"
                End If
            Case 8
                ' backspace -> 8 -> \b
                json_Char = "\b"
            Case 12
                ' form feed -> 12 -> \f
                json_Char = "\f"
            Case 10
                ' line feed -> 10 -> \n
                json_Char = "\n"
            Case 13
                ' carriage return -> 13 -> \r
                json_Char = "\r"
            Case 9
                ' tab -> 9 -> \t
                json_Char = "\t"
            Case 0 To 31, 127 To 65535
                ' Non-ascii characters -> convert to 4-digit hex
                json_Char = "\u" & VBA.Right$("0000" & VBA.Hex$(json_AscCode), 4)
            End Select
    
            json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
        Next json_Index
    
        json_Encode = json_BufferToString(json_Buffer, json_BufferPosition)
    End Function
    
    Private Function json_Peek(json_String As String, ByVal json_Index As Long, Optional json_NumberOfCharacters As Long = 1) As String
        ' "Peek" at the next number of characters without incrementing json_Index (ByVal instead of ByRef)
        json_SkipSpaces json_String, json_Index
        json_Peek = VBA.Mid$(json_String, json_Index, json_NumberOfCharacters)
    End Function
    
    Private Sub json_SkipSpaces(json_String As String, ByRef json_Index As Long)
        ' Increment index to skip over spaces
        Do While json_Index > 0 And json_Index <= VBA.Len(json_String) And VBA.Mid$(json_String, json_Index, 1) = " "
            json_Index = json_Index + 1
        Loop
    End Sub
    
    Private Function json_StringIsLargeNumber(json_String As Variant) As Boolean
        ' Check if the given string is considered a "large number"
        ' (See json_ParseNumber)
    
        Dim json_Length As Long
        Dim json_CharIndex As Long
        json_Length = VBA.Len(json_String)
    
        ' Length with be at least 16 characters and assume will be less than 100 characters
        If json_Length >= 16 And json_Length <= 100 Then
            Dim json_CharCode As String
    
            json_StringIsLargeNumber = True
    
            For json_CharIndex = 1 To json_Length
                json_CharCode = VBA.Asc(VBA.Mid$(json_String, json_CharIndex, 1))
                Select Case json_CharCode
                ' Look for .|0-9|E|e
                Case 46, 48 To 57, 69, 101
                    ' Continue through characters
                Case Else
                    json_StringIsLargeNumber = False
                    Exit Function
                End Select
            Next json_CharIndex
        End If
    End Function
    
    Private Function json_ParseErrorMessage(json_String As String, ByRef json_Index As Long, ErrorMessage As String)
        ' Provide detailed parse error message, including details of where and what occurred
        '
        ' Example:
        ' Error parsing JSON:
        ' {"abcde":True}
        '          ^
        ' Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['
    
        Dim json_StartIndex As Long
        Dim json_StopIndex As Long
    
        ' Include 10 characters before and after error (if possible)
        json_StartIndex = json_Index - 10
        json_StopIndex = json_Index + 10
        If json_StartIndex <= 0 Then
            json_StartIndex = 1
        End If
        If json_StopIndex > VBA.Len(json_String) Then
            json_StopIndex = VBA.Len(json_String)
        End If
    
        json_ParseErrorMessage = "Error parsing JSON:" & VBA.vbNewLine & _
                                    VBA.Mid$(json_String, json_StartIndex, json_StopIndex - json_StartIndex + 1) & VBA.vbNewLine & _
                                    VBA.Space$(json_Index - json_StartIndex) & "^" & VBA.vbNewLine & _
                                    ErrorMessage
    End Function
    
    Private Sub json_BufferAppend(ByRef json_Buffer As String, _
                                    ByRef json_Append As Variant, _
                                    ByRef json_BufferPosition As Long, _
                                    ByRef json_BufferLength As Long)
        ' VBA can be slow to append strings due to allocating a new string for each append
        ' Instead of using the traditional append, allocate a large empty string and then copy string at append position
        '
        ' Example:
        ' Buffer: "abc  "
        ' Append: "def"
        ' Buffer Position: 3
        ' Buffer Length: 5
        '
        ' Buffer position + Append length > Buffer length -> Append chunk of blank space to buffer
        ' Buffer: "abc       "
        ' Buffer Length: 10
        '
        ' Put "def" into buffer at position 3 (0-based)
        ' Buffer: "abcdef    "
        '
        ' Approach based on cStringBuilder from vbAccelerator
        ' http://www.vbaccelerator.com/home/VB/Code/Techniques/RunTime_Debug_Tracing/VB6_Tracer_Utility_zip_cStringBuilder_cls.asp
        '
        ' and clsStringAppend from Philip Swannell
        ' https://github.com/VBA-tools/VBA-JSON/pull/82
    
        Dim json_AppendLength As Long
        Dim json_LengthPlusPosition As Long
    
        json_AppendLength = VBA.Len(json_Append)
        json_LengthPlusPosition = json_AppendLength + json_BufferPosition
    
        If json_LengthPlusPosition > json_BufferLength Then
            ' Appending would overflow buffer, add chunk
            ' (double buffer length or append length, whichever is bigger)
            Dim json_AddedLength As Long
            json_AddedLength = IIf(json_AppendLength > json_BufferLength, json_AppendLength, json_BufferLength)
    
            json_Buffer = json_Buffer & VBA.Space$(json_AddedLength)
            json_BufferLength = json_BufferLength + json_AddedLength
        End If
    
        ' Note: Namespacing with VBA.Mid$ doesn't work properly here, throwing compile error:
        ' Function call on left-hand side of assignment must return Variant or Object
        Mid$(json_Buffer, json_BufferPosition + 1, json_AppendLength) = CStr(json_Append)
        json_BufferPosition = json_BufferPosition + json_AppendLength
    End Sub
    
    Private Function json_BufferToString(ByRef json_Buffer As String, ByVal json_BufferPosition As Long) As String
        If json_BufferPosition > 0 Then
            json_BufferToString = VBA.Left$(json_Buffer, json_BufferPosition)
        End If
    End Function
    
    ''
    ' VBA-UTC v1.0.6
    ' (c) Tim Hall - https://github.com/VBA-tools/VBA-UtcConverter
    '
    ' UTC/ISO 8601 Converter for VBA
    '
    ' Errors:
    ' 10011 - UTC parsing error
    ' 10012 - UTC conversion error
    ' 10013 - ISO 8601 parsing error
    ' 10014 - ISO 8601 conversion error
    '
    ' @module UtcConverter
    ' @author tim.hall.engr@gmail.com
    ' @license MIT (http://www.opensource.org/licenses/mit-license.php)
    '' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
    
    ' (Declarations moved to top)
    
    ' ============================================= '
    ' Public Methods
    ' ============================================= '
    
    ''
    ' Parse UTC date to local date
    '
    ' @method ParseUtc
    ' @param {Date} UtcDate
    ' @return {Date} Local date
    ' @throws 10011 - UTC parsing error
    ''
    Public Function ParseUtc(utc_UtcDate As Date) As Date
        On Error GoTo utc_ErrorHandling
    
    #If Mac Then
        ParseUtc = utc_ConvertDate(utc_UtcDate)
    #Else
        Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
        Dim utc_LocalDate As utc_SYSTEMTIME
    
        utc_GetTimeZoneInformation utc_TimeZoneInfo
        utc_SystemTimeToTzSpecificLocalTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_UtcDate), utc_LocalDate
    
        ParseUtc = utc_SystemTimeToDate(utc_LocalDate)
    #End If
    
        Exit Function
    
    utc_ErrorHandling:
        Err.Raise 10011, "UtcConverter.ParseUtc", "UTC parsing error: " & Err.Number & " - " & Err.Description
    End Function
    
    ''
    ' Convert local date to UTC date
    '
    ' @method ConvertToUrc
    ' @param {Date} utc_LocalDate
    ' @return {Date} UTC date
    ' @throws 10012 - UTC conversion error
    ''
    Public Function ConvertToUtc(utc_LocalDate As Date) As Date
        On Error GoTo utc_ErrorHandling
    
    #If Mac Then
        ConvertToUtc = utc_ConvertDate(utc_LocalDate, utc_ConvertToUtc:=True)
    #Else
        Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
        Dim utc_UtcDate As utc_SYSTEMTIME
    
        utc_GetTimeZoneInformation utc_TimeZoneInfo
        utc_TzSpecificLocalTimeToSystemTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_LocalDate), utc_UtcDate
    
        ConvertToUtc = utc_SystemTimeToDate(utc_UtcDate)
    #End If
    
        Exit Function
    
    utc_ErrorHandling:
        Err.Raise 10012, "UtcConverter.ConvertToUtc", "UTC conversion error: " & Err.Number & " - " & Err.Description
    End Function
    
    ''
    ' Parse ISO 8601 date string to local date
    '
    ' @method ParseIso
    ' @param {Date} utc_IsoString
    ' @return {Date} Local date
    ' @throws 10013 - ISO 8601 parsing error
    ''
    Public Function ParseIso(utc_IsoString As String) As Date
        On Error GoTo utc_ErrorHandling
    
        Dim utc_Parts() As String
        Dim utc_DateParts() As String
        Dim utc_TimeParts() As String
        Dim utc_OffsetIndex As Long
        Dim utc_HasOffset As Boolean
        Dim utc_NegativeOffset As Boolean
        Dim utc_OffsetParts() As String
        Dim utc_Offset As Date
    
        utc_Parts = VBA.Split(utc_IsoString, "T")
        utc_DateParts = VBA.Split(utc_Parts(0), "-")
        ParseIso = VBA.DateSerial(VBA.CInt(utc_DateParts(0)), VBA.CInt(utc_DateParts(1)), VBA.CInt(utc_DateParts(2)))
    
        If UBound(utc_Parts) > 0 Then
            If VBA.InStr(utc_Parts(1), "Z") Then
                utc_TimeParts = VBA.Split(VBA.Replace(utc_Parts(1), "Z", ""), ":")
            Else
                utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "+")
                If utc_OffsetIndex = 0 Then
                    utc_NegativeOffset = True
                    utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "-")
                End If
    
                If utc_OffsetIndex > 0 Then
                    utc_HasOffset = True
                    utc_TimeParts = VBA.Split(VBA.Left$(utc_Parts(1), utc_OffsetIndex - 1), ":")
                    utc_OffsetParts = VBA.Split(VBA.Right$(utc_Parts(1), Len(utc_Parts(1)) - utc_OffsetIndex), ":")
    
                    Select Case UBound(utc_OffsetParts)
                    Case 0
                        utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), 0, 0)
                    Case 1
                        utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), 0)
                    Case 2
                        ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
                        utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), Int(VBA.Val(utc_OffsetParts(2))))
                    End Select
    
                    If utc_NegativeOffset Then: utc_Offset = -utc_Offset
                Else
                    utc_TimeParts = VBA.Split(utc_Parts(1), ":")
                End If
            End If
    
            Select Case UBound(utc_TimeParts)
            Case 0
                ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), 0, 0)
            Case 1
                ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), 0)
            Case 2
                ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
                ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), Int(VBA.Val(utc_TimeParts(2))))
            End Select
    
            ParseIso = ParseUtc(ParseIso)
    
            If utc_HasOffset Then
                ParseIso = ParseIso - utc_Offset
            End If
        End If
    
        Exit Function
    
    utc_ErrorHandling:
        Err.Raise 10013, "UtcConverter.ParseIso", "ISO 8601 parsing error for " & utc_IsoString & ": " & Err.Number & " - " & Err.Description
    End Function
    
    ''
    ' Convert local date to ISO 8601 string
    '
    ' @method ConvertToIso
    ' @param {Date} utc_LocalDate
    ' @return {Date} ISO 8601 string
    ' @throws 10014 - ISO 8601 conversion error
    ''
    Public Function ConvertToIso(utc_LocalDate As Date) As String
        On Error GoTo utc_ErrorHandling
    
        ConvertToIso = VBA.Format$(ConvertToUtc(utc_LocalDate), "yyyy-mm-ddTHH:mm:ss.000Z")
    
        Exit Function
    
    utc_ErrorHandling:
        Err.Raise 10014, "UtcConverter.ConvertToIso", "ISO 8601 conversion error: " & Err.Number & " - " & Err.Description
    End Function
    
    ' ============================================= '
    ' Private Functions
    ' ============================================= '
    
    #If Mac Then
    
    Private Function utc_ConvertDate(utc_Value As Date, Optional utc_ConvertToUtc As Boolean = False) As Date
        Dim utc_ShellCommand As String
        Dim utc_Result As utc_ShellResult
        Dim utc_Parts() As String
        Dim utc_DateParts() As String
        Dim utc_TimeParts() As String
    
        If utc_ConvertToUtc Then
            utc_ShellCommand = "date -ur `date -jf '%Y-%m-%d %H:%M:%S' " & _
                "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & "' " & _
                " +'%s'` +'%Y-%m-%d %H:%M:%S'"
        Else
            utc_ShellCommand = "date -jf '%Y-%m-%d %H:%M:%S %z' " & _
                "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & " +0000' " & _
                "+'%Y-%m-%d %H:%M:%S'"
        End If
    
        utc_Result = utc_ExecuteInShell(utc_ShellCommand)
    
        If utc_Result.utc_Output = "" Then
            Err.Raise 10015, "UtcConverter.utc_ConvertDate", "'date' command failed"
        Else
            utc_Parts = Split(utc_Result.utc_Output, " ")
            utc_DateParts = Split(utc_Parts(0), "-")
            utc_TimeParts = Split(utc_Parts(1), ":")
    
            utc_ConvertDate = DateSerial(utc_DateParts(0), utc_DateParts(1), utc_DateParts(2)) + _
                TimeSerial(utc_TimeParts(0), utc_TimeParts(1), utc_TimeParts(2))
        End If
    End Function
    
    Private Function utc_ExecuteInShell(utc_ShellCommand As String) As utc_ShellResult
    #If VBA7 Then
        Dim utc_File As LongPtr
        Dim utc_Read As LongPtr
    #Else
        Dim utc_File As Long
        Dim utc_Read As Long
    #End If
    
        Dim utc_Chunk As String
    
        On Error GoTo utc_ErrorHandling
        utc_File = utc_popen(utc_ShellCommand, "r")
    
        If utc_File = 0 Then: Exit Function
    
        Do While utc_feof(utc_File) = 0
            utc_Chunk = VBA.Space$(50)
            utc_Read = CLng(utc_fread(utc_Chunk, 1, Len(utc_Chunk) - 1, utc_File))
            If utc_Read > 0 Then
                utc_Chunk = VBA.Left$(utc_Chunk, CLng(utc_Read))
                utc_ExecuteInShell.utc_Output = utc_ExecuteInShell.utc_Output & utc_Chunk
            End If
        Loop
    
    utc_ErrorHandling:
        utc_ExecuteInShell.utc_ExitCode = CLng(utc_pclose(utc_File))
    End Function
    
    #Else
    
    Private Function utc_DateToSystemTime(utc_Value As Date) As utc_SYSTEMTIME
        utc_DateToSystemTime.utc_wYear = VBA.Year(utc_Value)
        utc_DateToSystemTime.utc_wMonth = VBA.Month(utc_Value)
        utc_DateToSystemTime.utc_wDay = VBA.Day(utc_Value)
        utc_DateToSystemTime.utc_wHour = VBA.Hour(utc_Value)
        utc_DateToSystemTime.utc_wMinute = VBA.Minute(utc_Value)
        utc_DateToSystemTime.utc_wSecond = VBA.Second(utc_Value)
        utc_DateToSystemTime.utc_wMilliseconds = 0
    End Function
    
    Private Function utc_SystemTimeToDate(utc_Value As utc_SYSTEMTIME) As Date
        utc_SystemTimeToDate = DateSerial(utc_Value.utc_wYear, utc_Value.utc_wMonth, utc_Value.utc_wDay) + _
            TimeSerial(utc_Value.utc_wHour, utc_Value.utc_wMinute, utc_Value.utc_wSecond)
    End Function
    
    #End If
                    </pre>
                </div>
                <div class="vba-code">
                    <pre class="prettyprint lang-vb linenums" lang="vb">
    
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
'
' 頻出定数・短コード
'
'■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    
    Const strFileFilterCsv As String = "CSVファイル(*.csv),*.csv"
    Const strFileFilterXL As String = "エクセルファイル (*.xls?),*.xls?"
    
    CreateObject("WScript.Shell").CurrentDirectory = "FileServer"                    
                    </pre>
                </div>
            </div>
        </div>
    </main>
    <footer>
        <div class="container">
            <a href="https://twitter.com/office_diet" target="_blank">all right not reserved 24時間散歩おじさん
        </div>
    </footer>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=vbs&skin=sons-of-obsidian"></script>
    <script src="vba.js"></script>
</body>
</html>